!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ABS	cram/rANS_static.c	54;"	d	file:
AC_KSEQ_H	htslib/kseq.h	29;"	d
AC_KSORT_H	htslib/ksort.h	63;"	d
AC_VERSION_KHASH_H	htslib/khash.h	126;"	d
AP_delta	cram/cram_structs.h	/^    int AP_delta;$/;"	m	struct:cram_block_compression_hdr
AR	Makefile	/^AR     = ar$/;"	m
AUTH_LIFETIME	hfile_s3.c	53;"	d	file:
B	cram/cram_structs.h	/^	} B;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon83
BAM_CBACK	htslib/sam.h	74;"	d
BAM_CBASE_MATCH	cram/cram_samtools.h	/^    BAM_CBASE_MATCH=BAM_CEQUAL,$/;"	e	enum:cigar_op
BAM_CBASE_MISMATCH	cram/cram_samtools.h	/^    BAM_CBASE_MISMATCH=BAM_CDIFF$/;"	e	enum:cigar_op
BAM_CDEL	htslib/sam.h	67;"	d
BAM_CDEL_	cram/cram_samtools.h	/^    BAM_CDEL_=BAM_CDEL,$/;"	e	enum:cigar_op
BAM_CDIFF	htslib/sam.h	73;"	d
BAM_CEQUAL	htslib/sam.h	72;"	d
BAM_CHARD_CLIP	htslib/sam.h	70;"	d
BAM_CHARD_CLIP_	cram/cram_samtools.h	/^    BAM_CHARD_CLIP_=BAM_CHARD_CLIP,$/;"	e	enum:cigar_op
BAM_CIGAR_MASK	htslib/sam.h	78;"	d
BAM_CIGAR_SHIFT	htslib/sam.h	77;"	d
BAM_CIGAR_STR	htslib/sam.h	76;"	d
BAM_CIGAR_TYPE	htslib/sam.h	79;"	d
BAM_CINS	htslib/sam.h	66;"	d
BAM_CINS_	cram/cram_samtools.h	/^    BAM_CINS_=BAM_CINS,$/;"	e	enum:cigar_op
BAM_CMATCH	htslib/sam.h	65;"	d
BAM_CMATCH_	cram/cram_samtools.h	/^    BAM_CMATCH_=BAM_CMATCH,$/;"	e	enum:cigar_op
BAM_CPAD	htslib/sam.h	71;"	d
BAM_CPAD_	cram/cram_samtools.h	/^    BAM_CPAD_=BAM_CPAD,$/;"	e	enum:cigar_op
BAM_CREF_SKIP	htslib/sam.h	68;"	d
BAM_CREF_SKIP_	cram/cram_samtools.h	/^    BAM_CREF_SKIP_=BAM_CREF_SKIP,$/;"	e	enum:cigar_op
BAM_CSOFT_CLIP	htslib/sam.h	69;"	d
BAM_CSOFT_CLIP_	cram/cram_samtools.h	/^    BAM_CSOFT_CLIP_=BAM_CSOFT_CLIP,$/;"	e	enum:cigar_op
BAM_FDUP	htslib/sam.h	132;"	d
BAM_FMREVERSE	htslib/sam.h	122;"	d
BAM_FMUNMAP	htslib/sam.h	118;"	d
BAM_FPAIRED	htslib/sam.h	112;"	d
BAM_FPROPER_PAIR	htslib/sam.h	114;"	d
BAM_FQCFAIL	htslib/sam.h	130;"	d
BAM_FREAD1	htslib/sam.h	124;"	d
BAM_FREAD2	htslib/sam.h	126;"	d
BAM_FREVERSE	htslib/sam.h	120;"	d
BAM_FSECONDARY	htslib/sam.h	128;"	d
BAM_FSUPPLEMENTARY	htslib/sam.h	134;"	d
BAM_FUNMAP	htslib/sam.h	116;"	d
BASES_PER_SLICE	cram/cram_structs.h	87;"	d
BCF1_DIRTY_ALS	htslib/vcf.h	170;"	d
BCF1_DIRTY_FLT	htslib/vcf.h	171;"	d
BCF1_DIRTY_ID	htslib/vcf.h	169;"	d
BCF1_DIRTY_INF	htslib/vcf.h	172;"	d
BCF_BT_CHAR	htslib/vcf.h	133;"	d
BCF_BT_FLOAT	htslib/vcf.h	132;"	d
BCF_BT_INT16	htslib/vcf.h	130;"	d
BCF_BT_INT32	htslib/vcf.h	131;"	d
BCF_BT_INT8	htslib/vcf.h	129;"	d
BCF_BT_NULL	htslib/vcf.h	128;"	d
BCF_DT_CTG	htslib/vcf.h	83;"	d
BCF_DT_ID	htslib/vcf.h	82;"	d
BCF_DT_SAMPLE	htslib/vcf.h	84;"	d
BCF_ERR_CHAR	htslib/vcf.h	193;"	d
BCF_ERR_CTG_INVALID	htslib/vcf.h	194;"	d
BCF_ERR_CTG_UNDEF	htslib/vcf.h	189;"	d
BCF_ERR_LIMITS	htslib/vcf.h	192;"	d
BCF_ERR_NCOLS	htslib/vcf.h	191;"	d
BCF_ERR_TAG_INVALID	htslib/vcf.h	195;"	d
BCF_ERR_TAG_UNDEF	htslib/vcf.h	190;"	d
BCF_HL_CTG	htslib/vcf.h	55;"	d
BCF_HL_FLT	htslib/vcf.h	52;"	d
BCF_HL_FMT	htslib/vcf.h	54;"	d
BCF_HL_GEN	htslib/vcf.h	57;"	d
BCF_HL_INFO	htslib/vcf.h	53;"	d
BCF_HL_STR	htslib/vcf.h	56;"	d
BCF_HT_FLAG	htslib/vcf.h	59;"	d
BCF_HT_INT	htslib/vcf.h	60;"	d
BCF_HT_REAL	htslib/vcf.h	61;"	d
BCF_HT_STR	htslib/vcf.h	62;"	d
BCF_SR_AUX	synced_bcf_reader.c	56;"	d	file:
BCF_SR_PAIR_ANY	htslib/synced_bcf_reader.h	87;"	d
BCF_SR_PAIR_BOTH	htslib/synced_bcf_reader.h	92;"	d
BCF_SR_PAIR_BOTH_REF	htslib/synced_bcf_reader.h	93;"	d
BCF_SR_PAIR_EXACT	htslib/synced_bcf_reader.h	91;"	d
BCF_SR_PAIR_INDELS	htslib/synced_bcf_reader.h	86;"	d
BCF_SR_PAIR_INDEL_REF	htslib/synced_bcf_reader.h	90;"	d
BCF_SR_PAIR_LOGIC	htslib/synced_bcf_reader.h	/^    BCF_SR_PAIR_LOGIC       \/\/ combination of the PAIR_* values above$/;"	e	enum:__anon28
BCF_SR_PAIR_SNPS	htslib/synced_bcf_reader.h	85;"	d
BCF_SR_PAIR_SNP_REF	htslib/synced_bcf_reader.h	89;"	d
BCF_SR_PAIR_SOME	htslib/synced_bcf_reader.h	88;"	d
BCF_SR_REQUIRE_IDX	htslib/synced_bcf_reader.h	/^    BCF_SR_REQUIRE_IDX,$/;"	e	enum:__anon28
BCF_UN_ALL	htslib/vcf.h	354;"	d
BCF_UN_FLT	htslib/vcf.h	349;"	d
BCF_UN_FMT	htslib/vcf.h	352;"	d
BCF_UN_IND	htslib/vcf.h	353;"	d
BCF_UN_INFO	htslib/vcf.h	350;"	d
BCF_UN_SHR	htslib/vcf.h	351;"	d
BCF_UN_STR	htslib/vcf.h	348;"	d
BCF_VL_A	htslib/vcf.h	66;"	d
BCF_VL_FIXED	htslib/vcf.h	64;"	d
BCF_VL_G	htslib/vcf.h	67;"	d
BCF_VL_R	htslib/vcf.h	68;"	d
BCF_VL_VAR	htslib/vcf.h	65;"	d
BEEF	test/sam.c	100;"	d	file:
BGZF	htslib/bgzf.h	/^struct BGZF {$/;"	s
BGZF	htslib/bgzf.h	/^typedef struct BGZF BGZF;$/;"	t	typeref:struct:BGZF
BGZF	htslib/hts.h	/^typedef struct BGZF BGZF;$/;"	t	typeref:struct:BGZF
BGZF_BLOCK_SIZE	htslib/bgzf.h	44;"	d
BGZF_CACHE	bgzf.c	45;"	d	file:
BGZF_ERR_CRC	htslib/bgzf.h	52;"	d
BGZF_ERR_HEADER	htslib/bgzf.h	48;"	d
BGZF_ERR_IO	htslib/bgzf.h	49;"	d
BGZF_ERR_MISUSE	htslib/bgzf.h	50;"	d
BGZF_ERR_MT	htslib/bgzf.h	51;"	d
BGZF_ERR_ZLIB	htslib/bgzf.h	47;"	d
BGZF_MAX_BLOCK_SIZE	htslib/bgzf.h	45;"	d
BGZF_MT	bgzf.c	46;"	d	file:
BLK_SIZE	cram/rANS_static.c	56;"	d	file:
BLK_SIZE2	cram/rANS_static.c	60;"	d	file:
BLOCK_APPEND	cram/cram_io.h	520;"	d
BLOCK_APPEND_CHAR	cram/cram_io.h	528;"	d
BLOCK_APPEND_UINT	cram/cram_io.h	535;"	d
BLOCK_DATA	cram/cram_io.h	495;"	d
BLOCK_END	cram/cram_io.h	498;"	d
BLOCK_FOOTER_LENGTH	bgzf.c	49;"	d	file:
BLOCK_GROW	cram/cram_io.h	517;"	d
BLOCK_HEADER_LENGTH	bgzf.c	48;"	d	file:
BLOCK_RESIZE	cram/cram_io.h	501;"	d
BLOCK_RESIZE_EXACT	cram/cram_io.h	510;"	d
BLOCK_SIZE	cram/cram_io.h	494;"	d
BLOCK_UPLEN	cram/cram_io.h	613;"	d
BM_ERROR	cram/cram_structs.h	/^    BM_ERROR = -1,$/;"	e	enum:cram_block_method
BRANCH	htslib/vcf.h	901;"	d
BRANCH	htslib/vcf.h	919;"	d
BRANCH	vcf.c	1818;"	d	file:
BRANCH	vcf.c	1836;"	d	file:
BRANCH	vcf.c	3725;"	d	file:
BRANCH	vcf.c	3744;"	d	file:
BRANCH	vcf.c	3829;"	d	file:
BRANCH	vcf.c	3853;"	d	file:
BRANCH	vcfutils.c	181;"	d	file:
BRANCH	vcfutils.c	207;"	d	file:
BRANCH	vcfutils.c	385;"	d	file:
BRANCH	vcfutils.c	396;"	d	file:
BRANCH	vcfutils.c	428;"	d	file:
BRANCH	vcfutils.c	445;"	d	file:
BRANCH	vcfutils.c	458;"	d	file:
BRANCH	vcfutils.c	479;"	d	file:
BRANCH	vcfutils.c	683;"	d	file:
BRANCH	vcfutils.c	697;"	d	file:
BRANCH	vcfutils.c	728;"	d	file:
BRANCH	vcfutils.c	750;"	d	file:
BRANCH	vcfutils.c	762;"	d	file:
BRANCH	vcfutils.c	804;"	d	file:
BRANCH_INT	vcfutils.c	114;"	d	file:
BRANCH_INT	vcfutils.c	123;"	d	file:
BRANCH_INT	vcfutils.c	157;"	d	file:
BRANCH_INT	vcfutils.c	55;"	d	file:
BRANCH_INT	vcfutils.c	69;"	d	file:
BRANCH_INT	vcfutils.c	90;"	d	file:
BUFSZ	test/test_bgzf.c	43;"	d	file:
BUILT_PLUGINS	Makefile	/^BUILT_PLUGINS = $(PLUGIN_OBJS:.o=$(PLUGIN_EXT))$/;"	m
BUILT_PROGRAMS	Makefile	/^BUILT_PROGRAMS = \\$/;"	m
BUILT_TEST_PROGRAMS	Makefile	/^BUILT_TEST_PROGRAMS = \\$/;"	m
BUILT_THRASH_PROGRAMS	Makefile	/^BUILT_THRASH_PROGRAMS = \\$/;"	m
BZIP2	cram/cram_structs.h	/^    BZIP2    = 2,$/;"	e	enum:cram_block_method
BZIP2	htslib/cram.h	/^    BZIP2    = 2,$/;"	e	enum:cram_block_method
CC	Makefile	/^CC     = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS   = -g -Wall -O2$/;"	m
CLOSE	bgzf.c	/^    CLOSE,$/;"	e	enum:mtaux_cmd	file:
COLLAPSE_ANY	htslib/synced_bcf_reader.h	81;"	d
COLLAPSE_BOTH	htslib/synced_bcf_reader.h	83;"	d
COLLAPSE_INDELS	htslib/synced_bcf_reader.h	80;"	d
COLLAPSE_NONE	htslib/synced_bcf_reader.h	78;"	d
COLLAPSE_SNPS	htslib/synced_bcf_reader.h	79;"	d
COLLAPSE_SOME	htslib/synced_bcf_reader.h	82;"	d
COMPRESSION_HEADER	cram/cram_structs.h	/^    COMPRESSION_HEADER = 1,$/;"	e	enum:cram_content_type
COMPRESSION_HEADER	htslib/cram.h	/^    COMPRESSION_HEADER = 1,$/;"	e	enum:cram_content_type
CORE	cram/cram_structs.h	/^    CORE               = 5,$/;"	e	enum:cram_content_type
CORE	htslib/cram.h	/^    CORE               = 5,$/;"	e	enum:cram_content_type
CPPFLAGS	Makefile	/^CPPFLAGS =$/;"	m
CRAM_ALL	cram/cram_structs.h	/^    CRAM_ALL= 0x7fffffff,$/;"	e	enum:cram_fields
CRAM_AP	cram/cram_structs.h	/^    CRAM_AP = 0x00000002,$/;"	e	enum:cram_fields
CRAM_BA	cram/cram_structs.h	/^    CRAM_BA = 0x00000040,$/;"	e	enum:cram_fields
CRAM_BB	cram/cram_structs.h	/^    CRAM_BB = 0x04000000,$/;"	e	enum:cram_fields
CRAM_BB_len	cram/cram_structs.h	/^    CRAM_BB_len = 0x08000000,$/;"	e	enum:cram_fields
CRAM_BF	cram/cram_structs.h	/^    CRAM_BF = 0x00000001,$/;"	e	enum:cram_fields
CRAM_BS	cram/cram_structs.h	/^    CRAM_BS = 0x00000400,$/;"	e	enum:cram_fields
CRAM_CF	cram/cram_structs.h	/^    CRAM_CF = 0x00100000,$/;"	e	enum:cram_fields
CRAM_CIGAR	cram/cram_structs.h	794;"	d
CRAM_DL	cram/cram_structs.h	/^    CRAM_DL = 0x00000010,$/;"	e	enum:cram_fields
CRAM_FC	cram/cram_structs.h	/^    CRAM_FC = 0x00000100,$/;"	e	enum:cram_fields
CRAM_FDUP	cram/cram_structs.h	812;"	d
CRAM_FLAG_DETACHED	cram/cram_structs.h	830;"	d
CRAM_FLAG_DISCARD_NAME	cram/cram_structs.h	837;"	d
CRAM_FLAG_MASK	cram/cram_structs.h	833;"	d
CRAM_FLAG_MATE_DOWNSTREAM	cram/cram_structs.h	831;"	d
CRAM_FLAG_NO_SEQ	cram/cram_structs.h	832;"	d
CRAM_FLAG_PRESERVE_QUAL_SCORES	cram/cram_structs.h	829;"	d
CRAM_FLAG_STATS_ADDED	cram/cram_structs.h	836;"	d
CRAM_FN	cram/cram_structs.h	/^    CRAM_FN = 0x00000200,$/;"	e	enum:cram_fields
CRAM_FP	cram/cram_structs.h	/^    CRAM_FP = 0x00000004,$/;"	e	enum:cram_fields
CRAM_FPAIRED	cram/cram_structs.h	804;"	d
CRAM_FPROPER_PAIR	cram/cram_structs.h	805;"	d
CRAM_FQCFAIL	cram/cram_structs.h	811;"	d
CRAM_FREAD1	cram/cram_structs.h	808;"	d
CRAM_FREAD2	cram/cram_structs.h	809;"	d
CRAM_FREVERSE	cram/cram_structs.h	807;"	d
CRAM_FSECONDARY	cram/cram_structs.h	810;"	d
CRAM_FUNMAP	cram/cram_structs.h	806;"	d
CRAM_HC	cram/cram_structs.h	/^    CRAM_HC = 0x01000000,$/;"	e	enum:cram_fields
CRAM_IN	cram/cram_structs.h	/^    CRAM_IN = 0x00000800,$/;"	e	enum:cram_fields
CRAM_KEY	cram/cram_io.h	59;"	d
CRAM_MAJOR_VERS	cram/cram_structs.h	189;"	d
CRAM_MAP	cram/cram_structs.h	279;"	d
CRAM_MAP_HASH	cram/cram_structs.h	278;"	d
CRAM_MF	cram/cram_structs.h	/^    CRAM_MF = 0x00080000,$/;"	e	enum:cram_fields
CRAM_MINOR_VERS	cram/cram_structs.h	190;"	d
CRAM_MQ	cram/cram_structs.h	/^    CRAM_MQ = 0x00002000,$/;"	e	enum:cram_fields
CRAM_M_REVERSE	cram/cram_structs.h	824;"	d
CRAM_M_UNMAP	cram/cram_structs.h	825;"	d
CRAM_NF	cram/cram_structs.h	/^    CRAM_NF = 0x00000020,$/;"	e	enum:cram_fields
CRAM_NP	cram/cram_structs.h	/^    CRAM_NP = 0x00020000,$/;"	e	enum:cram_fields
CRAM_NS	cram/cram_structs.h	/^    CRAM_NS = 0x00010000,$/;"	e	enum:cram_fields
CRAM_OPT_BASES_PER_SLICE	htslib/hts.h	/^    CRAM_OPT_BASES_PER_SLICE,$/;"	e	enum:hts_fmt_option
CRAM_OPT_DECODE_MD	htslib/hts.h	/^    CRAM_OPT_DECODE_MD,$/;"	e	enum:hts_fmt_option
CRAM_OPT_EMBED_REF	htslib/hts.h	/^    CRAM_OPT_EMBED_REF,$/;"	e	enum:hts_fmt_option
CRAM_OPT_IGNORE_MD5	htslib/hts.h	/^    CRAM_OPT_IGNORE_MD5,$/;"	e	enum:hts_fmt_option
CRAM_OPT_LOSSY_NAMES	htslib/hts.h	/^    CRAM_OPT_LOSSY_NAMES,$/;"	e	enum:hts_fmt_option
CRAM_OPT_MULTI_SEQ_PER_SLICE	htslib/hts.h	/^    CRAM_OPT_MULTI_SEQ_PER_SLICE,$/;"	e	enum:hts_fmt_option
CRAM_OPT_NO_REF	htslib/hts.h	/^    CRAM_OPT_NO_REF,$/;"	e	enum:hts_fmt_option
CRAM_OPT_NTHREADS	htslib/hts.h	/^    CRAM_OPT_NTHREADS,   \/\/ deprecated, use HTS_OPT_NTHREADS$/;"	e	enum:hts_fmt_option
CRAM_OPT_PREFIX	htslib/hts.h	/^    CRAM_OPT_PREFIX,$/;"	e	enum:hts_fmt_option
CRAM_OPT_RANGE	htslib/hts.h	/^    CRAM_OPT_RANGE,$/;"	e	enum:hts_fmt_option
CRAM_OPT_REFERENCE	htslib/hts.h	/^    CRAM_OPT_REFERENCE,  \/\/ make general$/;"	e	enum:hts_fmt_option
CRAM_OPT_REQUIRED_FIELDS	htslib/hts.h	/^    CRAM_OPT_REQUIRED_FIELDS,$/;"	e	enum:hts_fmt_option
CRAM_OPT_SEQS_PER_SLICE	htslib/hts.h	/^    CRAM_OPT_SEQS_PER_SLICE,$/;"	e	enum:hts_fmt_option
CRAM_OPT_SHARED_REF	htslib/hts.h	/^    CRAM_OPT_SHARED_REF,$/;"	e	enum:hts_fmt_option
CRAM_OPT_SLICES_PER_CONTAINER	htslib/hts.h	/^    CRAM_OPT_SLICES_PER_CONTAINER,$/;"	e	enum:hts_fmt_option
CRAM_OPT_THREAD_POOL	htslib/hts.h	/^    CRAM_OPT_THREAD_POOL,\/\/ make general$/;"	e	enum:hts_fmt_option
CRAM_OPT_USE_BZIP2	htslib/hts.h	/^    CRAM_OPT_USE_BZIP2,$/;"	e	enum:hts_fmt_option
CRAM_OPT_USE_LZMA	htslib/hts.h	/^    CRAM_OPT_USE_LZMA,$/;"	e	enum:hts_fmt_option
CRAM_OPT_USE_RANS	htslib/hts.h	/^    CRAM_OPT_USE_RANS,$/;"	e	enum:hts_fmt_option
CRAM_OPT_VERBOSITY	htslib/hts.h	/^    CRAM_OPT_VERBOSITY,  \/\/ obsolete, use hts_set_log_level() instead$/;"	e	enum:hts_fmt_option
CRAM_OPT_VERSION	htslib/hts.h	/^    CRAM_OPT_VERSION,    \/\/ rename to cram_version?$/;"	e	enum:hts_fmt_option
CRAM_PD	cram/cram_structs.h	/^    CRAM_PD = 0x00800000,$/;"	e	enum:cram_fields
CRAM_QQ	cram/cram_structs.h	/^    CRAM_QQ = 0x10000000,$/;"	e	enum:cram_fields
CRAM_QQ_len	cram/cram_structs.h	/^    CRAM_QQ_len = 0x20000000,$/;"	e	enum:cram_fields
CRAM_QS	cram/cram_structs.h	/^    CRAM_QS = 0x00000080,$/;"	e	enum:cram_fields
CRAM_QUAL	cram/cram_structs.h	800;"	d
CRAM_RG	cram/cram_structs.h	/^    CRAM_RG = 0x00001000,$/;"	e	enum:cram_fields
CRAM_RI	cram/cram_structs.h	/^    CRAM_RI = 0x00200000,$/;"	e	enum:cram_fields
CRAM_RL	cram/cram_structs.h	/^    CRAM_RL = 0x00000008,$/;"	e	enum:cram_fields
CRAM_RN	cram/cram_structs.h	/^    CRAM_RN = 0x00008000,$/;"	e	enum:cram_fields
CRAM_RS	cram/cram_structs.h	/^    CRAM_RS = 0x00400000,$/;"	e	enum:cram_fields
CRAM_SC	cram/cram_structs.h	/^    CRAM_SC = 0x02000000,$/;"	e	enum:cram_fields
CRAM_SEQ	cram/cram_structs.h	797;"	d
CRAM_SUBST_MATRIX	cram/cram_structs.h	90;"	d
CRAM_TL	cram/cram_structs.h	/^    CRAM_TL = 0x00004000,$/;"	e	enum:cram_fields
CRAM_TS	cram/cram_structs.h	/^    CRAM_TS = 0x00040000,$/;"	e	enum:cram_fields
CRAM_aux	cram/cram_structs.h	/^    CRAM_aux= 0x40000000,$/;"	e	enum:cram_fields
CT_ERROR	cram/cram_structs.h	/^    CT_ERROR           = -1,$/;"	e	enum:cram_content_type
CT_ERROR	htslib/cram.h	/^    CT_ERROR           = -1,$/;"	e	enum:cram_content_type
Ccram_to_sam	test/cross_validate.sh	/^Ccram_to_sam() {$/;"	f
D	cram/cram_structs.h	/^	} D;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon89
DBG_OUT	thread_pool.c	/^int DBG_OUT(FILE *fp, char *fmt, ...) {$/;"	f
DBG_OUT	thread_pool.c	62;"	d	file:
DIGEST_BUFSIZ	hfile_s3.c	59;"	d	file:
DIGEST_BUFSIZ	hfile_s3.c	72;"	d	file:
DS_AP	cram/cram_structs.h	/^    DS_AP,$/;"	e	enum:cram_DS_ID
DS_BA	cram/cram_structs.h	/^    DS_BA,$/;"	e	enum:cram_DS_ID
DS_BB	cram/cram_structs.h	/^    DS_BB,$/;"	e	enum:cram_DS_ID
DS_BB_len	cram/cram_structs.h	/^    DS_BB_len,$/;"	e	enum:cram_DS_ID
DS_BF	cram/cram_structs.h	/^    DS_BF, \/\/ start loop$/;"	e	enum:cram_DS_ID
DS_BS	cram/cram_structs.h	/^    DS_BS,$/;"	e	enum:cram_DS_ID
DS_CF	cram/cram_structs.h	/^    DS_CF,$/;"	e	enum:cram_DS_ID
DS_CORE	cram/cram_structs.h	/^    DS_CORE   = 0,$/;"	e	enum:cram_DS_ID
DS_DL	cram/cram_structs.h	/^    DS_DL,$/;"	e	enum:cram_DS_ID
DS_END	cram/cram_structs.h	/^    DS_END,$/;"	e	enum:cram_DS_ID
DS_FC	cram/cram_structs.h	/^    DS_FC,$/;"	e	enum:cram_DS_ID
DS_FN	cram/cram_structs.h	/^    DS_FN,$/;"	e	enum:cram_DS_ID
DS_FP	cram/cram_structs.h	/^    DS_FP,$/;"	e	enum:cram_DS_ID
DS_HC	cram/cram_structs.h	/^    DS_HC,$/;"	e	enum:cram_DS_ID
DS_IN	cram/cram_structs.h	/^    DS_IN, \/\/ base_blk$/;"	e	enum:cram_DS_ID
DS_MF	cram/cram_structs.h	/^    DS_MF,$/;"	e	enum:cram_DS_ID
DS_MQ	cram/cram_structs.h	/^    DS_MQ,$/;"	e	enum:cram_DS_ID
DS_NF	cram/cram_structs.h	/^    DS_NF,$/;"	e	enum:cram_DS_ID
DS_NP	cram/cram_structs.h	/^    DS_NP,$/;"	e	enum:cram_DS_ID
DS_NS	cram/cram_structs.h	/^    DS_NS,$/;"	e	enum:cram_DS_ID
DS_PD	cram/cram_structs.h	/^    DS_PD,$/;"	e	enum:cram_DS_ID
DS_QQ	cram/cram_structs.h	/^    DS_QQ,$/;"	e	enum:cram_DS_ID
DS_QQ_len	cram/cram_structs.h	/^    DS_QQ_len,$/;"	e	enum:cram_DS_ID
DS_QS	cram/cram_structs.h	/^    DS_QS, \/\/ qual_blk$/;"	e	enum:cram_DS_ID
DS_RG	cram/cram_structs.h	/^    DS_RG,$/;"	e	enum:cram_DS_ID
DS_RI	cram/cram_structs.h	/^    DS_RI,$/;"	e	enum:cram_DS_ID
DS_RL	cram/cram_structs.h	/^    DS_RL,$/;"	e	enum:cram_DS_ID
DS_RN	cram/cram_structs.h	/^    DS_RN, \/\/ name_blk$/;"	e	enum:cram_DS_ID
DS_RN_len	cram/cram_structs.h	/^    DS_RN_len,$/;"	e	enum:cram_DS_ID
DS_RS	cram/cram_structs.h	/^    DS_RS,$/;"	e	enum:cram_DS_ID
DS_SC	cram/cram_structs.h	/^    DS_SC, \/\/ soft_blk$/;"	e	enum:cram_DS_ID
DS_SC_len	cram/cram_structs.h	/^    DS_SC_len,$/;"	e	enum:cram_DS_ID
DS_TC	cram/cram_structs.h	/^    DS_TC, \/\/ CRAM v1.0 tags$/;"	e	enum:cram_DS_ID
DS_TL	cram/cram_structs.h	/^    DS_TL,$/;"	e	enum:cram_DS_ID
DS_TM	cram/cram_structs.h	/^    DS_TM, \/\/ test$/;"	e	enum:cram_DS_ID
DS_TN	cram/cram_structs.h	/^    DS_TN, \/\/ end loop$/;"	e	enum:cram_DS_ID
DS_TS	cram/cram_structs.h	/^    DS_TS,$/;"	e	enum:cram_DS_ID
DS_TV	cram/cram_structs.h	/^    DS_TV, \/\/ test$/;"	e	enum:cram_DS_ID
DS_aux	cram/cram_structs.h	/^    DS_aux    = 1, \/\/ aux_blk$/;"	e	enum:cram_DS_ID
DS_aux_BD	cram/cram_structs.h	/^    DS_aux_BD = 4,$/;"	e	enum:cram_DS_ID
DS_aux_BD_S	cram/cram_structs.h	817;"	d
DS_aux_BI	cram/cram_structs.h	/^    DS_aux_BI = 5,$/;"	e	enum:cram_DS_ID
DS_aux_BI_S	cram/cram_structs.h	818;"	d
DS_aux_BQ	cram/cram_structs.h	/^    DS_aux_BQ = 3,$/;"	e	enum:cram_DS_ID
DS_aux_BQ_S	cram/cram_structs.h	816;"	d
DS_aux_FZ	cram/cram_structs.h	/^    DS_aux_FZ = 6, \/\/ also ZM:B$/;"	e	enum:cram_DS_ID
DS_aux_FZ_S	cram/cram_structs.h	819;"	d
DS_aux_OQ	cram/cram_structs.h	/^    DS_aux_OQ = 2,$/;"	e	enum:cram_DS_ID
DS_aux_OQ_S	cram/cram_structs.h	815;"	d
DS_aux_S	cram/cram_structs.h	814;"	d
DS_aux_oq	cram/cram_structs.h	/^    DS_aux_oq = 7, \/\/ other qualities$/;"	e	enum:cram_DS_ID
DS_aux_oq_S	cram/cram_structs.h	820;"	d
DS_aux_os	cram/cram_structs.h	/^    DS_aux_os = 8, \/\/ other sequences$/;"	e	enum:cram_DS_ID
DS_aux_os_S	cram/cram_structs.h	821;"	d
DS_aux_oz	cram/cram_structs.h	/^    DS_aux_oz = 9, \/\/ other strings$/;"	e	enum:cram_DS_ID
DS_aux_oz_S	cram/cram_structs.h	822;"	d
DS_ref	cram/cram_structs.h	/^    DS_ref,$/;"	e	enum:cram_DS_ID
E	test/sam.c	97;"	d	file:
EI	probaln.c	39;"	d	file:
EM	probaln.c	40;"	d	file:
ENOTSUP	hfile.c	40;"	d	file:
EOVERFLOW	hfile.c	43;"	d	file:
EOVERFLOW	sam.c	48;"	d	file:
EPROTO	multipart.c	37;"	d	file:
EPROTONOSUPPORT	hfile.c	46;"	d	file:
ERROR	htslib/cram.h	/^    ERROR    = -1,$/;"	e	enum:cram_block_method
EXTERNAL	cram/cram_structs.h	/^    EXTERNAL           = 4,$/;"	e	enum:cram_content_type
EXTERNAL	htslib/cram.h	/^    EXTERNAL           = 4,$/;"	e	enum:cram_content_type
EXTRA_CFLAGS_PIC	Makefile	/^EXTRA_CFLAGS_PIC = -fpic$/;"	m
E_BETA	cram/cram_structs.h	/^    E_BETA               = 6,$/;"	e	enum:cram_encoding
E_BYTE	cram/cram_structs.h	/^    E_BYTE               = 3,$/;"	e	enum:cram_external_type
E_BYTE_ARRAY	cram/cram_structs.h	/^    E_BYTE_ARRAY         = 4,$/;"	e	enum:cram_external_type
E_BYTE_ARRAY_BLOCK	cram/cram_structs.h	/^    E_BYTE_ARRAY_BLOCK   = 5,$/;"	e	enum:cram_external_type
E_BYTE_ARRAY_LEN	cram/cram_structs.h	/^    E_BYTE_ARRAY_LEN     = 4,$/;"	e	enum:cram_encoding
E_BYTE_ARRAY_STOP	cram/cram_structs.h	/^    E_BYTE_ARRAY_STOP    = 5,$/;"	e	enum:cram_encoding
E_EXTERNAL	cram/cram_structs.h	/^    E_EXTERNAL           = 1,$/;"	e	enum:cram_encoding
E_GAMMA	cram/cram_structs.h	/^    E_GAMMA              = 9,$/;"	e	enum:cram_encoding
E_GOLOMB	cram/cram_structs.h	/^    E_GOLOMB             = 2,$/;"	e	enum:cram_encoding
E_GOLOMB_RICE	cram/cram_structs.h	/^    E_GOLOMB_RICE        = 8,$/;"	e	enum:cram_encoding
E_HUFFMAN	cram/cram_structs.h	/^    E_HUFFMAN            = 3,$/;"	e	enum:cram_encoding
E_INT	cram/cram_structs.h	/^    E_INT                = 1,$/;"	e	enum:cram_external_type
E_LONG	cram/cram_structs.h	/^    E_LONG               = 2,$/;"	e	enum:cram_external_type
E_NULL	cram/cram_structs.h	/^    E_NULL               = 0,$/;"	e	enum:cram_encoding
E_NUM_CODECS	cram/cram_structs.h	/^    E_NUM_CODECS         = 10, \/* Number of codecs, not a real one. *\/$/;"	e	enum:cram_encoding
E_SUBEXP	cram/cram_structs.h	/^    E_SUBEXP             = 7,$/;"	e	enum:cram_encoding
F	md5.c	76;"	d	file:
FAI_CREATE	htslib/faidx.h	/^    FAI_CREATE = 0x01,$/;"	e	enum:fai_load_options
FILE_HEADER	cram/cram_structs.h	/^    FILE_HEADER        = 0,$/;"	e	enum:cram_content_type
FILE_HEADER	htslib/cram.h	/^    FILE_HEADER        = 0,$/;"	e	enum:cram_content_type
FT_BCF	htslib/hts.h	661;"	d
FT_BCF_GZ	htslib/hts.h	662;"	d
FT_GZ	htslib/hts.h	658;"	d
FT_STDIN	htslib/hts.h	663;"	d
FT_UNKN	htslib/hts.h	657;"	d
FT_VCF	htslib/hts.h	659;"	d
FT_VCF_GZ	htslib/hts.h	660;"	d
Files	test/test_bgzf.c	/^} Files;$/;"	t	typeref:struct:__anon48	file:
G	md5.c	77;"	d	file:
GET	md5.c	101;"	d	file:
GET	md5.c	110;"	d	file:
GET_BIT_MSB	cram/cram_codecs.h	156;"	d
GT_HAPL_A	htslib/vcfutils.h	110;"	d
GT_HAPL_R	htslib/vcfutils.h	109;"	d
GT_HET_AA	htslib/vcfutils.h	108;"	d
GT_HET_RA	htslib/vcfutils.h	107;"	d
GT_HOM_AA	htslib/vcfutils.h	106;"	d
GT_HOM_RR	htslib/vcfutils.h	105;"	d
GT_UNKN	htslib/vcfutils.h	111;"	d
GZIP	cram/cram_structs.h	/^    GZIP     = 1,$/;"	e	enum:cram_block_method
GZIP	htslib/cram.h	/^    GZIP     = 1,$/;"	e	enum:cram_block_method
GZIP_RLE	cram/cram_structs.h	/^    GZIP_RLE = 11, \/\/ NB: not externalised in CRAM$/;"	e	enum:cram_block_method
GZIP_RLE	htslib/cram.h	/^    GZIP_RLE = 11, \/\/ NB: not externalised in CRAM$/;"	e	enum:cram_block_method
H	cram/cram_structs.h	/^	} H;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon92
H	md5.c	78;"	d	file:
H2	md5.c	79;"	d	file:
HAS_EOF	bgzf.c	/^    HAS_EOF,$/;"	e	enum:mtaux_cmd	file:
HAVE_CLOSESOCKET	hfile.c	494;"	d	file:
HAVE_DRAND48	config.h	5;"	d
HAVE_FSEEKO	config.h	4;"	d
HAVE_LIBBZ2	config.h	2;"	d
HAVE_LIBLZMA	config.h	3;"	d
HAVE_SETMODE	hfile.c	495;"	d	file:
HAVE_STRUCT_STAT_ST_BLKSIZE	hfile.c	491;"	d	file:
HELLO	test/sam.c	98;"	d	file:
HFILE_INTERNAL_H	hfile_internal.h	26;"	d
HTSLIB_ALL	htslib.mk	/^HTSLIB_ALL = \\$/;"	m
HTSLIB_BGZF_H	htslib/bgzf.h	31;"	d
HTSLIB_CRAM_H	htslib/cram.h	36;"	d
HTSLIB_FAIDX_H	htslib/faidx.h	30;"	d
HTSLIB_HFILE_H	htslib/hfile.h	27;"	d
HTSLIB_HTS_DEFS_H	htslib/hts_defs.h	26;"	d
HTSLIB_HTS_H	htslib/hts.h	29;"	d
HTSLIB_HTS_INTERNAL_H	hts_internal.h	24;"	d
HTSLIB_HTS_OS_H	htslib/hts_os.h	27;"	d
HTSLIB_HTS_RAND_H	win/rand.h	17;"	d
HTSLIB_KFUNC_H	htslib/kfunc.h	28;"	d
HTSLIB_KHASH_STR2INT_H	htslib/khash_str2int.h	26;"	d
HTSLIB_PUBLIC_HEADERS	htslib.mk	/^HTSLIB_PUBLIC_HEADERS = \\$/;"	m
HTSLIB_REGIDX_H	htslib/regidx.h	54;"	d
HTSLIB_SAM_H	htslib/sam.h	28;"	d
HTSLIB_SYNCED_BCF_READER_H	htslib/synced_bcf_reader.h	57;"	d
HTSLIB_TBX_H	htslib/tbx.h	28;"	d
HTSLIB_THREAD_POOL_H	htslib/thread_pool.h	48;"	d
HTSLIB_VCFUTILS_H	htslib/vcfutils.h	27;"	d
HTSLIB_VCF_H	htslib/vcf.h	34;"	d
HTSLIB_VCF_SWEEP_H	htslib/vcf_sweep.h	27;"	d
HTSPREFIX	Makefile	/^HTSPREFIX =$/;"	m
HTSPREFIX	htslib.mk	/^HTSPREFIX = $(HTSDIR)\/$/;"	m
HTS_ALLOW_UNALIGNED	htslib/hts_endian.h	96;"	d
HTS_ALLOW_UNALIGNED	htslib/hts_endian.h	98;"	d
HTS_BGZF_TYPEDEF	htslib/bgzf.h	77;"	d
HTS_BGZF_TYPEDEF	htslib/hts.h	43;"	d
HTS_BIG_ENDIAN	htslib/hts_endian.h	69;"	d
HTS_BIG_ENDIAN	htslib/hts_endian.h	80;"	d
HTS_COMPILER_HAS	htslib/hts_defs.h	30;"	d
HTS_COMPILER_HAS	htslib/hts_defs.h	39;"	d
HTS_DEPRECATED	htslib/hts_defs.h	65;"	d
HTS_DEPRECATED	htslib/hts_defs.h	67;"	d
HTS_DEPRECATED	htslib/hts_defs.h	69;"	d
HTS_DEPRECATED	test/sam.c	37;"	d	file:
HTS_DEPRECATED	test/sam.c	38;"	d	file:
HTS_DEPRECATED_ENUM	htslib/hts.h	/^    json HTS_DEPRECATED_ENUM("Use htsExactFormat 'htsget' instead") = htsget,$/;"	e	enum:htsExactFormat
HTS_DEPRECATED_ENUM	htslib/hts_defs.h	73;"	d
HTS_DEPRECATED_ENUM	htslib/hts_defs.h	75;"	d
HTS_ENDIAN_H	htslib/hts_endian.h	27;"	d
HTS_FILE_OPTS_INIT	htslib/hts.h	256;"	d
HTS_FMT_BAI	htslib/hts.h	518;"	d
HTS_FMT_CRAI	htslib/hts.h	520;"	d
HTS_FMT_CSI	htslib/hts.h	517;"	d
HTS_FMT_TBI	htslib/hts.h	519;"	d
HTS_FORMAT	htslib/hts_defs.h	91;"	d
HTS_FORMAT	htslib/hts_defs.h	93;"	d
HTS_GCC_AT_LEAST	htslib/hts_defs.h	34;"	d
HTS_GCC_AT_LEAST	htslib/hts_defs.h	42;"	d
HTS_IDX_NOCOOR	htslib/hts.h	512;"	d
HTS_IDX_NONE	htslib/hts.h	515;"	d
HTS_IDX_REST	htslib/hts.h	514;"	d
HTS_IDX_START	htslib/hts.h	513;"	d
HTS_LITTLE_ENDIAN	htslib/hts_endian.h	56;"	d
HTS_LITTLE_ENDIAN	htslib/hts_endian.h	79;"	d
HTS_LOG_DEBUG	htslib/hts_log.h	/^    HTS_LOG_DEBUG,          \/\/\/< Logging of all except the most detailed debug events.$/;"	e	enum:htsLogLevel
HTS_LOG_ERROR	htslib/hts_log.h	/^    HTS_LOG_ERROR,          \/\/\/< Logging of errors only.$/;"	e	enum:htsLogLevel
HTS_LOG_H	htslib/hts_log.h	30;"	d
HTS_LOG_INFO	htslib/hts_log.h	/^    HTS_LOG_INFO,           \/\/\/< Logging of errors, warnings, and normal but significant events.$/;"	e	enum:htsLogLevel
HTS_LOG_OFF	htslib/hts_log.h	/^    HTS_LOG_OFF,            \/\/\/< All logging disabled.$/;"	e	enum:htsLogLevel
HTS_LOG_TRACE	htslib/hts_log.h	/^    HTS_LOG_TRACE           \/\/\/< All logging enabled.$/;"	e	enum:htsLogLevel
HTS_LOG_WARNING	htslib/hts_log.h	/^    HTS_LOG_WARNING = 3,    \/\/\/< Logging of errors and warnings.$/;"	e	enum:htsLogLevel
HTS_MIN_MARKER_DIST	hts.c	1265;"	d	file:
HTS_NORETURN	htslib/hts_defs.h	46;"	d
HTS_NORETURN	htslib/hts_defs.h	48;"	d
HTS_OPT_BLOCK_SIZE	htslib/hts.h	/^    HTS_OPT_BLOCK_SIZE,$/;"	e	enum:hts_fmt_option
HTS_OPT_CACHE_SIZE	htslib/hts.h	/^    HTS_OPT_CACHE_SIZE,$/;"	e	enum:hts_fmt_option
HTS_OPT_COMPRESSION_LEVEL	htslib/hts.h	/^    HTS_OPT_COMPRESSION_LEVEL = 100,$/;"	e	enum:hts_fmt_option
HTS_OPT_NTHREADS	htslib/hts.h	/^    HTS_OPT_NTHREADS,$/;"	e	enum:hts_fmt_option
HTS_OPT_THREAD_POOL	htslib/hts.h	/^    HTS_OPT_THREAD_POOL,$/;"	e	enum:hts_fmt_option
HTS_PARSE_THOUSANDS_SEP	htslib/hts.h	616;"	d
HTS_PRINTF_FMT	htslib/hts_defs.h	85;"	d
HTS_PRINTF_FMT	htslib/hts_defs.h	87;"	d
HTS_RESULT_USED	hfile_internal.h	/^        HTS_RESULT_USED;$/;"	m	struct:hFILE_backend
HTS_RESULT_USED	hfile_internal.h	/^        HTS_RESULT_USED;$/;"	m	struct:hFILE_scheme_handler
HTS_RESULT_USED	hfile_internal.h	/^    hFILE *(*open)(const char *filename, const char *mode) HTS_RESULT_USED;$/;"	m	struct:hFILE_scheme_handler
HTS_RESULT_USED	hfile_internal.h	/^    int (*close)(hFILE *fp) HTS_RESULT_USED;$/;"	m	struct:hFILE_backend
HTS_RESULT_USED	hfile_internal.h	/^    int (*flush)(hFILE *fp) HTS_RESULT_USED;$/;"	m	struct:hFILE_backend
HTS_RESULT_USED	hfile_internal.h	/^    int (*isremote)(const char *filename) HTS_RESULT_USED;$/;"	m	struct:hFILE_scheme_handler
HTS_RESULT_USED	hfile_internal.h	/^    off_t (*seek)(hFILE *fp, off_t offset, int whence) HTS_RESULT_USED;$/;"	m	struct:hFILE_backend
HTS_RESULT_USED	hfile_internal.h	/^    ssize_t (*read)(hFILE *fp, void *buffer, size_t nbytes) HTS_RESULT_USED;$/;"	m	struct:hFILE_backend
HTS_RESULT_USED	htslib/hts_defs.h	53;"	d
HTS_RESULT_USED	htslib/hts_defs.h	55;"	d
HTS_UNUSED	htslib/hts_defs.h	59;"	d
HTS_UNUSED	htslib/hts_defs.h	61;"	d
HTS_VERSION	version.h	1;"	d
HTS_x86	htslib/hts_endian.h	43;"	d
I	cram/cram_structs.h	/^	} I;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon87
I	md5.c	80;"	d	file:
ID_buf	cram/sam_header.h	/^    char ID_buf[1024];  \/\/ temporary buffer$/;"	m	struct:__anon65
ID_cnt	cram/sam_header.h	/^    int ID_cnt;$/;"	m	struct:__anon65
INSTALL	Makefile	/^INSTALL = install -p$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA    = $(INSTALL) -m 644$/;"	m
INSTALL_DIR	Makefile	/^INSTALL_DIR     = $(MKDIR_P) -m 755$/;"	m
INSTALL_LIB	Makefile	/^INSTALL_LIB     = $(INSTALL_DATA)$/;"	m
INSTALL_MAN	Makefile	/^INSTALL_MAN     = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = $(INSTALL)$/;"	m
IS_BAM	tabix.c	66;"	d	file:
IS_BCF	tabix.c	65;"	d	file:
IS_BED	tabix.c	62;"	d	file:
IS_CRAM	tabix.c	67;"	d	file:
IS_GFF	tabix.c	61;"	d	file:
IS_SAM	tabix.c	63;"	d	file:
IS_TXT	tabix.c	68;"	d	file:
IS_VCF	tabix.c	64;"	d	file:
Jcram_to_sam	test/cross_validate.sh	/^Jcram_to_sam() {$/;"	f
K	cram/sam_header.c	752;"	d	file:
KBITSET_H	htslib/kbitset.h	27;"	d
KBS_ELT	htslib/kbitset.h	60;"	d
KBS_ELTBITS	htslib/kbitset.h	59;"	d
KBS_MASK	htslib/kbitset.h	61;"	d
KF_GAMMA_EPS	kfunc.c	97;"	d	file:
KF_TINY	kfunc.c	98;"	d	file:
KHASH_DECLARE	htslib/khash.h	357;"	d
KHASH_INIT	htslib/khash.h	365;"	d
KHASH_INIT2	htslib/khash.h	361;"	d
KHASH_MAP_INIT_INT	htslib/khash.h	593;"	d
KHASH_MAP_INIT_INT64	htslib/khash.h	608;"	d
KHASH_MAP_INIT_STR	faidx.c	/^KHASH_MAP_INIT_STR(s, faidx1_t)$/;"	f
KHASH_MAP_INIT_STR	htslib/khash.h	624;"	d
KHASH_SET_INIT_INT	htslib/khash.h	585;"	d
KHASH_SET_INIT_INT64	htslib/khash.h	600;"	d
KHASH_SET_INIT_STR	htslib/khash.h	616;"	d
KLIST_INIT	htslib/klist.h	120;"	d
KLIST_INIT2	htslib/klist.h	77;"	d
KMEMPOOL_INIT	htslib/klist.h	68;"	d
KMEMPOOL_INIT2	htslib/klist.h	39;"	d
KNETFILE_H	htslib/knetfile.h	28;"	d
KNF_TYPE_FTP	htslib/knetfile.h	48;"	d
KNF_TYPE_HTTP	htslib/knetfile.h	49;"	d
KNF_TYPE_LOCAL	htslib/knetfile.h	47;"	d
KSEQ_DECLARE	htslib/kseq.h	246;"	d
KSEQ_INIT	htslib/kseq.h	244;"	d
KSEQ_INIT2	htslib/kseq.h	238;"	d
KSORT_INIT	htslib/ksort.h	81;"	d
KSORT_INIT_GENERIC	errmod.c	/^KSORT_INIT_GENERIC(uint16_t)$/;"	f
KSORT_INIT_GENERIC	htslib/ksort.h	289;"	d
KSORT_INIT_STR	htslib/ksort.h	290;"	d
KSORT_SWAP	htslib/ksort.h	79;"	d
KSTREAM_DECLARE	htslib/kseq.h	156;"	d
KSTREAM_INIT	htslib/kseq.h	154;"	d
KSTREAM_INIT2	htslib/kseq.h	148;"	d
KSTRING_H	htslib/kstring.h	27;"	d
KSTRING_T	htslib/bgzf.h	81;"	d
KSTRING_T	htslib/hts.h	51;"	d
KSTRING_T	htslib/kseq.h	83;"	d
KSTRING_T	htslib/kstring.h	66;"	d
KS_ATTR_PRINTF	htslib/kstring.h	51;"	d
KS_ATTR_PRINTF	htslib/kstring.h	53;"	d
KS_FREE	cram/sam_header.h	69;"	d
KS_INIT	cram/sam_header.h	66;"	d
KS_INITIALIZER	cram/sam_header.h	63;"	d
KS_SEP_LINE	htslib/kseq.h	37;"	d
KS_SEP_MAX	htslib/kseq.h	38;"	d
KS_SEP_SPACE	htslib/kseq.h	35;"	d
KS_SEP_TAB	htslib/kseq.h	36;"	d
L1	cram/cram_structs.h	/^    unsigned char L1[256];              \/\/ ACGT{*} ->0123{4}$/;"	m	struct:cram_fd
L2	cram/cram_structs.h	/^    unsigned char L2[256];              \/\/ ACGTN{*}->01234{5}$/;"	m	struct:cram_fd
LDFLAGS	Makefile	/^LDFLAGS  =$/;"	m
LIBHTS_OBJS	Makefile	/^LIBHTS_OBJS = \\$/;"	m
LIBHTS_SOVERSION	Makefile	/^LIBHTS_SOVERSION = 2$/;"	m
LIBS	Makefile	/^LIBS     = $(htslib_default_libs)$/;"	m
LIDX_SHIFT	regidx.c	35;"	d	file:
LZMA	cram/cram_structs.h	/^    LZMA     = 3,$/;"	e	enum:cram_block_method
LZMA	htslib/cram.h	/^    LZMA     = 3,$/;"	e	enum:cram_block_method
MAPPED_SLICE	cram/cram_structs.h	/^    MAPPED_SLICE       = 2,$/;"	e	enum:cram_content_type
MAPPED_SLICE	htslib/cram.h	/^    MAPPED_SLICE       = 2,$/;"	e	enum:cram_content_type
MAX	cram/misc.h	104;"	d
MAXDELTA	cram/cram_io.c	1319;"	d	file:
MAXFAILS	cram/cram_io.c	1320;"	d	file:
MAX_CSI_COOR	synced_bcf_reader.c	41;"	d	file:
MAX_HUFF	cram/cram_codecs.h	63;"	d
MAX_N_FMT	vcf.c	1869;"	d	file:
MAX_STAT_VAL	cram/cram_structs.h	92;"	d
META_BIN	hts.c	1269;"	d	file:
MF_APPEND	cram/mFILE.h	53;"	d
MF_APPEND	cram/mFILE.h	58;"	d
MF_BINARY	cram/mFILE.h	59;"	d
MF_MMAP	cram/mFILE.h	62;"	d
MF_MODEX	cram/mFILE.h	61;"	d
MF_READ	cram/mFILE.h	56;"	d
MF_TRUNC	cram/mFILE.h	60;"	d
MF_WRITE	cram/mFILE.h	57;"	d
MIN	cram/misc.h	103;"	d
MIN_STR_SIZE	cram/string_alloc.c	47;"	d	file:
MKDIR_P	Makefile	/^MKDIR_P = mkdir -p$/;"	m
N	cram/cram_structs.h	/^	} N;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon90
N	test/thrash_threads4.c	48;"	d	file:
N	test/thrash_threads5.c	33;"	d	file:
N	test/thrash_threads6.c	64;"	d	file:
NELE	test/hts_endian.c	144;"	d	file:
NEW_HELLO	test/sam.c	99;"	d	file:
NONE	bgzf.c	/^    NONE = 0,$/;"	e	enum:mtaux_cmd	file:
NP	cram/pooled_alloc.c	150;"	d	file:
NTRIALS	cram/cram_io.c	95;"	d	file:
NUMERIC_VERSION	Makefile	/^NUMERIC_VERSION := $(shell .\/version.sh numeric)$/;"	m
ORDER_COORD	cram/sam_header.h	/^    ORDER_COORD    = 2,$/;"	e	enum:sam_sort_order
ORDER_NAME	cram/sam_header.h	/^    ORDER_NAME     = 1,$/;"	e	enum:sam_sort_order
ORDER_UNKNOWN	cram/sam_header.h	/^    ORDER_UNKNOWN  =-1,$/;"	e	enum:sam_sort_order
ORDER_UNSORTED	cram/sam_header.h	/^    ORDER_UNSORTED = 0,$/;"	e	enum:sam_sort_order
Open_method	test/test_bgzf.c	/^} Open_method;$/;"	t	typeref:enum:__anon49	file:
P	cram/cram_structs.h	/^	} P;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon91
PACKAGE_VERSION	Makefile	/^PACKAGE_VERSION := $(shell .\/version.sh)$/;"	m
PATH_MAX	cram/cram_io.c	91;"	d	file:
PATH_MAX	cram/open_trace_file.c	75;"	d	file:
PI	test/sam.c	96;"	d	file:
PLATFORM	Makefile	/^PLATFORM := $(shell uname -s)$/;"	m
PLUGINPATH	plugin.c	39;"	d	file:
PLUGIN_EXT	Makefile	/^PLUGIN_EXT  =$/;"	m
PLUGIN_GLOBAL	hfile_gcs.c	/^int PLUGIN_GLOBAL(hfile_plugin_init,_gcs)(struct hFILE_plugin *self)$/;"	f
PLUGIN_GLOBAL	hfile_internal.h	155;"	d
PLUGIN_GLOBAL	hfile_internal.h	161;"	d
PLUGIN_GLOBAL	hfile_libcurl.c	/^int PLUGIN_GLOBAL(hfile_plugin_init,_libcurl)(struct hFILE_plugin *self)$/;"	f
PLUGIN_GLOBAL	hfile_s3.c	/^int PLUGIN_GLOBAL(hfile_plugin_init,_s3)(struct hFILE_plugin *self)$/;"	f
PLUGIN_OBJS	Makefile	/^PLUGIN_OBJS =$/;"	m
PRId16	cram/os.h	170;"	d
PRId32	cram/os.h	169;"	d
PRId64	cram/os.h	168;"	d
PRId8	cram/os.h	171;"	d
PRIu16	cram/os.h	174;"	d
PRIu32	cram/os.h	173;"	d
PRIu64	cram/os.h	172;"	d
PRIu8	cram/os.h	175;"	d
PSIZE	cram/pooled_alloc.c	42;"	d	file:
Q	cram/cram_structs.h	/^	} Q;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon85
R	cram/rANS_static.c	/^    unsigned char R[TOTFREQ];$/;"	m	struct:__anon59	file:
RAND48_ADD	win/rand.c	32;"	d	file:
RAND48_MULT_0	win/rand.c	29;"	d	file:
RAND48_MULT_1	win/rand.c	30;"	d	file:
RAND48_MULT_2	win/rand.c	31;"	d	file:
RAND48_SEED_0	win/rand.c	26;"	d	file:
RAND48_SEED_1	win/rand.c	27;"	d	file:
RAND48_SEED_2	win/rand.c	28;"	d	file:
RANLIB	Makefile	/^RANLIB = ranlib$/;"	m
RANS	cram/cram_structs.h	/^    RANS     = 4,  \/\/ Generic; either order$/;"	e	enum:cram_block_method
RANS	htslib/cram.h	/^    RANS     = 4,  \/\/ Generic; either order$/;"	e	enum:cram_block_method
RANS0	cram/cram_structs.h	/^    RANS0    = 4,$/;"	e	enum:cram_block_method
RANS0	htslib/cram.h	/^    RANS0    = 4,$/;"	e	enum:cram_block_method
RANS1	cram/cram_structs.h	/^    RANS1    = 10, \/\/ Not externalised; stored as RANS (generic)$/;"	e	enum:cram_block_method
RANS1	htslib/cram.h	/^    RANS1    = 10, \/\/ Not externalised; stored as RANS (generic)$/;"	e	enum:cram_block_method
RANS_BYTE_HEADER	cram/rANS_byte.h	16;"	d
RANS_BYTE_L	cram/rANS_byte.h	59;"	d
RANS_STATIC_H	cram/rANS_static.h	36;"	d
RAW	cram/cram_structs.h	/^    RAW      = 0,$/;"	e	enum:cram_block_method
RAW	htslib/cram.h	/^    RAW      = 0,$/;"	e	enum:cram_block_method
READ_COMPRESSED	test/test_view.c	/^    READ_COMPRESSED  = 1,$/;"	e	enum:test_op	file:
READ_CRAM	test/test_view.c	/^    READ_CRAM        = 4,$/;"	e	enum:test_op	file:
REF_PATH	Makefile	/^	REF_PATH=: test\/sam test\/ce.fa test\/faidx.fa$/;"	m
REGITR_END	htslib/regidx.h	78;"	d
REGITR_OVERLAP	htslib/regidx.h	80;"	d
REGITR_PAYLOAD	htslib/regidx.h	79;"	d
REGITR_START	htslib/regidx.h	77;"	d
RP	cram/cram_io.c	80;"	d	file:
RP	cram/cram_io.c	82;"	d	file:
RTLD_NOLOAD	plugin.c	132;"	d	file:
RansAssert	cram/rANS_byte.h	21;"	d
RansAssert	cram/rANS_byte.h	23;"	d
RansDecAdvance	cram/rANS_byte.h	/^static inline void RansDecAdvance(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)$/;"	f
RansDecAdvanceStep	cram/rANS_byte.h	/^static inline void RansDecAdvanceStep(RansState* r, uint32_t start, uint32_t freq, uint32_t scale_bits)$/;"	f
RansDecAdvanceSymbol	cram/rANS_byte.h	/^static inline void RansDecAdvanceSymbol(RansState* r, uint8_t** pptr, RansDecSymbol const* sym, uint32_t scale_bits)$/;"	f
RansDecAdvanceSymbolStep	cram/rANS_byte.h	/^static inline void RansDecAdvanceSymbolStep(RansState* r, RansDecSymbol const* sym, uint32_t scale_bits)$/;"	f
RansDecGet	cram/rANS_byte.h	/^static inline uint32_t RansDecGet(RansState* r, uint32_t scale_bits)$/;"	f
RansDecInit	cram/rANS_byte.h	/^static inline void RansDecInit(RansState* r, uint8_t** pptr)$/;"	f
RansDecRenorm	cram/rANS_byte.h	/^static inline void RansDecRenorm(RansState* r, uint8_t** pptr)$/;"	f
RansDecRenormSafe	cram/rANS_byte.h	/^static inline void RansDecRenormSafe(RansState* r, uint8_t** pptr, uint8_t *ptr_end)$/;"	f
RansDecSymbol	cram/rANS_byte.h	/^} RansDecSymbol;$/;"	t	typeref:struct:__anon57
RansDecSymbolInit	cram/rANS_byte.h	/^static inline void RansDecSymbolInit(RansDecSymbol* s, uint32_t start, uint32_t freq)$/;"	f
RansEncFlush	cram/rANS_byte.h	/^static inline void RansEncFlush(RansState* r, uint8_t** pptr)$/;"	f
RansEncInit	cram/rANS_byte.h	/^static inline void RansEncInit(RansState* r)$/;"	f
RansEncPut	cram/rANS_byte.h	/^static inline void RansEncPut(RansState* r, uint8_t** pptr, uint32_t start, uint32_t freq, uint32_t scale_bits)$/;"	f
RansEncPutSymbol	cram/rANS_byte.h	/^static inline void RansEncPutSymbol(RansState* r, uint8_t** pptr, RansEncSymbol const* sym)$/;"	f
RansEncRenorm	cram/rANS_byte.h	/^static inline RansState RansEncRenorm(RansState x, uint8_t** pptr, uint32_t freq, uint32_t scale_bits)$/;"	f
RansEncSymbol	cram/rANS_byte.h	/^} RansEncSymbol;$/;"	t	typeref:struct:__anon56
RansEncSymbolInit	cram/rANS_byte.h	/^static inline void RansEncSymbolInit(RansEncSymbol* s, uint32_t start, uint32_t freq, uint32_t scale_bits)$/;"	f
RansState	cram/rANS_byte.h	/^typedef uint32_t RansState;$/;"	t
S	cram/cram_structs.h	/^	} S;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon86
SAM_AUX	htslib/hts.h	/^    SAM_AUX   = 0x00000800,$/;"	e	enum:sam_fields
SAM_CIGAR	htslib/hts.h	/^    SAM_CIGAR = 0x00000020,$/;"	e	enum:sam_fields
SAM_FLAG	htslib/hts.h	/^    SAM_FLAG  = 0x00000002,$/;"	e	enum:sam_fields
SAM_MAPQ	htslib/hts.h	/^    SAM_MAPQ  = 0x00000010,$/;"	e	enum:sam_fields
SAM_PG	cram/sam_header.h	/^} SAM_PG;$/;"	t	typeref:struct:__anon64
SAM_PNEXT	htslib/hts.h	/^    SAM_PNEXT = 0x00000080,$/;"	e	enum:sam_fields
SAM_POS	htslib/hts.h	/^    SAM_POS   = 0x00000008,$/;"	e	enum:sam_fields
SAM_QNAME	htslib/hts.h	/^    SAM_QNAME = 0x00000001,$/;"	e	enum:sam_fields
SAM_QUAL	htslib/hts.h	/^    SAM_QUAL  = 0x00000400,$/;"	e	enum:sam_fields
SAM_RG	cram/sam_header.h	/^} SAM_RG;$/;"	t	typeref:struct:__anon63
SAM_RGAUX	htslib/hts.h	/^    SAM_RGAUX = 0x00001000,$/;"	e	enum:sam_fields
SAM_RNAME	htslib/hts.h	/^    SAM_RNAME = 0x00000004,$/;"	e	enum:sam_fields
SAM_RNEXT	htslib/hts.h	/^    SAM_RNEXT = 0x00000040,$/;"	e	enum:sam_fields
SAM_SEQ	htslib/hts.h	/^    SAM_SEQ   = 0x00000200,$/;"	e	enum:sam_fields
SAM_SQ	cram/sam_header.h	/^} SAM_SQ;$/;"	t	typeref:struct:__anon62
SAM_TLEN	htslib/hts.h	/^    SAM_TLEN  = 0x00000100,$/;"	e	enum:sam_fields
SAM_hdr	cram/sam_header.h	/^} SAM_hdr;$/;"	t	typeref:struct:__anon65
SAM_hdr	htslib/cram.h	/^typedef struct SAM_hdr SAM_hdr;$/;"	t	typeref:struct:SAM_hdr
SAM_hdr_item_s	cram/sam_header.h	/^typedef struct SAM_hdr_item_s {$/;"	s
SAM_hdr_tag	cram/sam_header.h	/^} SAM_hdr_tag;$/;"	t	typeref:struct:SAM_hdr_tag_s
SAM_hdr_tag_s	cram/sam_header.h	/^typedef struct SAM_hdr_tag_s {$/;"	s
SAM_hdr_type	cram/sam_header.h	/^} SAM_hdr_type;$/;"	t	typeref:struct:SAM_hdr_item_s
SEEK	bgzf.c	/^    SEEK,$/;"	e	enum:mtaux_cmd	file:
SEEK_CUR	cram/os.h	189;"	d
SEEK_END	cram/os.h	190;"	d
SEEK_SET	cram/os.h	188;"	d
SEQS_PER_SLICE	cram/cram_structs.h	86;"	d
SET	md5.c	104;"	d	file:
SET	md5.c	99;"	d	file:
SHLIB_FLAVOUR	Makefile	/^SHLIB_FLAVOUR = cygdll$/;"	m
SHLIB_FLAVOUR	Makefile	/^SHLIB_FLAVOUR = dll$/;"	m
SHLIB_FLAVOUR	Makefile	/^SHLIB_FLAVOUR = dylib$/;"	m
SHLIB_FLAVOUR	Makefile	/^SHLIB_FLAVOUR = so$/;"	m
SLICE_PER_CNT	cram/cram_structs.h	88;"	d
SR_INDEL	bcf_sr_sort.c	32;"	d	file:
SR_OTHER	bcf_sr_sort.c	33;"	d	file:
SR_REF	bcf_sr_sort.c	30;"	d	file:
SR_SCORE	bcf_sr_sort.c	34;"	d	file:
SR_SNP	bcf_sr_sort.c	31;"	d	file:
SSIZE_MAX	hfile.c	50;"	d	file:
STATE	textutils.c	228;"	d	file:
STATE	textutils.c	264;"	d	file:
STEP	md5.c	85;"	d	file:
STRNCMP	sam.c	1743;"	d	file:
SW_BWD	vcf_sweep.c	31;"	d	file:
SW_FWD	vcf_sweep.c	30;"	d	file:
S_ISDIR	cram/files.c	42;"	d	file:
S_ISREG	cram/files.c	45;"	d	file:
T16	test/hts_endian.c	64;"	d	file:
T32	test/hts_endian.c	75;"	d	file:
T64	test/hts_endian.c	93;"	d	file:
TASK_SIZE	thread_pool.c	997;"	d	file:
TBX_GENERIC	htslib/tbx.h	38;"	d
TBX_MAX_SHIFT	htslib/tbx.h	36;"	d
TBX_SAM	htslib/tbx.h	39;"	d
TBX_UCSC	htslib/tbx.h	41;"	d
TBX_VCF	htslib/tbx.h	40;"	d
TD	test/hts_endian.c	128;"	d	file:
TDIFF	thread_pool.c	458;"	d	file:
TD_blk	cram/cram_structs.h	/^    cram_block *TD_blk;          \/\/ Tag Dictionary$/;"	m	struct:cram_block_compression_hdr
TD_hash	cram/cram_structs.h	/^    khash_t(m_s2i) *TD_hash;     \/\/ Keyed on TD strings, map to TL[] indices$/;"	m	struct:cram_block_compression_hdr
TD_keys	cram/cram_structs.h	/^    string_alloc_t *TD_keys;     \/\/ Pooled keys for TD hash.$/;"	m	struct:cram_block_compression_hdr
TF	test/hts_endian.c	116;"	d	file:
TF_SHIFT	cram/rANS_static.c	51;"	d	file:
THREAD_POOL_INTERNAL_H	thread_pool_internal.h	43;"	d
TL	cram/cram_structs.h	/^    int     TL;$/;"	m	struct:cram_record
TL	cram/cram_structs.h	/^    unsigned char **TL;          \/\/ array of size nTL, pointer into TD_blk.$/;"	m	struct:cram_block_compression_hdr
TN	cram/cram_structs.h	/^    uint32_t      *TN;$/;"	m	struct:cram_slice
TN_idx	cram/cram_structs.h	/^    int32_t TN_idx;       \/\/ TN; idx to s->TN;$/;"	m	struct:cram_record
TOTFREQ	cram/rANS_static.c	52;"	d	file:
TRIAL_SPAN	cram/cram_io.c	94;"	d	file:
Test16	test/hts_endian.c	/^} Test16;$/;"	t	typeref:struct:__anon43	file:
Test32	test/hts_endian.c	/^} Test32;$/;"	t	typeref:struct:__anon44	file:
Test64	test/hts_endian.c	/^} Test64;$/;"	t	typeref:struct:__anon45	file:
Test_double	test/hts_endian.c	/^} Test_double;$/;"	t	typeref:struct:__anon47	file:
Test_float	test/hts_endian.c	/^} Test_float;$/;"	t	typeref:struct:__anon46	file:
UNMAPPED_SLICE	cram/cram_structs.h	/^    UNMAPPED_SLICE     = 3, \/\/ CRAM V1.0 only$/;"	e	enum:cram_content_type
UNMAPPED_SLICE	htslib/cram.h	/^    UNMAPPED_SLICE     = 3, \/\/ CRAM V1.0 only$/;"	e	enum:cram_content_type
USE_BGZF_DOPEN	test/test_bgzf.c	/^    USE_BGZF_DOPEN,$/;"	e	enum:__anon49	file:
USE_BGZF_HOPEN	test/test_bgzf.c	/^    USE_BGZF_HOPEN$/;"	e	enum:__anon49	file:
USE_BGZF_OPEN	test/test_bgzf.c	/^    USE_BGZF_OPEN,$/;"	e	enum:__anon49	file:
VCF_BND	htslib/vcf.h	140;"	d
VCF_INDEL	htslib/vcf.h	138;"	d
VCF_MNP	htslib/vcf.h	137;"	d
VCF_OTHER	htslib/vcf.h	139;"	d
VCF_REF	htslib/vcf.h	135;"	d
VCF_SNP	htslib/vcf.h	136;"	d
WIN32_LEAN_AND_MEAN	bgzip.c	40;"	d	file:
WINDOW_SIZE	bgzip.c	/^static const int WINDOW_SIZE = 64 * 1024;$/;"	v	file:
WRITE_COMPRESSED	test/test_view.c	/^    WRITE_COMPRESSED = 2,$/;"	e	enum:test_op	file:
WRITE_CRAM	test/test_view.c	/^    WRITE_CRAM       = 8$/;"	e	enum:test_op	file:
X	cram/cram_structs.h	/^	} X;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon82
Z_CRAM_STRAT	cram/cram_encode.c	50;"	d	file:
_AC_KLIST_H	htslib/klist.h	27;"	d
_CRAM_ENCODINGS_H_	cram/cram_codecs.h	32;"	d
_CRAM_H_	cram/cram.h	43;"	d
_CRAM_INDEX_H_	cram/cram_index.h	32;"	d
_CRAM_IO_H_	cram/cram_io.h	43;"	d
_CRAM_READ_H_	cram/cram_decode.h	42;"	d
_CRAM_SAMTOOLS_H_	cram/cram_samtools.h	32;"	d
_CRAM_STATS_H_	cram/cram_stats.h	32;"	d
_CRAM_STRUCTS_H_	cram/cram_structs.h	32;"	d
_CRAM_WRITE_H_	cram/cram_encode.h	42;"	d
_MFILE_H_	cram/mFILE.h	32;"	d
_OPEN_TRACE_FILE_H_	cram/open_trace_file.h	65;"	d
_OS_H_	cram/os.h	76;"	d
_POOLED_ALLOC_H_	cram/pooled_alloc.h	32;"	d
_SAM_HDR_H_	cram/sam_header.h	48;"	d
_STRING_ALLOC_H_	cram/string_alloc.h	32;"	d
__AC_KHASH_H	htslib/khash.h	118;"	d
__BCF_SR_SORT_H__	bcf_sr_sort.h	35;"	d
__KHASH_IMPL	htslib/khash.h	211;"	d
__KHASH_PROTOTYPES	htslib/khash.h	202;"	d
__KHASH_TYPE	htslib/khash.h	194;"	d
__KSEQ_BASIC	htslib/kseq.h	169;"	d
__KSEQ_READ	htslib/kseq.h	189;"	d
__KSEQ_TYPE	htslib/kseq.h	231;"	d
__KS_BASIC	htslib/kseq.h	52;"	d
__KS_GETUNTIL	htslib/kseq.h	94;"	d
__KS_INLINED	htslib/kseq.h	67;"	d
__KS_TYPE	htslib/kseq.h	40;"	d
__NORETURN__	cram/misc.h	83;"	d
__NORETURN__	cram/misc.h	85;"	d
__PRI64__	cram/os.h	167;"	d
__PRINTF_FORMAT__	cram/misc.h	94;"	d
__PRINTF_FORMAT__	cram/misc.h	96;"	d
__ac_HASH_UPPER	htslib/khash.h	/^static const double __ac_HASH_UPPER = 0.77;$/;"	v
__ac_Wang_hash	htslib/khash.h	/^static kh_inline khint_t __ac_Wang_hash(khint_t key)$/;"	f
__ac_X31_hash_string	htslib/khash.h	/^static kh_inline khint_t __ac_X31_hash_string(const char *s)$/;"	f
__ac_fsize	htslib/khash.h	173;"	d
__ac_isdel	htslib/khash.h	166;"	d
__ac_iseither	htslib/khash.h	167;"	d
__ac_isempty	htslib/khash.h	165;"	d
__ac_set_isboth_false	htslib/khash.h	170;"	d
__ac_set_isdel_false	htslib/khash.h	168;"	d
__ac_set_isdel_true	htslib/khash.h	171;"	d
__ac_set_isempty_false	htslib/khash.h	169;"	d
__bam_mplp_t	sam.c	/^struct __bam_mplp_t {$/;"	s	file:
__bam_plp_t	sam.c	/^struct __bam_plp_t {$/;"	s	file:
__bgzidx_t	bgzf.c	/^struct __bgzidx_t$/;"	s	file:
__err_connect	knetfile.c	153;"	d	file:
__err_connect	knetfile.c	92;"	d	file:
__hts_idx_t	hts.c	/^struct __hts_idx_t {$/;"	s	file:
__ksplit_aux	kstring.c	210;"	d	file:
__kstring_t	htslib/bgzf.h	/^typedef struct __kstring_t {$/;"	s
__kstring_t	htslib/hts.h	/^typedef struct __kstring_t {$/;"	s
__kstring_t	htslib/kseq.h	/^typedef struct __kstring_t {$/;"	s
__kstring_t	htslib/kstring.h	/^typedef struct __kstring_t {$/;"	s
__linkbuf_t	sam.c	/^typedef struct __linkbuf_t {$/;"	s	file:
_bcf1_sync_alleles	vcf.c	/^static inline int _bcf1_sync_alleles(const bcf_hdr_t *hdr, bcf1_t *line, int nals)$/;"	f	file:
_bcf_hrec_format	vcf.c	/^static void _bcf_hrec_format(const bcf_hrec_t *hrec, int is_bcf, kstring_t *str)$/;"	f	file:
_bcf_sr_regions_t	htslib/synced_bcf_reader.h	/^typedef struct _bcf_sr_regions_t$/;"	s
_bcf_sweep_t	vcf_sweep.c	/^struct _bcf_sweep_t$/;"	s	file:
_cln	sam.c	1867;"	d	file:
_cmd	test/test-bcf-sr.pl	/^sub _cmd$/;"	s
_cmd	test/test.pl	/^sub _cmd$/;"	s
_cop	sam.c	1866;"	d	file:
_dorand48	win/rand.c	/^_dorand48(unsigned short xseed[3])$/;"	f	file:
_get_mem	sam.c	1170;"	d	file:
_get_mem	sam.c	947;"	d	file:
_kf_gammap	kfunc.c	/^static double _kf_gammap(double s, double z)$/;"	f	file:
_kf_gammaq	kfunc.c	/^static double _kf_gammaq(double s, double z)$/;"	f	file:
_misc_h	cram/misc.h	64;"	d
_parse_err	sam.c	1168;"	d	file:
_parse_err	sam.c	948;"	d	file:
_parse_err_param	sam.c	1169;"	d	file:
_parse_err_param	sam.c	949;"	d	file:
_parse_warn	sam.c	1167;"	d	file:
_parse_warn	sam.c	950;"	d	file:
_rand48_add	win/rand.c	/^static unsigned short _rand48_add = RAND48_ADD;$/;"	v	file:
_rand48_mult	win/rand.c	/^static unsigned short _rand48_mult[3] = {$/;"	v	file:
_rand48_seed	win/rand.c	/^static unsigned short _rand48_seed[3] = {$/;"	v	file:
_read_token	sam.c	1172;"	d	file:
_read_token	sam.c	945;"	d	file:
_read_token_aux	sam.c	1171;"	d	file:
_read_token_aux	sam.c	946;"	d	file:
_reader_fill_buffer	synced_bcf_reader.c	/^static void _reader_fill_buffer(bcf_srs_t *files, bcf_sr_t *reader)$/;"	f	file:
_reader_next_line	synced_bcf_reader.c	/^int _reader_next_line(bcf_srs_t *files)$/;"	f
_reader_seek	synced_bcf_reader.c	/^static int _reader_seek(bcf_sr_t *reader, const char *seq, int start, int end)$/;"	f	file:
_reader_shift_buffer	synced_bcf_reader.c	/^static void _reader_shift_buffer(bcf_sr_t *reader)$/;"	f	file:
_readers_next_region	synced_bcf_reader.c	/^static int _readers_next_region(bcf_srs_t *files)$/;"	f	file:
_regidx_build_index	regidx.c	/^int _regidx_build_index(regidx_t *idx)$/;"	f
_regidx_t	regidx.c	/^struct _regidx_t$/;"	s	file:
_region_t	synced_bcf_reader.c	/^typedef struct _region_t$/;"	s	file:
_regions_add	synced_bcf_reader.c	/^static void _regions_add(bcf_sr_regions_t *reg, const char *chr, int start, int end)$/;"	f	file:
_regions_init_string	synced_bcf_reader.c	/^static bcf_sr_regions_t *_regions_init_string(const char *str)$/;"	f	file:
_regions_match_alleles	synced_bcf_reader.c	/^static int _regions_match_alleles(bcf_sr_regions_t *reg, int als_idx, bcf1_t *rec)$/;"	f	file:
_regions_parse_line	synced_bcf_reader.c	/^static int _regions_parse_line(char *line, int ichr,int ifrom,int ito, char **chr,char **chr_end,int *from,int *to)$/;"	f	file:
_skip_to_comma	sam.c	1149;"	d	file:
_skip_to_comma	sam.c	1160;"	d	file:
a	htslib/hts.h	/^        int *a;$/;"	m	struct:__anon14::__anon15
a	md5.c	/^	hts_md5_u32plus a, b, c, d;$/;"	m	struct:hts_md5_context	file:
aTN	cram/cram_structs.h	/^    int           nTN, aTN;  \/\/ used and allocated size for TN[]$/;"	m	struct:cram_slice
add_callback_headers	hfile_libcurl.c	/^static int add_callback_headers(hFILE_libcurl *fp) {$/;"	f	file:
add_md_char	cram/cram_decode.c	/^static inline void add_md_char(cram_slice *s, int decode_md, char c, int32_t *md_dist) {$/;"	f	file:
add_read_names	cram/cram_encode.c	/^static void add_read_names(cram_fd *fd, cram_container *c, cram_slice *s,$/;"	f	file:
aend	cram/cram_structs.h	/^    int32_t aend;         \/\/ alignment end$/;"	m	struct:cram_record
afeatures	cram/cram_structs.h	/^    int           afeatures; \/\/ allocated size of features$/;"	m	struct:cram_slice
align_mem	vcf.c	/^static inline void align_mem(kstring_t *s)$/;"	f	file:
allele	htslib/vcf.h	/^    char **allele;      \/\/ allele[0] is the REF (allele[] pointers to the als block); all null terminated$/;"	m	struct:__anon24
alloc	cram/cram_structs.h	/^    size_t alloc;$/;"	m	struct:cram_block
alloced	cram/mFILE.h	/^    size_t alloced;$/;"	m	struct:__anon58
als	htslib/synced_bcf_reader.h	/^    char **als;             \/\/ parsed alleles if targets_als set and _regions_match_alleles called$/;"	m	struct:_bcf_sr_regions_t
als	htslib/vcf.h	/^    char *id, *als;     \/\/ ID and REF+ALT block (\\0-seperated)$/;"	m	struct:__anon24
als_str	htslib/synced_bcf_reader.h	/^    kstring_t als_str;      \/\/ block of parsed alleles$/;"	m	struct:_bcf_sr_regions_t
als_type	htslib/synced_bcf_reader.h	/^    int als_type;           \/\/ alleles type, currently VCF_SNP or VCF_INDEL$/;"	m	struct:_bcf_sr_regions_t
api_usage_error	htslib/synced_bcf_reader.h	/^    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,$/;"	e	enum:__anon30
api_version	hfile_internal.h	/^    int api_version;$/;"	m	struct:hFILE_plugin
apos	cram/cram_structs.h	/^    int32_t apos;         \/\/ AP$/;"	m	struct:cram_record
append_header	hfile_libcurl.c	/^static int append_header(hdrlist *hdrs, const char *data, int dup) {$/;"	f	file:
append_sub32	cram/cram_io.h	/^static inline unsigned char *append_sub32(unsigned char *cp, uint32_t i) {$/;"	f
append_uint32	cram/cram_io.h	/^static inline unsigned char *append_uint32(unsigned char *cp, uint32_t i) {$/;"	f
append_uint64	cram/cram_io.h	/^static inline unsigned char *append_uint64(unsigned char *cp, uint64_t i) {$/;"	f
apply_filters	htslib/synced_bcf_reader.h	/^    char *apply_filters;    \/\/ If set, sites where none of the FILTER strings is listed$/;"	m	struct:__anon31
arg	htslib/hts.h	/^    char *arg;                \/\/ string form, strdup()ed$/;"	m	struct:hts_opt
arg	thread_pool_internal.h	/^    void *arg;$/;"	m	struct:hts_tpool_job
args_t	tabix.c	/^args_t;$/;"	t	typeref:struct:__anon97	file:
ari_decoder	cram/rANS_static.c	/^} ari_decoder;$/;"	t	typeref:struct:__anon59	file:
at_eof	htslib/hfile.h	/^    unsigned at_eof:1, mobile:1, readonly:1;$/;"	m	struct:hFILE
auth_hdr	hfile_s3.c	/^    kstring_t auth_hdr;$/;"	m	struct:__anon53	file:
auth_header_callback	hfile_s3.c	/^static int auth_header_callback(void *ctx, char ***hdrs) {$/;"	f	file:
auth_time	hfile_s3.c	/^    time_t auth_time;$/;"	m	struct:__anon53	file:
aux	cram/cram_structs.h	/^    int32_t aux;          \/\/ idx to s->aux_blk$/;"	m	struct:cram_record
aux	htslib/sam.h	/^    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, aux:28;$/;"	m	struct:__anon40
aux	htslib/synced_bcf_reader.h	/^    void *aux;          \/\/ Opaque auxiliary data$/;"	m	struct:__anon31
aux_blk	cram/cram_structs.h	/^    cram_block *aux_blk;       \/\/ BAM aux block, created while decoding CRAM$/;"	m	struct:cram_slice
aux_block	cram/cram_structs.h	/^    cram_block **aux_block;$/;"	m	struct:cram_slice
aux_fields1	test/sam.c	/^static int aux_fields1(void)$/;"	f	file:
aux_size	cram/cram_structs.h	/^    int32_t aux_size;     \/\/ total size of packed ntags in aux_blk$/;"	m	struct:cram_record
aux_t	synced_bcf_reader.c	/^aux_t;$/;"	t	typeref:struct:__anon106	file:
aux_to_le	sam.c	/^static int aux_to_le(char type, uint8_t *out, const uint8_t *in, size_t len) {$/;"	f	file:
aux_type2size	sam.c	/^static inline int aux_type2size(uint8_t type)$/;"	f	file:
aux_val_to_le	sam.c	1396;"	d	file:
aux_val_to_le	sam.c	1409;"	d	file:
b	cram/cram_codecs.h	/^    cram_block *b;$/;"	m	struct:__anon74
b	cram/cram_codecs.h	/^    cram_block *b;$/;"	m	struct:__anon76
b	cram/cram_structs.h	/^	} b;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon84
b	htslib/kbitset.h	/^	unsigned long b[1];$/;"	m	struct:kbitset_t
b	htslib/sam.h	/^    bam1_t *b;$/;"	m	struct:__anon40
b	md5.c	/^	hts_md5_u32plus a, b, c, d;$/;"	m	struct:hts_md5_context	file:
b	sam.c	/^    bam1_t *b;$/;"	m	struct:__bam_plp_t	file:
b	sam.c	/^    bam1_t b;$/;"	m	struct:__linkbuf_t	file:
backend	htslib/hfile.h	/^    const struct hFILE_backend *backend;$/;"	m	struct:hFILE	typeref:struct:hFILE::hFILE_backend
bai	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
bam	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
bam1_core_t	htslib/sam.h	/^} bam1_core_t;$/;"	t	typeref:struct:__anon37
bam1_t	htslib/sam.h	/^} bam1_t;$/;"	t	typeref:struct:__anon38
bam_aux	cram/cram_samtools.h	53;"	d
bam_aux2A	sam.c	/^char bam_aux2A(const uint8_t *s)$/;"	f
bam_aux2Z	sam.c	/^char *bam_aux2Z(const uint8_t *s)$/;"	f
bam_aux2f	sam.c	/^double bam_aux2f(const uint8_t *s)$/;"	f
bam_aux2i	sam.c	/^int64_t bam_aux2i(const uint8_t *s)$/;"	f
bam_auxB2f	sam.c	/^double bam_auxB2f(const uint8_t *s, uint32_t idx)$/;"	f
bam_auxB2i	sam.c	/^int64_t bam_auxB2i(const uint8_t *s, uint32_t idx)$/;"	f
bam_auxB_len	sam.c	/^uint32_t bam_auxB_len(const uint8_t *s)$/;"	f
bam_aux_append	sam.c	/^int bam_aux_append(bam1_t *b, const char tag[2], char type, int len, const uint8_t *data)$/;"	f
bam_aux_del	sam.c	/^int bam_aux_del(bam1_t *b, uint8_t *s)$/;"	f
bam_aux_get	sam.c	/^uint8_t *bam_aux_get(const bam1_t *b, const char tag[2])$/;"	f
bam_aux_update_str	sam.c	/^int bam_aux_update_str(bam1_t *b, const char tag[2], int len, const char *data)$/;"	f
bam_bin	cram/cram_samtools.h	46;"	d
bam_blk_size	cram/cram_samtools.h	35;"	d
bam_cigar	cram/cram_samtools.h	52;"	d
bam_cigar2qlen	sam.c	/^int bam_cigar2qlen(int n_cigar, const uint32_t *cigar)$/;"	f
bam_cigar2rlen	sam.c	/^int bam_cigar2rlen(int n_cigar, const uint32_t *cigar)$/;"	f
bam_cigar_gen	htslib/sam.h	88;"	d
bam_cigar_len	cram/cram_samtools.h	44;"	d
bam_cigar_op	htslib/sam.h	81;"	d
bam_cigar_opchr	htslib/sam.h	87;"	d
bam_cigar_oplen	htslib/sam.h	82;"	d
bam_cigar_type	htslib/sam.h	109;"	d
bam_construct_seq	cram/cram_samtools.c	/^int bam_construct_seq(bam_seq_t **bp, size_t extra_len,$/;"	f
bam_copy1	sam.c	/^bam1_t *bam_copy1(bam1_t *bdst, const bam1_t *bsrc)$/;"	f
bam_destroy1	sam.c	/^void bam_destroy1(bam1_t *b)$/;"	f
bam_dup	cram/cram_samtools.h	55;"	d
bam_dup1	sam.c	/^bam1_t *bam_dup1(const bam1_t *bsrc)$/;"	f
bam_endpos	sam.c	/^int32_t bam_endpos(const bam1_t *b)$/;"	f
bam_flag	cram/cram_samtools.h	45;"	d
bam_flag2str	sam.c	/^char *bam_flag2str(int flag)$/;"	f
bam_flag_swap	cram/cram_structs.h	/^    unsigned int bam_flag_swap[0x1000]; \/\/ cram -> bam flags$/;"	m	struct:cram_fd
bam_free	cram/cram_samtools.h	57;"	d
bam_get_aux	htslib/sam.h	247;"	d
bam_get_cigar	htslib/sam.h	224;"	d
bam_get_l_aux	htslib/sam.h	253;"	d
bam_get_qname	htslib/sam.h	214;"	d
bam_get_qual	htslib/sam.h	241;"	d
bam_get_seq	htslib/sam.h	235;"	d
bam_hdr_destroy	sam.c	/^void bam_hdr_destroy(bam_hdr_t *h)$/;"	f
bam_hdr_dup	sam.c	/^bam_hdr_t *bam_hdr_dup(const bam_hdr_t *h0)$/;"	f
bam_hdr_init	sam.c	/^bam_hdr_t *bam_hdr_init()$/;"	f
bam_hdr_read	sam.c	/^bam_hdr_t *bam_hdr_read(BGZF *fp)$/;"	f
bam_hdr_t	htslib/sam.h	/^} bam_hdr_t;$/;"	t	typeref:struct:__anon36
bam_hdr_write	sam.c	/^int bam_hdr_write(BGZF *fp, const bam_hdr_t *h)$/;"	f
bam_header_to_cram	cram/cram_samtools.c	/^SAM_hdr *bam_header_to_cram(bam_hdr_t *h) {$/;"	f
bam_index	sam.c	/^static hts_idx_t *bam_index(BGZF *fp, int min_shift)$/;"	f	file:
bam_index_build	htslib/sam.h	317;"	d
bam_index_build	sam.c	/^int bam_index_build(const char *fn, int min_shift)$/;"	f
bam_index_build	sam.c	556;"	d	file:
bam_index_load	htslib/sam.h	316;"	d
bam_init1	sam.c	/^bam1_t *bam_init1()$/;"	f
bam_ins_size	cram/cram_samtools.h	42;"	d
bam_is_mrev	htslib/sam.h	208;"	d
bam_is_rev	htslib/sam.h	202;"	d
bam_itr_destroy	htslib/sam.h	309;"	d
bam_itr_next	htslib/sam.h	312;"	d
bam_itr_queryi	htslib/sam.h	310;"	d
bam_itr_querys	htslib/sam.h	311;"	d
bam_list_lock	cram/cram_structs.h	/^    pthread_mutex_t bam_list_lock;$/;"	m	struct:cram_fd
bam_map_qual	cram/cram_samtools.h	47;"	d
bam_mate_pos	cram/cram_samtools.h	40;"	d
bam_mate_ref	cram/cram_samtools.h	41;"	d
bam_mplp_auto	sam.c	/^int bam_mplp_auto(bam_mplp_t iter, int *_tid, int *_pos, int *n_plp, const bam_pileup1_t **plp)$/;"	f
bam_mplp_constructor	sam.c	/^void bam_mplp_constructor(bam_mplp_t iter,$/;"	f
bam_mplp_destroy	sam.c	/^void bam_mplp_destroy(bam_mplp_t iter)$/;"	f
bam_mplp_destructor	sam.c	/^void bam_mplp_destructor(bam_mplp_t iter,$/;"	f
bam_mplp_init	sam.c	/^bam_mplp_t bam_mplp_init(int n, bam_plp_auto_f func, void **data)$/;"	f
bam_mplp_init_overlaps	sam.c	/^void bam_mplp_init_overlaps(bam_mplp_t iter)$/;"	f
bam_mplp_reset	sam.c	/^void bam_mplp_reset(bam_mplp_t iter)$/;"	f
bam_mplp_set_maxcnt	sam.c	/^void bam_mplp_set_maxcnt(bam_mplp_t iter, int maxcnt)$/;"	f
bam_mplp_t	htslib/sam.h	/^typedef struct __bam_mplp_t *bam_mplp_t;$/;"	t	typeref:struct:__bam_mplp_t
bam_name	cram/cram_samtools.h	49;"	d
bam_name2id	sam.c	/^int bam_name2id(bam_hdr_t *h, const char *ref)$/;"	f
bam_name_len	cram/cram_samtools.h	48;"	d
bam_pileup1_t	htslib/sam.h	/^} bam_pileup1_t;$/;"	t	typeref:struct:__anon40
bam_pileup_cd	htslib/sam.h	/^} bam_pileup_cd;$/;"	t	typeref:union:__anon39
bam_plp_auto	sam.c	/^const bam_pileup1_t *bam_plp_auto(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp)$/;"	f
bam_plp_auto_f	htslib/sam.h	/^typedef int (*bam_plp_auto_f)(void *data, bam1_t *b);$/;"	t
bam_plp_constructor	sam.c	/^void bam_plp_constructor(bam_plp_t plp,$/;"	f
bam_plp_destroy	sam.c	/^void bam_plp_destroy(bam_plp_t iter)$/;"	f
bam_plp_destructor	sam.c	/^void bam_plp_destructor(bam_plp_t plp,$/;"	f
bam_plp_init	sam.c	/^bam_plp_t bam_plp_init(bam_plp_auto_f func, void *data)$/;"	f
bam_plp_init_overlaps	sam.c	/^void bam_plp_init_overlaps(bam_plp_t iter)$/;"	f
bam_plp_next	sam.c	/^const bam_pileup1_t *bam_plp_next(bam_plp_t iter, int *_tid, int *_pos, int *_n_plp)$/;"	f
bam_plp_push	sam.c	/^int bam_plp_push(bam_plp_t iter, const bam1_t *b)$/;"	f
bam_plp_reset	sam.c	/^void bam_plp_reset(bam_plp_t iter)$/;"	f
bam_plp_set_maxcnt	sam.c	/^void bam_plp_set_maxcnt(bam_plp_t iter, int maxcnt)$/;"	f
bam_plp_t	htslib/sam.h	/^typedef struct __bam_plp_t *bam_plp_t;$/;"	t	typeref:struct:__bam_plp_t
bam_pos	cram/cram_samtools.h	39;"	d
bam_qual	cram/cram_samtools.h	50;"	d
bam_read1	sam.c	/^int bam_read1(BGZF *fp, bam1_t *b)$/;"	f
bam_readrec	sam.c	/^static int bam_readrec(BGZF *fp, void *ignored, void *bv, int *tid, int *beg, int *end)$/;"	f	file:
bam_ref	cram/cram_samtools.h	38;"	d
bam_reg2bin	cram/cram_samtools.h	59;"	d
bam_seq	cram/cram_samtools.h	51;"	d
bam_seq_len	cram/cram_samtools.h	43;"	d
bam_seq_t	cram/cram_samtools.h	/^typedef bam1_t bam_seq_t;$/;"	t
bam_seqi	htslib/sam.h	260;"	d
bam_set_blk_size	cram/cram_samtools.h	36;"	d
bam_str2flag	sam.c	/^int bam_str2flag(const char *str)$/;"	f
bam_write1	sam.c	/^int bam_write1(BGZF *fp, const bam1_t *b)$/;"	f
bams	cram/cram_structs.h	/^    bam_seq_t **bams;$/;"	m	struct:cram_container
bams	cram/cram_structs.h	/^    bam_seq_t **bams;$/;"	m	struct:spare_bams
base	cram/cram_structs.h	/^	    int base;    \/\/ actual base & qual$/;"	m	struct:cram_feature::__anon81::__anon83
base	cram/cram_structs.h	/^	    int base;    \/\/ substitution code$/;"	m	struct:cram_feature::__anon81::__anon82
base	cram/cram_structs.h	/^	    int base; \/\/ insertion single base$/;"	m	struct:cram_feature::__anon81::__anon88
base	hfile.c	/^	hFILE base;$/;"	m	struct:__anon108	file:
base	hfile.c	/^    hFILE base;$/;"	m	struct:__anon107	file:
base	hfile.c	/^    hFILE base;$/;"	m	struct:__anon109	file:
base	hfile_libcurl.c	/^    hFILE base;$/;"	m	struct:__anon100	file:
base	hfile_net.c	/^    hFILE base;$/;"	m	struct:__anon42	file:
base	multipart.c	/^    hFILE base;$/;"	m	struct:__anon104	file:
base64_kput	hfile_s3.c	/^static void base64_kput(const unsigned char *data, size_t len, kstring_t *str)$/;"	f	file:
base_blk	cram/cram_structs.h	/^    cram_block *base_blk;$/;"	m	struct:cram_slice
bases_per_line	cram/cram_structs.h	/^    int bases_per_line;$/;"	m	struct:ref_entry
bases_per_slice	cram/cram_structs.h	/^    int bases_per_slice;$/;"	m	struct:cram_fd
bc	htslib/tbx.h	/^    int32_t sc, bc, ec; \/\/ seq col., beg col. and end col.$/;"	m	struct:__anon34
bcf	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
bcf1_sync	vcf.c	/^static int bcf1_sync(bcf1_t *line)$/;"	f	file:
bcf1_sync_alleles	vcf.c	/^static inline void bcf1_sync_alleles(bcf1_t *line, kstring_t *str)$/;"	f	file:
bcf1_sync_filter	vcf.c	/^static inline void bcf1_sync_filter(bcf1_t *line, kstring_t *str)$/;"	f	file:
bcf1_sync_id	vcf.c	/^static inline void bcf1_sync_id(bcf1_t *line, kstring_t *str)$/;"	f	file:
bcf1_sync_info	vcf.c	/^static inline void bcf1_sync_info(bcf1_t *line, kstring_t *str)$/;"	f	file:
bcf1_t	htslib/vcf.h	/^} bcf1_t;$/;"	t	typeref:struct:__anon25
bcf_acgt2int	htslib/vcfutils.h	/^static inline int bcf_acgt2int(char c)$/;"	f
bcf_add_filter	vcf.c	/^int bcf_add_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id)$/;"	f
bcf_add_id	vcf.c	/^int bcf_add_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)$/;"	f
bcf_alleles2gt	htslib/vcf.h	616;"	d
bcf_calc_ac	vcfutils.c	/^int bcf_calc_ac(const bcf_hdr_t *header, bcf1_t *line, int *ac, int which)$/;"	f
bcf_clear	vcf.c	/^void bcf_clear(bcf1_t *v)$/;"	f
bcf_clear1	htslib/vcf.h	248;"	d
bcf_close	htslib/vcf.h	287;"	d
bcf_copy	vcf.c	/^bcf1_t *bcf_copy(bcf1_t *dst, bcf1_t *src)$/;"	f
bcf_dec_int1	htslib/vcf.h	/^static inline int32_t bcf_dec_int1(const uint8_t *p, int type, uint8_t **q)$/;"	f
bcf_dec_size	htslib/vcf.h	/^static inline int32_t bcf_dec_size(const uint8_t *p, uint8_t **q, int *type)$/;"	f
bcf_dec_size_safe	vcf.c	/^static int bcf_dec_size_safe(uint8_t *p, uint8_t *end, uint8_t **q,$/;"	f	file:
bcf_dec_t	htslib/vcf.h	/^} bcf_dec_t;$/;"	t	typeref:struct:__anon24
bcf_dec_typed_int1	htslib/vcf.h	/^static inline int32_t bcf_dec_typed_int1(const uint8_t *p, uint8_t **q)$/;"	f
bcf_dec_typed_int1_safe	vcf.c	/^static int bcf_dec_typed_int1_safe(uint8_t *p, uint8_t *end, uint8_t **q,$/;"	f	file:
bcf_destroy	vcf.c	/^void bcf_destroy(bcf1_t *v)$/;"	f
bcf_destroy1	htslib/vcf.h	245;"	d
bcf_dup	vcf.c	/^bcf1_t *bcf_dup(bcf1_t *src)$/;"	f
bcf_empty	vcf.c	/^void bcf_empty(bcf1_t *v)$/;"	f
bcf_empty1	htslib/vcf.h	246;"	d
bcf_enc_int1	htslib/vcf.h	/^static inline void bcf_enc_int1(kstring_t *s, int32_t x)$/;"	f
bcf_enc_inttype	htslib/vcf.h	/^static inline int bcf_enc_inttype(long x)$/;"	f
bcf_enc_size	htslib/vcf.h	/^static inline void bcf_enc_size(kstring_t *s, int size, int type)$/;"	f
bcf_enc_vchar	vcf.c	/^void bcf_enc_vchar(kstring_t *s, int l, const char *a)$/;"	f
bcf_enc_vfloat	vcf.c	/^void bcf_enc_vfloat(kstring_t *s, int n, float *a)$/;"	f
bcf_enc_vint	vcf.c	/^void bcf_enc_vint(kstring_t *s, int n, int32_t *a, int wsize)$/;"	f
bcf_float_is_missing	htslib/vcf.h	/^static inline int bcf_float_is_missing(float f)$/;"	f
bcf_float_is_vector_end	htslib/vcf.h	/^static inline int bcf_float_is_vector_end(float f)$/;"	f
bcf_float_missing	vcf.c	/^uint32_t bcf_float_missing    = 0x7F800001;$/;"	v
bcf_float_set	htslib/vcf.h	/^static inline void bcf_float_set(float *ptr, uint32_t value)$/;"	f
bcf_float_set_missing	htslib/vcf.h	885;"	d
bcf_float_set_vector_end	htslib/vcf.h	884;"	d
bcf_float_vector_end	vcf.c	/^uint32_t bcf_float_vector_end = 0x7F800002;$/;"	v
bcf_fmt_array	vcf.c	/^void bcf_fmt_array(kstring_t *s, int n, int type, void *data)$/;"	f
bcf_fmt_sized_array	vcf.c	/^uint8_t *bcf_fmt_sized_array(kstring_t *s, uint8_t *ptr)$/;"	f
bcf_fmt_t	htslib/vcf.h	/^} bcf_fmt_t;$/;"	t	typeref:struct:__anon21
bcf_format_gt	htslib/vcf.h	/^static inline void bcf_format_gt(bcf_fmt_t *fmt, int isample, kstring_t *str)$/;"	f
bcf_get_fmt	vcf.c	/^bcf_fmt_t *bcf_get_fmt(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)$/;"	f
bcf_get_fmt_id	vcf.c	/^bcf_fmt_t *bcf_get_fmt_id(bcf1_t *line, const int id)$/;"	f
bcf_get_format_char	htslib/vcf.h	726;"	d
bcf_get_format_float	htslib/vcf.h	725;"	d
bcf_get_format_int32	htslib/vcf.h	724;"	d
bcf_get_format_string	vcf.c	/^int bcf_get_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, char ***dst, int *ndst)$/;"	f
bcf_get_format_values	vcf.c	/^int bcf_get_format_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)$/;"	f
bcf_get_genotypes	htslib/vcf.h	727;"	d
bcf_get_info	vcf.c	/^bcf_info_t *bcf_get_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key)$/;"	f
bcf_get_info_flag	htslib/vcf.h	669;"	d
bcf_get_info_float	htslib/vcf.h	667;"	d
bcf_get_info_id	vcf.c	/^bcf_info_t *bcf_get_info_id(bcf1_t *line, const int id)$/;"	f
bcf_get_info_int32	htslib/vcf.h	666;"	d
bcf_get_info_string	htslib/vcf.h	668;"	d
bcf_get_info_values	vcf.c	/^int bcf_get_info_values(const bcf_hdr_t *hdr, bcf1_t *line, const char *tag, void **dst, int *ndst, int type)$/;"	f
bcf_get_variant_type	vcf.c	/^int bcf_get_variant_type(bcf1_t *rec, int ith_allele)$/;"	f
bcf_get_variant_types	vcf.c	/^int bcf_get_variant_types(bcf1_t *rec)$/;"	f
bcf_gt2alleles	htslib/vcf.h	/^    static inline void bcf_gt2alleles(int igt, int *a, int *b)$/;"	f
bcf_gt_allele	htslib/vcf.h	613;"	d
bcf_gt_is_missing	htslib/vcf.h	611;"	d
bcf_gt_is_phased	htslib/vcf.h	612;"	d
bcf_gt_missing	htslib/vcf.h	610;"	d
bcf_gt_phased	htslib/vcf.h	608;"	d
bcf_gt_type	vcfutils.c	/^int bcf_gt_type(bcf_fmt_t *fmt_ptr, int isample, int *_ial, int *_jal)$/;"	f
bcf_gt_unphased	htslib/vcf.h	609;"	d
bcf_has_filter	vcf.c	/^int bcf_has_filter(const bcf_hdr_t *hdr, bcf1_t *line, char *filter)$/;"	f
bcf_hdr_add_hrec	vcf.c	/^int bcf_hdr_add_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)$/;"	f
bcf_hdr_add_sample	vcf.c	/^int bcf_hdr_add_sample(bcf_hdr_t *h, const char *s)$/;"	f
bcf_hdr_append	vcf.c	/^int bcf_hdr_append(bcf_hdr_t *hdr, const char *line)$/;"	f
bcf_hdr_check_sanity	vcf.c	/^void bcf_hdr_check_sanity(bcf_hdr_t *hdr)$/;"	f
bcf_hdr_combine	vcf.c	/^int bcf_hdr_combine(bcf_hdr_t *dst, const bcf_hdr_t *src)$/;"	f
bcf_hdr_destroy	vcf.c	/^void bcf_hdr_destroy(bcf_hdr_t *h)$/;"	f
bcf_hdr_dup	vcf.c	/^bcf_hdr_t *bcf_hdr_dup(const bcf_hdr_t *hdr)$/;"	f
bcf_hdr_fmt_text	vcf.c	/^char *bcf_hdr_fmt_text(const bcf_hdr_t *hdr, int is_bcf, int *len)$/;"	f
bcf_hdr_format	vcf.c	/^int bcf_hdr_format(const bcf_hdr_t *hdr, int is_bcf, kstring_t *str)$/;"	f
bcf_hdr_get_hrec	vcf.c	/^bcf_hrec_t *bcf_hdr_get_hrec(const bcf_hdr_t *hdr, int type, const char *key, const char *value, const char *str_class)$/;"	f
bcf_hdr_get_version	vcf.c	/^const char *bcf_hdr_get_version(const bcf_hdr_t *hdr)$/;"	f
bcf_hdr_id2coltype	htslib/vcf.h	774;"	d
bcf_hdr_id2hrec	htslib/vcf.h	776;"	d
bcf_hdr_id2int	vcf.c	/^int bcf_hdr_id2int(const bcf_hdr_t *h, int which, const char *id)$/;"	f
bcf_hdr_id2length	htslib/vcf.h	771;"	d
bcf_hdr_id2name	htslib/vcf.h	/^    static inline const char *bcf_hdr_id2name(const bcf_hdr_t *hdr, int rid) { return hdr->id[BCF_DT_CTG][rid].key; }$/;"	f
bcf_hdr_id2number	htslib/vcf.h	772;"	d
bcf_hdr_id2type	htslib/vcf.h	773;"	d
bcf_hdr_idinfo_exists	htslib/vcf.h	775;"	d
bcf_hdr_init	vcf.c	/^bcf_hdr_t *bcf_hdr_init(const char *mode)$/;"	f
bcf_hdr_int2id	htslib/vcf.h	747;"	d
bcf_hdr_merge	vcf.c	/^bcf_hdr_t *bcf_hdr_merge(bcf_hdr_t *dst, const bcf_hdr_t *src)$/;"	f
bcf_hdr_name2id	htslib/vcf.h	/^    static inline int bcf_hdr_name2id(const bcf_hdr_t *hdr, const char *id) { return bcf_hdr_id2int(hdr, BCF_DT_CTG, id); }$/;"	f
bcf_hdr_nsamples	htslib/vcf.h	474;"	d
bcf_hdr_parse	vcf.c	/^int bcf_hdr_parse(bcf_hdr_t *hdr, char *htxt)$/;"	f
bcf_hdr_parse_line	vcf.c	/^bcf_hrec_t *bcf_hdr_parse_line(const bcf_hdr_t *h, const char *line, int *len)$/;"	f
bcf_hdr_parse_sample_line	vcf.c	/^int bcf_hdr_parse_sample_line(bcf_hdr_t *h, const char *str)$/;"	f
bcf_hdr_printf	vcf.c	/^int bcf_hdr_printf(bcf_hdr_t *hdr, const char *fmt, ...)$/;"	f
bcf_hdr_read	vcf.c	/^bcf_hdr_t *bcf_hdr_read(htsFile *hfp)$/;"	f
bcf_hdr_register_hrec	vcf.c	/^int bcf_hdr_register_hrec(bcf_hdr_t *hdr, bcf_hrec_t *hrec)$/;"	f
bcf_hdr_remove	vcf.c	/^void bcf_hdr_remove(bcf_hdr_t *hdr, int type, const char *key)$/;"	f
bcf_hdr_seqnames	vcf.c	/^const char **bcf_hdr_seqnames(const bcf_hdr_t *h, int *n)$/;"	f
bcf_hdr_set	vcf.c	/^int bcf_hdr_set(bcf_hdr_t *hdr, const char *fname)$/;"	f
bcf_hdr_set_idx	vcf.c	/^static int bcf_hdr_set_idx(bcf_hdr_t *hdr, int dict_type, const char *tag, bcf_idinfo_t *idinfo)$/;"	f	file:
bcf_hdr_set_samples	vcf.c	/^int bcf_hdr_set_samples(bcf_hdr_t *hdr, const char *samples, int is_file)$/;"	f
bcf_hdr_set_version	vcf.c	/^void bcf_hdr_set_version(bcf_hdr_t *hdr, const char *version)$/;"	f
bcf_hdr_subset	vcf.c	/^bcf_hdr_t *bcf_hdr_subset(const bcf_hdr_t *h0, int n, char *const* samples, int *imap)$/;"	f
bcf_hdr_sync	vcf.c	/^int bcf_hdr_sync(bcf_hdr_t *h)$/;"	f
bcf_hdr_t	htslib/vcf.h	/^} bcf_hdr_t;$/;"	t	typeref:struct:__anon19
bcf_hdr_write	vcf.c	/^int bcf_hdr_write(htsFile *hfp, bcf_hdr_t *h)$/;"	f
bcf_header_debug	vcf.c	/^void bcf_header_debug(bcf_hdr_t *hdr)$/;"	f
bcf_hrec_add_key	vcf.c	/^void bcf_hrec_add_key(bcf_hrec_t *hrec, const char *str, int len)$/;"	f
bcf_hrec_debug	vcf.c	/^void bcf_hrec_debug(FILE *fp, bcf_hrec_t *hrec)$/;"	f
bcf_hrec_destroy	vcf.c	/^void bcf_hrec_destroy(bcf_hrec_t *hrec)$/;"	f
bcf_hrec_dup	vcf.c	/^bcf_hrec_t *bcf_hrec_dup(bcf_hrec_t *hrec)$/;"	f
bcf_hrec_find_key	vcf.c	/^int bcf_hrec_find_key(bcf_hrec_t *hrec, const char *key)$/;"	f
bcf_hrec_format	vcf.c	/^void bcf_hrec_format(const bcf_hrec_t *hrec, kstring_t *str)$/;"	f
bcf_hrec_set_val	vcf.c	/^void bcf_hrec_set_val(bcf_hrec_t *hrec, int i, const char *str, int len, int is_quoted)$/;"	f
bcf_hrec_t	htslib/vcf.h	/^} bcf_hrec_t;$/;"	t	typeref:struct:__anon16
bcf_idinfo_def	vcf.c	/^static bcf_idinfo_t bcf_idinfo_def = { .info = { 15, 15, 15 }, .hrec = { NULL, NULL, NULL}, .id = -1 };$/;"	v	file:
bcf_idinfo_t	htslib/vcf.h	/^} bcf_idinfo_t;$/;"	t	typeref:struct:__anon17
bcf_idpair_t	htslib/vcf.h	/^} bcf_idpair_t;$/;"	t	typeref:struct:__anon18
bcf_idx	htslib/synced_bcf_reader.h	/^    hts_idx_t *bcf_idx;$/;"	m	struct:__anon29
bcf_ij2G	htslib/vcfutils.h	132;"	d
bcf_index	vcf.c	/^hts_idx_t *bcf_index(htsFile *fp, int min_shift)$/;"	f
bcf_index_build	vcf.c	/^int bcf_index_build(const char *fn, int min_shift)$/;"	f
bcf_index_build2	vcf.c	/^int bcf_index_build2(const char *fn, const char *fnidx, int min_shift)$/;"	f
bcf_index_build3	vcf.c	/^int bcf_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads)$/;"	f
bcf_index_load	htslib/vcf.h	798;"	d
bcf_index_load2	vcf.c	/^hts_idx_t *bcf_index_load2(const char *fn, const char *fnidx)$/;"	f
bcf_index_seqnames	htslib/vcf.h	799;"	d
bcf_info_t	htslib/vcf.h	/^} bcf_info_t;$/;"	t	typeref:struct:__anon22
bcf_init	vcf.c	/^bcf1_t *bcf_init()$/;"	f
bcf_init1	htslib/vcf.h	240;"	d
bcf_int16_missing	htslib/vcf.h	873;"	d
bcf_int16_vector_end	htslib/vcf.h	869;"	d
bcf_int2acgt	htslib/vcfutils.h	124;"	d
bcf_int32_missing	htslib/vcf.h	874;"	d
bcf_int32_vector_end	htslib/vcf.h	870;"	d
bcf_int8_missing	htslib/vcf.h	872;"	d
bcf_int8_vector_end	htslib/vcf.h	868;"	d
bcf_is_snp	vcf.c	/^int bcf_is_snp(bcf1_t *v)$/;"	f
bcf_itr_destroy	htslib/vcf.h	794;"	d
bcf_itr_next	htslib/vcf.h	797;"	d
bcf_itr_queryi	htslib/vcf.h	795;"	d
bcf_itr_querys	htslib/vcf.h	796;"	d
bcf_open	htslib/vcf.h	285;"	d
bcf_read	vcf.c	/^int bcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)$/;"	f
bcf_read1	htslib/vcf.h	241;"	d
bcf_read1_core	vcf.c	/^static inline int bcf_read1_core(BGZF *fp, bcf1_t *v)$/;"	f	file:
bcf_read_error	htslib/synced_bcf_reader.h	/^    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error$/;"	e	enum:__anon30
bcf_readrec	vcf.c	/^int bcf_readrec(BGZF *fp, void *null, void *vv, int *tid, int *beg, int *end)$/;"	f
bcf_record_check	vcf.c	/^static int bcf_record_check(const bcf_hdr_t *hdr, bcf1_t *rec) {$/;"	f	file:
bcf_remove_allele_set	vcfutils.c	/^int bcf_remove_allele_set(const bcf_hdr_t *header, bcf1_t *line, const struct kbitset_t *rm_set)$/;"	f
bcf_remove_alleles	vcfutils.c	/^void bcf_remove_alleles(const bcf_hdr_t *header, bcf1_t *line, int rm_mask)$/;"	f
bcf_remove_filter	vcf.c	/^int bcf_remove_filter(const bcf_hdr_t *hdr, bcf1_t *line, int flt_id, int pass)$/;"	f
bcf_seqname	htslib/vcf.h	/^    static inline const char *bcf_seqname(const bcf_hdr_t *hdr, bcf1_t *rec) { return hdr->id[BCF_DT_CTG][rec->rid].key; }$/;"	f
bcf_set_variant_type	vcf.c	/^static void bcf_set_variant_type(const char *ref, const char *alt, variant_t *var)$/;"	f	file:
bcf_set_variant_types	vcf.c	/^static void bcf_set_variant_types(bcf1_t *b)$/;"	f	file:
bcf_sr_add_reader	synced_bcf_reader.c	/^int bcf_sr_add_reader(bcf_srs_t *files, const char *fname)$/;"	f
bcf_sr_destroy	synced_bcf_reader.c	/^void bcf_sr_destroy(bcf_srs_t *files)$/;"	f
bcf_sr_destroy1	synced_bcf_reader.c	/^static void bcf_sr_destroy1(bcf_sr_t *reader)$/;"	f	file:
bcf_sr_destroy_threads	synced_bcf_reader.c	/^void bcf_sr_destroy_threads(bcf_srs_t *files) {$/;"	f
bcf_sr_error	htslib/synced_bcf_reader.h	/^bcf_sr_error;$/;"	t	typeref:enum:__anon30
bcf_sr_get_header	htslib/synced_bcf_reader.h	235;"	d
bcf_sr_get_line	htslib/synced_bcf_reader.h	232;"	d
bcf_sr_get_reader	htslib/synced_bcf_reader.h	236;"	d
bcf_sr_has_line	htslib/synced_bcf_reader.h	231;"	d
bcf_sr_init	synced_bcf_reader.c	/^bcf_srs_t *bcf_sr_init(void)$/;"	f
bcf_sr_init_scores	bcf_sr_sort.c	/^static void bcf_sr_init_scores(sr_sort_t *srt)$/;"	f	file:
bcf_sr_next_line	synced_bcf_reader.c	/^int bcf_sr_next_line(bcf_srs_t *files)$/;"	f
bcf_sr_opt_t	htslib/synced_bcf_reader.h	/^bcf_sr_opt_t;$/;"	t	typeref:enum:__anon28
bcf_sr_region_done	htslib/synced_bcf_reader.h	234;"	d
bcf_sr_regions_destroy	synced_bcf_reader.c	/^void bcf_sr_regions_destroy(bcf_sr_regions_t *reg)$/;"	f
bcf_sr_regions_flush	synced_bcf_reader.c	/^void bcf_sr_regions_flush(bcf_sr_regions_t *reg)$/;"	f
bcf_sr_regions_init	synced_bcf_reader.c	/^bcf_sr_regions_t *bcf_sr_regions_init(const char *regions, int is_file, int ichr, int ifrom, int ito)$/;"	f
bcf_sr_regions_next	synced_bcf_reader.c	/^int bcf_sr_regions_next(bcf_sr_regions_t *reg)$/;"	f
bcf_sr_regions_overlap	synced_bcf_reader.c	/^int bcf_sr_regions_overlap(bcf_sr_regions_t *reg, const char *seq, int start, int end)$/;"	f
bcf_sr_regions_seek	synced_bcf_reader.c	/^int bcf_sr_regions_seek(bcf_sr_regions_t *reg, const char *seq)$/;"	f
bcf_sr_regions_t	htslib/synced_bcf_reader.h	/^bcf_sr_regions_t;$/;"	t	typeref:struct:_bcf_sr_regions_t
bcf_sr_remove_reader	synced_bcf_reader.c	/^void bcf_sr_remove_reader(bcf_srs_t *files, int i)$/;"	f
bcf_sr_seek	synced_bcf_reader.c	/^int bcf_sr_seek(bcf_srs_t *readers, const char *seq, int pos)$/;"	f
bcf_sr_seek_start	synced_bcf_reader.c	/^static void bcf_sr_seek_start(bcf_srs_t *readers)$/;"	f	file:
bcf_sr_set_opt	synced_bcf_reader.c	/^int bcf_sr_set_opt(bcf_srs_t *readers, bcf_sr_opt_t opt, ...)$/;"	f
bcf_sr_set_regions	synced_bcf_reader.c	/^int bcf_sr_set_regions(bcf_srs_t *readers, const char *regions, int is_file)$/;"	f
bcf_sr_set_samples	synced_bcf_reader.c	/^int bcf_sr_set_samples(bcf_srs_t *files, const char *fname, int is_file)$/;"	f
bcf_sr_set_targets	synced_bcf_reader.c	/^int bcf_sr_set_targets(bcf_srs_t *readers, const char *targets, int is_file, int alleles)$/;"	f
bcf_sr_set_threads	synced_bcf_reader.c	/^int bcf_sr_set_threads(bcf_srs_t *files, int n_threads)$/;"	f
bcf_sr_sort_destroy	bcf_sr_sort.c	/^void bcf_sr_sort_destroy(sr_sort_t *srt)$/;"	f
bcf_sr_sort_init	bcf_sr_sort.c	/^sr_sort_t *bcf_sr_sort_init(sr_sort_t *srt)$/;"	f
bcf_sr_sort_next	bcf_sr_sort.c	/^int bcf_sr_sort_next(bcf_srs_t *readers, sr_sort_t *srt, const char *chr, int min_pos)$/;"	f
bcf_sr_sort_remove_reader	bcf_sr_sort.c	/^void bcf_sr_sort_remove_reader(bcf_srs_t *readers, sr_sort_t *srt, int i)$/;"	f
bcf_sr_sort_set	bcf_sr_sort.c	/^static void bcf_sr_sort_set(bcf_srs_t *readers, sr_sort_t *srt, const char *chr, int min_pos)$/;"	f	file:
bcf_sr_strerror	synced_bcf_reader.c	/^char *bcf_sr_strerror(int errnum)$/;"	f
bcf_sr_swap_line	htslib/synced_bcf_reader.h	233;"	d
bcf_sr_t	htslib/synced_bcf_reader.h	/^bcf_sr_t;$/;"	t	typeref:struct:__anon29
bcf_srs_t	htslib/synced_bcf_reader.h	/^bcf_srs_t;$/;"	t	typeref:struct:__anon31
bcf_str_missing	htslib/vcf.h	875;"	d
bcf_str_vector_end	htslib/vcf.h	871;"	d
bcf_subset	vcf.c	/^int bcf_subset(const bcf_hdr_t *h, bcf1_t *v, int n, int *imap)$/;"	f
bcf_subset_format	vcf.c	/^int bcf_subset_format(const bcf_hdr_t *hdr, bcf1_t *rec)$/;"	f
bcf_sweep_bwd	vcf_sweep.c	/^bcf1_t *bcf_sweep_bwd(bcf_sweep_t *sw)$/;"	f
bcf_sweep_destroy	vcf_sweep.c	/^void bcf_sweep_destroy(bcf_sweep_t *sw)$/;"	f
bcf_sweep_fwd	vcf_sweep.c	/^bcf1_t *bcf_sweep_fwd(bcf_sweep_t *sw)$/;"	f
bcf_sweep_hdr	vcf_sweep.c	/^bcf_hdr_t *bcf_sweep_hdr(bcf_sweep_t *sw) { return sw->hdr; }$/;"	f
bcf_sweep_init	vcf_sweep.c	/^bcf_sweep_t *bcf_sweep_init(const char *fname)$/;"	f
bcf_sweep_t	htslib/vcf_sweep.h	/^typedef struct _bcf_sweep_t bcf_sweep_t;$/;"	t	typeref:struct:_bcf_sweep_t
bcf_to_vcf	test/test-vcf-api.c	/^void bcf_to_vcf(char *fname)$/;"	f
bcf_translate	vcf.c	/^int bcf_translate(const bcf_hdr_t *dst_hdr, bcf_hdr_t *src_hdr, bcf1_t *line)$/;"	f
bcf_trim_alleles	vcfutils.c	/^int bcf_trim_alleles(const bcf_hdr_t *header, bcf1_t *line)$/;"	f
bcf_type_shift	vcf.c	/^uint8_t bcf_type_shift[] = { 0, 0, 1, 2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };$/;"	v
bcf_unpack	vcf.c	/^int bcf_unpack(bcf1_t *b, int which)$/;"	f
bcf_unpack_fmt_core1	vcf.c	/^static inline uint8_t *bcf_unpack_fmt_core1(uint8_t *ptr, int n_sample, bcf_fmt_t *fmt)$/;"	f	file:
bcf_unpack_info_core1	vcf.c	/^static inline uint8_t *bcf_unpack_info_core1(uint8_t *ptr, bcf_info_t *info)$/;"	f	file:
bcf_update_alleles	vcf.c	/^int bcf_update_alleles(const bcf_hdr_t *hdr, bcf1_t *line, const char **alleles, int nals)$/;"	f
bcf_update_alleles_str	vcf.c	/^int bcf_update_alleles_str(const bcf_hdr_t *hdr, bcf1_t *line, const char *alleles_string)$/;"	f
bcf_update_filter	vcf.c	/^int bcf_update_filter(const bcf_hdr_t *hdr, bcf1_t *line, int *flt_ids, int n)$/;"	f
bcf_update_format	vcf.c	/^int bcf_update_format(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)$/;"	f
bcf_update_format_char	htslib/vcf.h	600;"	d
bcf_update_format_float	htslib/vcf.h	599;"	d
bcf_update_format_int32	htslib/vcf.h	598;"	d
bcf_update_format_string	vcf.c	/^int bcf_update_format_string(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const char **values, int n)$/;"	f
bcf_update_genotypes	htslib/vcf.h	601;"	d
bcf_update_id	vcf.c	/^int bcf_update_id(const bcf_hdr_t *hdr, bcf1_t *line, const char *id)$/;"	f
bcf_update_info	vcf.c	/^int bcf_update_info(const bcf_hdr_t *hdr, bcf1_t *line, const char *key, const void *values, int n, int type)$/;"	f
bcf_update_info_flag	htslib/vcf.h	578;"	d
bcf_update_info_float	htslib/vcf.h	577;"	d
bcf_update_info_int32	htslib/vcf.h	576;"	d
bcf_update_info_string	htslib/vcf.h	579;"	d
bcf_write	vcf.c	/^int bcf_write(htsFile *hfp, bcf_hdr_t *h, bcf1_t *v)$/;"	f
bcf_write1	htslib/vcf.h	243;"	d
bed	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
beg	htslib/hts.h	/^    int tid, beg, end, n_off, i;$/;"	m	struct:__anon14
beg	sam.c	/^    int32_t beg, end;$/;"	m	struct:__linkbuf_t	file:
beg	tbx.c	/^    int64_t beg, end;$/;"	m	struct:__anon113	file:
begin	htslib/hfile.h	/^    char *buffer, *begin, *end, *limit;$/;"	m	struct:hFILE
beta	cram/cram_codecs.h	/^	cram_beta_decoder            beta;$/;"	m	union:cram_codec::__anon78
bgzf	htslib/hts.h	/^        BGZF *bgzf;$/;"	m	union:__anon9::__anon10
bgzf	htslib/hts.h	/^    no_compression, gzip, bgzf, custom,$/;"	e	enum:htsCompression
bgzf_block_write	bgzf.c	/^ssize_t bgzf_block_write(BGZF *fp, const void *data, size_t length)$/;"	f
bgzf_check_EOF	bgzf.c	/^int bgzf_check_EOF(BGZF *fp) {$/;"	f
bgzf_check_EOF_common	bgzf.c	/^static int bgzf_check_EOF_common(BGZF *fp)$/;"	f	file:
bgzf_close	bgzf.c	/^int bgzf_close(BGZF* fp)$/;"	f
bgzf_compress	bgzf.c	/^int bgzf_compress(void *_dst, size_t *dlen, const void *src, size_t slen, int level)$/;"	f
bgzf_compression	bgzf.c	/^int bgzf_compression(BGZF *fp)$/;"	f
bgzf_decode_func	bgzf.c	/^void *bgzf_decode_func(void *arg) {$/;"	f
bgzf_dopen	bgzf.c	/^BGZF *bgzf_dopen(int fd, const char *mode)$/;"	f
bgzf_encode_func	bgzf.c	/^void *bgzf_encode_func(void *arg) {$/;"	f
bgzf_fdopen	htslib/bgzf.h	110;"	d
bgzf_flush	bgzf.c	/^int bgzf_flush(BGZF *fp)$/;"	f
bgzf_flush_try	bgzf.c	/^int bgzf_flush_try(BGZF *fp, ssize_t size)$/;"	f
bgzf_getc	bgzf.c	/^int bgzf_getc(BGZF *fp)$/;"	f
bgzf_getline	bgzf.c	/^int bgzf_getline(BGZF *fp, int delim, kstring_t *str)$/;"	f
bgzf_gzip_compress	bgzf.c	/^static int bgzf_gzip_compress(BGZF *fp, void *_dst, size_t *dlen, const void *src, size_t slen, int level)$/;"	f	file:
bgzf_hfile	bgzf.c	/^struct hFILE *bgzf_hfile(struct BGZF *fp) {$/;"	f
bgzf_hopen	bgzf.c	/^BGZF *bgzf_hopen(hFILE *hfp, const char *mode)$/;"	f
bgzf_htell	bgzf.c	/^static off_t bgzf_htell(BGZF *fp) {$/;"	f	file:
bgzf_index_add_block	bgzf.c	/^int bgzf_index_add_block(BGZF *fp)$/;"	f
bgzf_index_build_init	bgzf.c	/^int bgzf_index_build_init(BGZF *fp)$/;"	f
bgzf_index_destroy	bgzf.c	/^void bgzf_index_destroy(BGZF *fp)$/;"	f
bgzf_index_dump	bgzf.c	/^int bgzf_index_dump(BGZF *fp, const char *bname, const char *suffix)$/;"	f
bgzf_index_dump_hfile	bgzf.c	/^int bgzf_index_dump_hfile(BGZF *fp, struct hFILE *idx, const char *name)$/;"	f
bgzf_index_load	bgzf.c	/^int bgzf_index_load(BGZF *fp, const char *bname, const char *suffix)$/;"	f
bgzf_index_load_hfile	bgzf.c	/^int bgzf_index_load_hfile(BGZF *fp, struct hFILE *idx, const char *name)$/;"	f
bgzf_is_bgzf	bgzf.c	/^int bgzf_is_bgzf(const char *fn)$/;"	f
bgzf_job	bgzf.c	/^typedef struct bgzf_job {$/;"	s	file:
bgzf_job	bgzf.c	/^} bgzf_job;$/;"	t	typeref:struct:bgzf_job	file:
bgzf_mt	bgzf.c	/^int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks)$/;"	f
bgzf_mt_eof	bgzf.c	/^static void bgzf_mt_eof(BGZF *fp) {$/;"	f	file:
bgzf_mt_read_block	bgzf.c	/^int bgzf_mt_read_block(BGZF *fp, bgzf_job *j)$/;"	f
bgzf_mt_reader	bgzf.c	/^static void *bgzf_mt_reader(void *vp) {$/;"	f	file:
bgzf_mt_seek	bgzf.c	/^static void bgzf_mt_seek(BGZF *fp) {$/;"	f	file:
bgzf_mt_writer	bgzf.c	/^static void *bgzf_mt_writer(void *vp) {$/;"	f	file:
bgzf_mtaux_t	bgzf.c	/^typedef struct bgzf_mtaux_t {$/;"	s	file:
bgzf_nul_func	bgzf.c	/^void *bgzf_nul_func(void *arg) { return arg; }$/;"	f
bgzf_open	bgzf.c	/^BGZF *bgzf_open(const char *path, const char *mode)$/;"	f
bgzf_open_ref	cram/cram_io.c	/^static BGZF *bgzf_open_ref(char *fn, char *mode, int is_md5) {$/;"	f	file:
bgzf_raw_read	bgzf.c	/^ssize_t bgzf_raw_read(BGZF *fp, void *data, size_t length)$/;"	f
bgzf_raw_write	bgzf.c	/^ssize_t bgzf_raw_write(BGZF *fp, const void *data, size_t length)$/;"	f
bgzf_read	bgzf.c	/^ssize_t bgzf_read(BGZF *fp, void *data, size_t length)$/;"	f
bgzf_read_block	bgzf.c	/^int bgzf_read_block(BGZF *fp)$/;"	f
bgzf_read_init	bgzf.c	/^static BGZF *bgzf_read_init(hFILE *hfpr)$/;"	f	file:
bgzf_seek	bgzf.c	/^int64_t bgzf_seek(BGZF* fp, int64_t pos, int where)$/;"	f
bgzf_set_cache_size	bgzf.c	/^void bgzf_set_cache_size(BGZF *fp, int cache_size)$/;"	f
bgzf_suffix	test/test_bgzf.c	/^const char *bgzf_suffix = ".gz";$/;"	v
bgzf_tell	htslib/bgzf.h	201;"	d
bgzf_thread_pool	bgzf.c	/^int bgzf_thread_pool(BGZF *fp, hts_tpool *pool, int qsize) {$/;"	f
bgzf_uncompress	bgzf.c	/^static int bgzf_uncompress(uint8_t *dst, size_t *dlen, const uint8_t *src, size_t slen) {$/;"	f	file:
bgzf_useek	bgzf.c	/^int bgzf_useek(BGZF *fp, long uoffset, int where)$/;"	f
bgzf_utell	bgzf.c	/^long bgzf_utell(BGZF *fp)$/;"	f
bgzf_write	bgzf.c	/^ssize_t bgzf_write(BGZF *fp, const void *data, size_t length)$/;"	f
bgzf_write_init	bgzf.c	/^static BGZF *bgzf_write_init(const char *mode)$/;"	f	file:
bgzf_zerr	bgzf.c	/^static const char *bgzf_zerr(int errnum, z_stream *zs)$/;"	f	file:
bgzidx1_t	bgzf.c	/^bgzidx1_t;$/;"	t	typeref:struct:__anon52	file:
bgzidx_t	htslib/bgzf.h	/^typedef struct __bgzidx_t bgzidx_t;$/;"	t	typeref:struct:__bgzidx_t
bgzip_main_usage	bgzip.c	/^static int bgzip_main_usage(void)$/;"	f	file:
bias	cram/rANS_byte.h	/^    uint32_t bias;      \/\/ Bias$/;"	m	struct:__anon56
bidx	hts.c	/^    bidx_t **bidx;$/;"	m	struct:__hts_idx_t	file:
bidx_t	hts.c	/^typedef khash_t(bin) bidx_t;$/;"	t	file:
bin	htslib/sam.h	/^    uint16_t bin;$/;"	m	struct:__anon37
binary_format	htslib/hts.h	/^    binary_format, text_format,$/;"	e	enum:htsExactFormat
bindir	Makefile	/^bindir      = $(exec_prefix)\/bin$/;"	m
bins	htslib/hts.h	/^    } bins;$/;"	m	struct:__anon14	typeref:struct:__anon14::__anon15
bins_t	hts.c	/^} bins_t;$/;"	t	typeref:struct:__anon1	file:
bit	cram/cram_structs.h	/^    int bit;$/;"	m	struct:cram_block
bit_array_clear	vcf.c	1040;"	d	file:
bit_array_set	vcf.c	1039;"	d	file:
bit_array_size	vcf.c	1038;"	d	file:
bit_array_test	vcf.c	1041;"	d	file:
bl	cram/cram_structs.h	/^    spare_bams *bl;$/;"	m	struct:cram_fd
blk	cram/cram_structs.h	/^    cram_block *blk;$/;"	m	struct:cram_tag_map
blksize	hfile.c	/^static size_t blksize(int fd)$/;"	f	file:
block	bgzf.c	/^    uint8_t *block;$/;"	m	struct:__anon51	file:
block	cram/cram_structs.h	/^    cram_block **block;$/;"	m	struct:cram_slice
block	md5.c	/^	hts_md5_u32plus block[16];$/;"	m	struct:hts_md5_context	file:
block_address	bgzf.c	/^    int64_t block_address;$/;"	m	struct:bgzf_job	file:
block_address	bgzf.c	/^    uint64_t block_address;$/;"	m	struct:bgzf_mtaux_t	file:
block_address	htslib/bgzf.h	/^    int64_t block_address, uncompressed_address;$/;"	m	struct:BGZF
block_by_id	cram/cram_structs.h	/^    cram_block **block_by_id;$/;"	m	struct:cram_slice
block_clength	htslib/bgzf.h	/^    int block_length, block_clength, block_offset;$/;"	m	struct:BGZF
block_content_ids	cram/cram_structs.h	/^    int32_t *block_content_ids;$/;"	m	struct:cram_block_slice_hdr
block_length	htslib/bgzf.h	/^    int block_length, block_clength, block_offset;$/;"	m	struct:BGZF
block_offset	htslib/bgzf.h	/^    int block_length, block_clength, block_offset;$/;"	m	struct:BGZF
block_size	vcf_sweep.c	/^    int block_size;         \/\/ the size of uncompressed data to hold in memory$/;"	m	struct:_bcf_sweep_t	file:
body	md5.c	/^static const void *body(hts_md5_context *ctx, const void *data, unsigned long size)$/;"	f	file:
bsum	errmod.c	/^    double fsum[16], bsum[16];$/;"	m	struct:__anon119	file:
bucket	hfile_s3.c	/^    char *bucket;$/;"	m	struct:__anon53	file:
buf	sam.c	/^    lbnode_t **buf;$/;"	m	struct:__anon5	file:
buf	vcf.c	/^    uint8_t *buf;$/;"	m	struct:__anon50	file:
buffer	hfile_libcurl.c	/^    } buffer;$/;"	m	struct:__anon100	typeref:struct:__anon100::__anon101	file:
buffer	htslib/hfile.h	/^    char *buffer, *begin, *end, *limit;$/;"	m	struct:hFILE
buffer	htslib/synced_bcf_reader.h	/^    bcf1_t **buffer;                \/\/ cached VCF records. First is the current record synced across the reader$/;"	m	struct:__anon29
buffer	md5.c	/^	unsigned char buffer[64];$/;"	m	struct:hts_md5_context	file:
bw	htslib/hts.h	/^    int bw;$/;"	m	struct:probaln_par_t
byte	cram/cram_structs.h	/^    size_t byte;$/;"	m	struct:cram_block
byte_array_len	cram/cram_codecs.h	/^	cram_byte_array_len_decoder  byte_array_len;$/;"	m	union:cram_codec::__anon78
byte_array_stop	cram/cram_codecs.h	/^	cram_byte_array_stop_decoder byte_array_stop;$/;"	m	union:cram_codec::__anon78
bzip2_cnt	cram/cram_structs.h	/^    int bzip2_cnt;$/;"	m	struct:__anon80
bzip2_extra	cram/cram_structs.h	/^    double bzip2_extra;$/;"	m	struct:__anon80
c	cram/cram_decode.c	/^    cram_container *c;$/;"	m	struct:__anon95	file:
c	cram/cram_io.c	/^    cram_container *c;$/;"	m	struct:__anon67	file:
c	errmod.c	/^    uint32_t c[16];$/;"	m	struct:__anon119	file:
c	md5.c	/^	hts_md5_u32plus a, b, c, d;$/;"	m	struct:hts_md5_context	file:
cache	htslib/bgzf.h	/^    void *cache; \/\/ a pointer to a hash table$/;"	m	struct:BGZF
cache_block	bgzf.c	/^static void cache_block(BGZF *fp, int size) {}$/;"	f	file:
cache_block	bgzf.c	/^static void cache_block(BGZF *fp, int size)$/;"	f	file:
cache_size	htslib/bgzf.h	/^    int cache_size;$/;"	m	struct:BGZF
cache_t	bgzf.c	/^} cache_t;$/;"	t	typeref:struct:__anon51	file:
caddr	bgzf.c	/^    uint64_t caddr;  \/\/ offset w.r.t. compressed data$/;"	m	struct:__anon52	file:
cal_coef	errmod.c	/^static void cal_coef(errmod_t *em, double depcorr, double eta)$/;"	f	file:
call_aux_t	errmod.c	/^} call_aux_t;$/;"	t	typeref:struct:__anon119	file:
callback	hfile_libcurl.c	/^    hts_httphdr_callback callback;   \/\/ Callback to get more headers$/;"	m	struct:__anon99	file:
callback_data	hfile_libcurl.c	/^    void *callback_data;             \/\/ Data to pass to callback$/;"	m	struct:__anon99	file:
can_seek	hfile_libcurl.c	/^    unsigned can_seek : 1;  \/\/ Can (attempt to) seek on this handle$/;"	m	struct:__anon100	file:
category	htslib/hts.h	/^    enum htsFormatCategory category;$/;"	m	struct:htsFormat	typeref:enum:htsFormat::htsFormatCategory
category_maximum	htslib/hts.h	/^    category_maximum = 32767$/;"	e	enum:htsFormatCategory
cb_backend	hfile.c	/^static const struct hFILE_backend cb_backend =$/;"	v	typeref:struct:hFILE_backend	file:
cb_close	hfile.c	/^static int cb_close(hFILE* fpv)$/;"	f	file:
cb_data	htslib/hfile.h	/^	void* cb_data;$/;"	m	struct:hFILE_callback_ops
cb_flush	hfile.c	/^static int cb_flush(hFILE* fpv)$/;"	f	file:
cb_read	hfile.c	/^static ssize_t cb_read(hFILE *fpv, void *buffer, size_t nbytes)$/;"	f	file:
cb_seek	hfile.c	/^static off_t cb_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
cb_write	hfile.c	/^static ssize_t cb_write(hFILE* fpv, const void* buffer, size_t nbytes)$/;"	f	file:
cd	htslib/sam.h	/^    bam_pileup_cd cd; \/\/ generic per-struct data, owned by caller.$/;"	m	struct:__anon40
cd	sam.c	/^    bam_pileup_cd cd;$/;"	m	struct:__linkbuf_t	file:
charp	bcf_sr_sort.h	/^    char **charp;$/;"	m	struct:__anon118
check	hts.c	1659;"	d	file:
check	hts.c	1695;"	d	file:
check	hts.c	1723;"	d	file:
check	hts.c	1745;"	d	file:
check	test/fieldarith.c	/^void check(const bam1_t *aln, const char *testname, const char *tag, int value)$/;"	f
check_bam_aux_get	test/sam.c	/^uint8_t *check_bam_aux_get(const bam1_t *aln, const char *tag, char type)$/;"	f
check_dir	test/test-logging.pl	/^sub check_dir$/;"	s
check_enum1	test/sam.c	/^static void check_enum1(void)$/;"	f	file:
check_file	test/test-logging.pl	/^sub check_file$/;"	s
check_format_values	test/test-vcf-api.c	/^void check_format_values(const char *fname)$/;"	f
check_header	bgzf.c	/^static int check_header(const uint8_t *header)$/;"	f	file:
check_int_B_array	test/sam.c	/^static void check_int_B_array(bam1_t *aln, char *tag,$/;"	f	file:
check_log_message	test/test-logging.pl	/^sub check_log_message$/;"	s
check_offset	test/hfile.c	/^void check_offset(hFILE *f, off_t off, const char *message)$/;"	f
check_outputs	test/test-bcf-sr.pl	/^sub check_outputs$/;"	s
chr	bcf_sr_sort.h	/^    const char *chr;$/;"	m	struct:__anon118
cigar	cram/cram_structs.h	/^    int32_t cigar;        \/\/ idx to s->cigar$/;"	m	struct:cram_record
cigar	cram/cram_structs.h	/^    uint32_t  *cigar;$/;"	m	struct:cram_slice
cigar_alloc	cram/cram_structs.h	/^    uint32_t   cigar_alloc;$/;"	m	struct:cram_slice
cigar_iref2iseq_next	sam.c	/^static inline int cigar_iref2iseq_next(uint32_t **cigar, uint32_t *cigar_max, int *icig, int *iseq, int *iref)$/;"	f	file:
cigar_iref2iseq_set	sam.c	/^static inline int cigar_iref2iseq_set(uint32_t **cigar, uint32_t *cigar_max, int *icig, int *iseq, int *iref)$/;"	f	file:
cigar_op	cram/cram_samtools.h	/^enum cigar_op {$/;"	g
cigar_tab	htslib/sam.h	/^    int8_t *cigar_tab;$/;"	m	struct:__anon36
cleanup	test/test_bgzf.c	/^static void cleanup(Files *f, int retval) {$/;"	f	file:
close	htslib/hfile.h	/^	int (*close)(void* cb_data);$/;"	m	struct:hFILE_callback_ops
close_plugin	plugin.c	/^void close_plugin(void *plugin)$/;"	f
closing	hfile_libcurl.c	/^    unsigned closing : 1;   \/\/ informs callback that hclose() has been invoked$/;"	m	struct:__anon100	file:
cmd	test/test-bcf-sr.pl	/^sub cmd$/;"	s
cmd	test/test.pl	/^sub cmd$/;"	s
cmp_nonblank	hts.c	/^cmp_nonblank(const char *key, const unsigned char *u, const unsigned char *ulim)$/;"	f	file:
cmp_prefix	hfile.c	/^static int cmp_prefix(const char *key, const char *s)$/;"	f	file:
cmpl_freq	cram/rANS_byte.h	/^    uint16_t cmpl_freq; \/\/ Complement of frequency: (1 << scale_bits) - freq$/;"	m	struct:__anon56
cmpstringp	bcf_sr_sort.c	/^static int cmpstringp(const void *p1, const void *p2)$/;"	f	file:
cnt	bcf_sr_sort.h	/^    int cnt;                \/\/ number of readers in this group$/;"	m	struct:__anon117
cnt	bcf_sr_sort.h	/^    int mcnt, *cnt;         \/\/ number of VCF covered by a varset$/;"	m	struct:__anon118
cnt	sam.c	/^    int cnt, n, max;$/;"	m	struct:__anon5	file:
code	cram/cram_codecs.h	/^    int32_t code;$/;"	m	struct:__anon68
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon82
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon83
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon84
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon85
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon86
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon87
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon88
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon89
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon90
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon91
code	cram/cram_structs.h	/^	    int code;$/;"	m	struct:cram_feature::__anon81::__anon92
code_sort	cram/cram_codecs.c	/^static int code_sort(const void *vp1, const void *vp2) {$/;"	f	file:
codec	cram/cram_codecs.h	/^    enum cram_encoding codec;$/;"	m	struct:cram_codec	typeref:enum:cram_codec::cram_encoding
codec	cram/cram_structs.h	/^    struct cram_codec *codec;$/;"	m	struct:cram_map	typeref:struct:cram_map::cram_codec
codec	cram/cram_structs.h	/^    struct cram_codec *codec;$/;"	m	struct:cram_tag_map	typeref:struct:cram_tag_map::cram_codec
codecs	cram/cram_structs.h	/^    struct cram_codec *codecs[DS_END];$/;"	m	struct:cram_block_compression_hdr	typeref:struct:cram_block_compression_hdr::cram_codec
codes	cram/cram_codecs.h	/^    cram_huffman_code *codes;$/;"	m	struct:__anon69
codes	cram/cram_codecs.h	/^    cram_huffman_code *codes;$/;"	m	struct:__anon70
collapse	htslib/synced_bcf_reader.h	/^    int collapse;           \/\/ Do not access directly, use bcf_sr_set_pairing_logic() instead$/;"	m	struct:__anon31
command	bgzf.c	/^    enum mtaux_cmd command;$/;"	m	struct:bgzf_mtaux_t	typeref:enum:bgzf_mtaux_t::mtaux_cmd	file:
command_c	bgzf.c	/^    pthread_cond_t command_c;$/;"	m	struct:bgzf_mtaux_t	file:
command_m	bgzf.c	/^    pthread_mutex_t command_m; \/\/ Set whenever fp is being updated$/;"	m	struct:bgzf_mtaux_t	file:
comp_data	bgzf.c	/^    unsigned char comp_data[BGZF_MAX_BLOCK_SIZE];$/;"	m	struct:bgzf_job	file:
comp_hdr	cram/cram_structs.h	/^    cram_block_compression_hdr *comp_hdr;$/;"	m	struct:cram_container
comp_hdr_block	cram/cram_structs.h	/^    cram_block *comp_hdr_block;$/;"	m	struct:cram_container
comp_len	bgzf.c	/^    size_t comp_len;$/;"	m	struct:bgzf_job	file:
comp_size	cram/cram_structs.h	/^    int32_t  comp_size;$/;"	m	struct:cram_block
compare_buffers	test/test_bgzf.c	/^static int compare_buffers(const unsigned char *b1, const unsigned char *b2,$/;"	f	file:
compare_sam	test/cross_validate.sh	/^compare_sam() {$/;"	f
compress_binning	hts.c	/^static void compress_binning(hts_idx_t *idx, int i)$/;"	f	file:
compress_level	htslib/bgzf.h	/^    signed compress_level:9;$/;"	m	struct:BGZF
compressed_block	htslib/bgzf.h	/^    void *uncompressed_block, *compressed_block;$/;"	m	struct:BGZF
compression	htslib/hts.h	/^    enum htsCompression compression;$/;"	m	struct:htsFormat	typeref:enum:htsFormat::htsCompression
compression_level	htslib/hts.h	/^    short compression_level;  \/\/ currently unused$/;"	m	struct:htsFormat
compression_maximum	htslib/hts.h	/^    compression_maximum = 32767$/;"	e	enum:htsCompression
conf	htslib/tbx.h	/^    tbx_conf_t conf;$/;"	m	struct:__anon35
confirm_overwrite	bgzip.c	/^static int confirm_overwrite(const char *fn)$/;"	f	file:
content_id	cram/cram_codecs.h	/^    int32_t content_id;$/;"	m	struct:__anon74
content_id	cram/cram_codecs.h	/^    int32_t content_id;$/;"	m	struct:__anon76
content_id	cram/cram_structs.h	/^    int32_t  content_id;$/;"	m	struct:cram_block
content_type	cram/cram_structs.h	/^    enum cram_content_type  content_type;$/;"	m	struct:cram_block	typeref:enum:cram_block::cram_content_type
content_type	cram/cram_structs.h	/^    enum cram_content_type content_type;$/;"	m	struct:cram_block_slice_hdr	typeref:enum:cram_block_slice_hdr::cram_content_type
copy_auth_headers	hfile_s3.c	/^static int copy_auth_headers(s3_auth_data *ad, char ***hdrs) {$/;"	f	file:
copy_check_alignment	test/sam.c	/^static void copy_check_alignment(const char *infname, const char *informat,$/;"	f	file:
core	htslib/sam.h	/^    bam1_core_t core;$/;"	m	struct:__anon38
count	cram/cram_structs.h	/^    int count;             \/\/ how many cram_fd sharing this refs struct$/;"	m	struct:__anon93
count	cram/cram_structs.h	/^    int64_t count;	   \/\/ for shared references so we know to dealloc seq$/;"	m	struct:ref_entry
crai	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
cram	hts_internal.h	/^    struct cram_fd *cram;$/;"	m	struct:hts_cram_idx_t	typeref:struct:hts_cram_idx_t::cram_fd
cram	htslib/hts.h	/^        struct cram_fd *cram;$/;"	m	union:__anon9::__anon10	typeref:struct:__anon9::__anon10::cram_fd
cram	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
cram_DS_ID	cram/cram_structs.h	/^enum cram_DS_ID {$/;"	g
cram_add_base	cram/cram_encode.c	/^static int cram_add_base(cram_fd *fd, cram_container *c,$/;"	f	file:
cram_add_bases	cram/cram_encode.c	/^static int cram_add_bases(cram_fd *fd, cram_container *c,$/;"	f	file:
cram_add_deletion	cram/cram_encode.c	/^static int cram_add_deletion(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_feature	cram/cram_encode.c	/^static int cram_add_feature(cram_container *c, cram_slice *s,$/;"	f	file:
cram_add_hardclip	cram/cram_encode.c	/^static int cram_add_hardclip(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_insertion	cram/cram_encode.c	/^static int cram_add_insertion(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_pad	cram/cram_encode.c	/^static int cram_add_pad(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_quality	cram/cram_encode.c	/^static int cram_add_quality(cram_fd *fd, cram_container *c,$/;"	f	file:
cram_add_skip	cram/cram_encode.c	/^static int cram_add_skip(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_softclip	cram/cram_encode.c	/^static int cram_add_softclip(cram_container *c, cram_slice *s, cram_record *r,$/;"	f	file:
cram_add_substitution	cram/cram_encode.c	/^static int cram_add_substitution(cram_fd *fd, cram_container *c,$/;"	f	file:
cram_aux	cram/cram_structs.h	461;"	d
cram_beta_decode_char	cram/cram_codecs.c	/^int cram_beta_decode_char(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {$/;"	f
cram_beta_decode_free	cram/cram_codecs.c	/^void cram_beta_decode_free(cram_codec *c) {$/;"	f
cram_beta_decode_init	cram/cram_codecs.c	/^cram_codec *cram_beta_decode_init(char *data, int size,$/;"	f
cram_beta_decode_int	cram/cram_codecs.c	/^int cram_beta_decode_int(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {$/;"	f
cram_beta_decoder	cram/cram_codecs.h	/^} cram_beta_decoder;$/;"	t	typeref:struct:__anon71
cram_beta_encode_char	cram/cram_codecs.c	/^int cram_beta_encode_char(cram_slice *slice, cram_codec *c,$/;"	f
cram_beta_encode_free	cram/cram_codecs.c	/^void cram_beta_encode_free(cram_codec *c) {$/;"	f
cram_beta_encode_init	cram/cram_codecs.c	/^cram_codec *cram_beta_encode_init(cram_stats *st,$/;"	f
cram_beta_encode_int	cram/cram_codecs.c	/^int cram_beta_encode_int(cram_slice *slice, cram_codec *c,$/;"	f
cram_beta_encode_store	cram/cram_codecs.c	/^int cram_beta_encode_store(cram_codec *c, cram_block *b,$/;"	f
cram_block	cram/cram_structs.h	/^typedef struct cram_block {$/;"	s
cram_block	cram/cram_structs.h	/^} cram_block;$/;"	t	typeref:struct:cram_block
cram_block	htslib/cram.h	/^typedef struct cram_block cram_block;$/;"	t	typeref:struct:cram_block
cram_block_append	cram/cram_external.c	/^int cram_block_append(cram_block *b, void *data, int size) {$/;"	f
cram_block_compression_hdr	cram/cram_structs.h	/^typedef struct cram_block_compression_hdr {$/;"	s
cram_block_compression_hdr	cram/cram_structs.h	/^} cram_block_compression_hdr;$/;"	t	typeref:struct:cram_block_compression_hdr
cram_block_compression_hdr	htslib/cram.h	/^typedef struct cram_block_compression_hdr cram_block_compression_hdr;$/;"	t	typeref:struct:cram_block_compression_hdr
cram_block_compression_hdr_decoder2encoder	cram/cram_external.c	/^int cram_block_compression_hdr_decoder2encoder(cram_fd *fd,$/;"	f
cram_block_compression_hdr_set_DS	cram/cram_external.c	/^static int cram_block_compression_hdr_set_DS(cram_block_compression_hdr *ch,$/;"	f	file:
cram_block_compression_hdr_set_rg	cram/cram_external.c	/^int cram_block_compression_hdr_set_rg(cram_block_compression_hdr *ch, int new_rg) {$/;"	f
cram_block_get_comp_size	cram/cram_external.c	/^int32_t cram_block_get_comp_size(cram_block *b)   { return b->comp_size; }$/;"	f
cram_block_get_content_id	cram/cram_external.c	/^int32_t cram_block_get_content_id(cram_block *b)  { return b->content_id; }$/;"	f
cram_block_get_content_type	cram/cram_external.c	/^enum cram_content_type cram_block_get_content_type(cram_block *b) {$/;"	f
cram_block_get_crc32	cram/cram_external.c	/^int32_t cram_block_get_crc32(cram_block *b)       { return b->crc32; }$/;"	f
cram_block_get_data	cram/cram_external.c	/^void *  cram_block_get_data(cram_block *b)        { return BLOCK_DATA(b); }$/;"	f
cram_block_get_offset	cram/cram_external.c	/^size_t cram_block_get_offset(cram_block *b) { return BLOCK_SIZE(b); }$/;"	f
cram_block_get_size	cram/cram_external.c	/^int32_t cram_block_get_size(cram_block *b)        { return BLOCK_SIZE(b); }$/;"	f
cram_block_get_uncomp_size	cram/cram_external.c	/^int32_t cram_block_get_uncomp_size(cram_block *b) { return b->uncomp_size; }$/;"	f
cram_block_method	cram/cram_structs.h	/^enum cram_block_method {$/;"	g
cram_block_method	htslib/cram.h	/^enum cram_block_method {$/;"	g
cram_block_method2str	cram/cram_io.c	/^char *cram_block_method2str(enum cram_block_method m) {$/;"	f
cram_block_set_comp_size	cram/cram_external.c	/^void cram_block_set_comp_size(cram_block *b, int32_t size) { b->comp_size = size; }$/;"	f
cram_block_set_content_id	cram/cram_external.c	/^void cram_block_set_content_id(cram_block *b, int32_t id) { b->content_id = id; }$/;"	f
cram_block_set_crc32	cram/cram_external.c	/^void cram_block_set_crc32(cram_block *b, int32_t crc) { b->crc32 = crc; }$/;"	f
cram_block_set_data	cram/cram_external.c	/^void cram_block_set_data(cram_block *b, void *data) { BLOCK_DATA(b) = data; }$/;"	f
cram_block_set_offset	cram/cram_external.c	/^void cram_block_set_offset(cram_block *b, size_t offset) { BLOCK_SIZE(b) = offset; }$/;"	f
cram_block_set_size	cram/cram_external.c	/^void cram_block_set_size(cram_block *b, int32_t size) { BLOCK_SIZE(b) = size; }$/;"	f
cram_block_set_uncomp_size	cram/cram_external.c	/^void cram_block_set_uncomp_size(cram_block *b, int32_t size) { b->uncomp_size = size; }$/;"	f
cram_block_size	cram/cram_io.c	/^uint32_t cram_block_size(cram_block *b) {$/;"	f
cram_block_slice_hdr	cram/cram_structs.h	/^typedef struct cram_block_slice_hdr {$/;"	s
cram_block_slice_hdr	cram/cram_structs.h	/^} cram_block_slice_hdr;$/;"	t	typeref:struct:cram_block_slice_hdr
cram_block_slice_hdr	htslib/cram.h	/^typedef struct cram_block_slice_hdr cram_block_slice_hdr;$/;"	t	typeref:struct:cram_block_slice_hdr
cram_block_update_size	cram/cram_external.c	/^void cram_block_update_size(cram_block *b) { BLOCK_UPLEN(b); }$/;"	f
cram_byte_array_len_decode	cram/cram_codecs.c	/^int cram_byte_array_len_decode(cram_slice *slice, cram_codec *c,$/;"	f
cram_byte_array_len_decode_free	cram/cram_codecs.c	/^void cram_byte_array_len_decode_free(cram_codec *c) {$/;"	f
cram_byte_array_len_decode_init	cram/cram_codecs.c	/^cram_codec *cram_byte_array_len_decode_init(char *data, int size,$/;"	f
cram_byte_array_len_decode_reset	cram/cram_codecs.c	/^static void cram_byte_array_len_decode_reset(cram_codec *c) {$/;"	f	file:
cram_byte_array_len_decoder	cram/cram_codecs.h	/^} cram_byte_array_len_decoder;$/;"	t	typeref:struct:__anon75
cram_byte_array_len_encode	cram/cram_codecs.c	/^int cram_byte_array_len_encode(cram_slice *slice, cram_codec *c,$/;"	f
cram_byte_array_len_encode_free	cram/cram_codecs.c	/^void cram_byte_array_len_encode_free(cram_codec *c) {$/;"	f
cram_byte_array_len_encode_init	cram/cram_codecs.c	/^cram_codec *cram_byte_array_len_encode_init(cram_stats *st,$/;"	f
cram_byte_array_len_encode_store	cram/cram_codecs.c	/^int cram_byte_array_len_encode_store(cram_codec *c, cram_block *b,$/;"	f
cram_byte_array_len_encoder	cram/cram_codecs.h	/^} cram_byte_array_len_encoder;$/;"	t	typeref:struct:__anon77
cram_byte_array_stop_decode_block	cram/cram_codecs.c	/^int cram_byte_array_stop_decode_block(cram_slice *slice, cram_codec *c,$/;"	f
cram_byte_array_stop_decode_char	cram/cram_codecs.c	/^static int cram_byte_array_stop_decode_char(cram_slice *slice, cram_codec *c,$/;"	f	file:
cram_byte_array_stop_decode_free	cram/cram_codecs.c	/^void cram_byte_array_stop_decode_free(cram_codec *c) {$/;"	f
cram_byte_array_stop_decode_init	cram/cram_codecs.c	/^cram_codec *cram_byte_array_stop_decode_init(char *data, int size,$/;"	f
cram_byte_array_stop_decode_reset	cram/cram_codecs.c	/^static void cram_byte_array_stop_decode_reset(cram_codec *c) {$/;"	f	file:
cram_byte_array_stop_decoder	cram/cram_codecs.h	/^} cram_byte_array_stop_decoder;$/;"	t	typeref:struct:__anon76
cram_byte_array_stop_encode	cram/cram_codecs.c	/^int cram_byte_array_stop_encode(cram_slice *slice, cram_codec *c,$/;"	f
cram_byte_array_stop_encode_free	cram/cram_codecs.c	/^void cram_byte_array_stop_encode_free(cram_codec *c) {$/;"	f
cram_byte_array_stop_encode_init	cram/cram_codecs.c	/^cram_codec *cram_byte_array_stop_encode_init(cram_stats *st,$/;"	f
cram_byte_array_stop_encode_store	cram/cram_codecs.c	/^int cram_byte_array_stop_encode_store(cram_codec *c, cram_block *b,$/;"	f
cram_check_EOF	cram/cram_io.c	/^int cram_check_EOF(cram_fd *fd)$/;"	f
cram_cigar	cram/cram_structs.h	466;"	d
cram_close	cram/cram_io.c	/^int cram_close(cram_fd *fd) {$/;"	f
cram_codec	cram/cram_codecs.h	/^typedef struct cram_codec {$/;"	s
cram_codec	cram/cram_codecs.h	/^} cram_codec;$/;"	t	typeref:struct:cram_codec
cram_codec_decoder2encoder	cram/cram_codecs.c	/^int cram_codec_decoder2encoder(cram_fd *fd, cram_codec *c) {$/;"	f
cram_codec_to_id	cram/cram_codecs.c	/^int cram_codec_to_id(cram_codec *c, int *id2) {$/;"	f
cram_compress_block	cram/cram_io.c	/^int cram_compress_block(cram_fd *fd, cram_block *b, cram_metrics *metrics,$/;"	f
cram_compress_by_method	cram/cram_io.c	/^static char *cram_compress_by_method(char *in, size_t in_size,$/;"	f	file:
cram_compress_slice	cram/cram_encode.c	/^static int cram_compress_slice(cram_fd *fd, cram_container *c, cram_slice *s) {$/;"	f	file:
cram_container	cram/cram_structs.h	/^typedef struct cram_container {$/;"	s
cram_container	cram/cram_structs.h	/^} cram_container;$/;"	t	typeref:struct:cram_container
cram_container	htslib/cram.h	/^typedef struct cram_container cram_container;$/;"	t	typeref:struct:cram_container
cram_container_get_landmarks	cram/cram_external.c	/^int32_t *cram_container_get_landmarks(cram_container *c, int32_t *num_landmarks) {$/;"	f
cram_container_get_length	cram/cram_external.c	/^int32_t cram_container_get_length(cram_container *c) {$/;"	f
cram_container_get_num_blocks	cram/cram_external.c	/^int32_t cram_container_get_num_blocks(cram_container *c) {$/;"	f
cram_container_is_empty	cram/cram_external.c	/^int cram_container_is_empty(cram_fd *fd) {$/;"	f
cram_container_set_landmarks	cram/cram_external.c	/^void cram_container_set_landmarks(cram_container *c, int32_t num_landmarks,$/;"	f
cram_container_set_length	cram/cram_external.c	/^void cram_container_set_length(cram_container *c, int32_t length) {$/;"	f
cram_container_set_num_blocks	cram/cram_external.c	/^void cram_container_set_num_blocks(cram_container *c, int32_t num_blocks) {$/;"	f
cram_container_size	cram/cram_io.c	/^int cram_container_size(cram_container *c) {$/;"	f
cram_content_type	cram/cram_structs.h	/^enum cram_content_type {$/;"	g
cram_content_type	htslib/cram.h	/^enum cram_content_type {$/;"	g
cram_content_type2str	cram/cram_io.c	/^char *cram_content_type2str(enum cram_content_type t) {$/;"	f
cram_copy_slice	cram/cram_external.c	/^int cram_copy_slice(cram_fd *in, cram_fd *out, int32_t num_slice) {$/;"	f
cram_decode_TD	cram/cram_decode.c	/^int cram_decode_TD(char *cp, const char *endp, cram_block_compression_hdr *h) {$/;"	f
cram_decode_aux	cram/cram_decode.c	/^static int cram_decode_aux(cram_container *c, cram_slice *s,$/;"	f	file:
cram_decode_aux_1_0	cram/cram_decode.c	/^static int cram_decode_aux_1_0(cram_container *c, cram_slice *s,$/;"	f	file:
cram_decode_compression_header	cram/cram_decode.c	/^cram_block_compression_hdr *cram_decode_compression_header(cram_fd *fd,$/;"	f
cram_decode_estimate_sizes	cram/cram_decode.c	/^void cram_decode_estimate_sizes(cram_block_compression_hdr *hdr, cram_slice *s,$/;"	f
cram_decode_job	cram/cram_decode.c	/^} cram_decode_job;$/;"	t	typeref:struct:__anon95	file:
cram_decode_seq	cram/cram_decode.c	/^static int cram_decode_seq(cram_fd *fd, cram_container *c, cram_slice *s,$/;"	f	file:
cram_decode_slice	cram/cram_decode.c	/^int cram_decode_slice(cram_fd *fd, cram_container *c, cram_slice *s,$/;"	f
cram_decode_slice_header	cram/cram_decode.c	/^cram_block_slice_hdr *cram_decode_slice_header(cram_fd *fd, cram_block *b) {$/;"	f
cram_decode_slice_mt	cram/cram_decode.c	/^int cram_decode_slice_mt(cram_fd *fd, cram_container *c, cram_slice *s,$/;"	f
cram_decode_slice_thread	cram/cram_decode.c	/^void *cram_decode_slice_thread(void *arg) {$/;"	f
cram_decode_slice_xref	cram/cram_decode.c	/^static int cram_decode_slice_xref(cram_slice *s, int required_fields) {$/;"	f	file:
cram_decoder_init	cram/cram_codecs.c	/^cram_codec *cram_decoder_init(enum cram_encoding codec,$/;"	f
cram_dependent_data_series	cram/cram_decode.c	/^int cram_dependent_data_series(cram_fd *fd,$/;"	f
cram_dopen	cram/cram_io.c	/^cram_fd *cram_dopen(hFILE *fp, const char *filename, const char *mode) {$/;"	f
cram_ds_unique	cram/cram_decode.c	/^static int cram_ds_unique(cram_block_compression_hdr *hdr, cram_codec *c,$/;"	f	file:
cram_encode_aux	cram/cram_encode.c	/^static char *cram_encode_aux(cram_fd *fd, bam_seq_t *b, cram_container *c,$/;"	f	file:
cram_encode_aux_1_0	cram/cram_encode.c	/^static char *cram_encode_aux_1_0(cram_fd *fd, bam_seq_t *b, cram_container *c,$/;"	f	file:
cram_encode_compression_header	cram/cram_encode.c	/^cram_block *cram_encode_compression_header(cram_fd *fd, cram_container *c,$/;"	f
cram_encode_container	cram/cram_encode.c	/^int cram_encode_container(cram_fd *fd, cram_container *c) {$/;"	f
cram_encode_slice	cram/cram_encode.c	/^static int cram_encode_slice(cram_fd *fd, cram_container *c,$/;"	f	file:
cram_encode_slice_header	cram/cram_encode.c	/^cram_block *cram_encode_slice_header(cram_fd *fd, cram_slice *s) {$/;"	f
cram_encode_slice_read	cram/cram_encode.c	/^static int cram_encode_slice_read(cram_fd *fd,$/;"	f	file:
cram_encoder_init	cram/cram_codecs.c	/^cram_codec *cram_encoder_init(enum cram_encoding codec,$/;"	f
cram_encoding	cram/cram_structs.h	/^enum cram_encoding {$/;"	g
cram_encoding2str	cram/cram_codecs.c	/^const char *cram_encoding2str(enum cram_encoding t) {$/;"	f
cram_eof	cram/cram_io.c	/^int cram_eof(cram_fd *fd) {$/;"	f
cram_external_decode_block	cram/cram_codecs.c	/^static int cram_external_decode_block(cram_slice *slice, cram_codec *c,$/;"	f	file:
cram_external_decode_char	cram/cram_codecs.c	/^int cram_external_decode_char(cram_slice *slice, cram_codec *c,$/;"	f
cram_external_decode_free	cram/cram_codecs.c	/^void cram_external_decode_free(cram_codec *c) {$/;"	f
cram_external_decode_init	cram/cram_codecs.c	/^cram_codec *cram_external_decode_init(char *data, int size,$/;"	f
cram_external_decode_int	cram/cram_codecs.c	/^int cram_external_decode_int(cram_slice *slice, cram_codec *c,$/;"	f
cram_external_decode_reset	cram/cram_codecs.c	/^static void cram_external_decode_reset(cram_codec *c) {$/;"	f	file:
cram_external_decoder	cram/cram_codecs.h	/^} cram_external_decoder;$/;"	t	typeref:struct:__anon74
cram_external_encode_char	cram/cram_codecs.c	/^int cram_external_encode_char(cram_slice *slice, cram_codec *c,$/;"	f
cram_external_encode_free	cram/cram_codecs.c	/^void cram_external_encode_free(cram_codec *c) {$/;"	f
cram_external_encode_init	cram/cram_codecs.c	/^cram_codec *cram_external_encode_init(cram_stats *st,$/;"	f
cram_external_encode_int	cram/cram_codecs.c	/^int cram_external_encode_int(cram_slice *slice, cram_codec *c,$/;"	f
cram_external_encode_store	cram/cram_codecs.c	/^int cram_external_encode_store(cram_codec *c, cram_block *b, char *prefix,$/;"	f
cram_external_type	cram/cram_structs.h	/^enum cram_external_type {$/;"	g
cram_extract_block	cram/cram_codecs.c	/^static char *cram_extract_block(cram_block *b, int size) {$/;"	f	file:
cram_fd	cram/cram_structs.h	/^typedef struct cram_fd {$/;"	s
cram_fd	cram/cram_structs.h	/^} cram_fd;$/;"	t	typeref:struct:cram_fd
cram_fd	htslib/cram.h	/^typedef struct cram_fd cram_fd;$/;"	t	typeref:struct:cram_fd
cram_fd_get_fp	cram/cram_external.c	/^hFILE *cram_fd_get_fp(cram_fd *fd) { return fd->fp; }$/;"	f
cram_fd_get_header	cram/cram_external.c	/^SAM_hdr *cram_fd_get_header(cram_fd *fd) { return fd->header; }$/;"	f
cram_fd_get_version	cram/cram_external.c	/^int cram_fd_get_version(cram_fd *fd) { return fd->version; }$/;"	f
cram_fd_set_fp	cram/cram_external.c	/^void cram_fd_set_fp(cram_fd *fd, hFILE *fp) { fd->fp = fp; }$/;"	f
cram_fd_set_header	cram/cram_external.c	/^void cram_fd_set_header(cram_fd *fd, SAM_hdr *hdr) { fd->header = hdr; }$/;"	f
cram_fd_set_version	cram/cram_external.c	/^void cram_fd_set_version(cram_fd *fd, int vers) { fd->version = vers; }$/;"	f
cram_feature	cram/cram_structs.h	/^typedef struct cram_feature {$/;"	s
cram_feature	cram/cram_structs.h	/^} cram_feature;$/;"	t	typeref:struct:cram_feature
cram_fields	cram/cram_structs.h	/^enum cram_fields {$/;"	g
cram_file_def	cram/cram_structs.h	/^typedef struct cram_file_def {$/;"	s
cram_file_def	cram/cram_structs.h	/^} cram_file_def;$/;"	t	typeref:struct:cram_file_def
cram_file_def	htslib/cram.h	/^typedef struct cram_file_def cram_file_def;$/;"	t	typeref:struct:cram_file_def
cram_flag_swap	cram/cram_structs.h	/^    unsigned int cram_flag_swap[0x1000];\/\/ bam -> cram flags$/;"	m	struct:cram_fd
cram_flags	cram/cram_structs.h	/^    int32_t cram_flags;   \/\/ CF$/;"	m	struct:cram_record
cram_flush	cram/cram_io.c	/^int cram_flush(cram_fd *fd) {$/;"	f
cram_flush_container	cram/cram_io.c	/^int cram_flush_container(cram_fd *fd, cram_container *c) {$/;"	f
cram_flush_container2	cram/cram_io.c	/^static int cram_flush_container2(cram_fd *fd, cram_container *c) {$/;"	f	file:
cram_flush_container_mt	cram/cram_io.c	/^int cram_flush_container_mt(cram_fd *fd, cram_container *c) {$/;"	f
cram_flush_result	cram/cram_io.c	/^static int cram_flush_result(cram_fd *fd) {$/;"	f	file:
cram_flush_thread	cram/cram_io.c	/^void *cram_flush_thread(void *arg) {$/;"	f
cram_free_block	cram/cram_io.c	/^void cram_free_block(cram_block *b) {$/;"	f
cram_free_compression_header	cram/cram_io.c	/^void cram_free_compression_header(cram_block_compression_hdr *hdr) {$/;"	f
cram_free_container	cram/cram_io.c	/^void cram_free_container(cram_container *c) {$/;"	f
cram_free_file_def	cram/cram_io.c	/^void cram_free_file_def(cram_file_def *def) {$/;"	f
cram_free_slice	cram/cram_io.c	/^void cram_free_slice(cram_slice *s) {$/;"	f
cram_free_slice_header	cram/cram_io.c	/^void cram_free_slice_header(cram_block_slice_hdr *hdr) {$/;"	f
cram_gamma_decode	cram/cram_codecs.c	/^int cram_gamma_decode(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {$/;"	f
cram_gamma_decode_free	cram/cram_codecs.c	/^void cram_gamma_decode_free(cram_codec *c) {$/;"	f
cram_gamma_decode_init	cram/cram_codecs.c	/^cram_codec *cram_gamma_decode_init(char *data, int size,$/;"	f
cram_gamma_decoder	cram/cram_codecs.h	/^} cram_gamma_decoder;$/;"	t	typeref:struct:__anon72
cram_get_bam_seq	cram/cram_decode.c	/^int cram_get_bam_seq(cram_fd *fd, bam_seq_t **bam) {$/;"	f
cram_get_block_by_id	cram/cram_io.h	/^static inline cram_block *cram_get_block_by_id(cram_slice *slice, int id) {$/;"	f
cram_get_ref	cram/cram_io.c	/^char *cram_get_ref(cram_fd *fd, int id, int start, int end) {$/;"	f
cram_get_refs	cram/cram_external.c	/^refs_t *cram_get_refs(htsFile *fd) {$/;"	f
cram_get_seq	cram/cram_decode.c	/^cram_record *cram_get_seq(cram_fd *fd) {$/;"	f
cram_h	Makefile	/^cram_h = cram\/cram.h $(cram_samtools_h) $(cram_sam_header_h) $(cram_structs_h) $(cram_io_h) cram\/cram_encode.h cram\/cram_decode.h cram\/cram_stats.h cram\/cram_codecs.h cram\/cram_index.h $(htslib_cram_h)$/;"	m
cram_header_to_bam	cram/cram_samtools.c	/^bam_hdr_t *cram_header_to_bam(SAM_hdr *h) {$/;"	f
cram_hfile	cram/cram_io.h	/^static inline struct hFILE *cram_hfile(cram_fd *fd) {$/;"	f
cram_huffman_code	cram/cram_codecs.h	/^} cram_huffman_code;$/;"	t	typeref:struct:__anon68
cram_huffman_decode_char	cram/cram_codecs.c	/^int cram_huffman_decode_char(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_decode_char0	cram/cram_codecs.c	/^int cram_huffman_decode_char0(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_decode_free	cram/cram_codecs.c	/^void cram_huffman_decode_free(cram_codec *c) {$/;"	f
cram_huffman_decode_init	cram/cram_codecs.c	/^cram_codec *cram_huffman_decode_init(char *data, int size,$/;"	f
cram_huffman_decode_int	cram/cram_codecs.c	/^int cram_huffman_decode_int(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_decode_int0	cram/cram_codecs.c	/^int cram_huffman_decode_int0(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_decode_null	cram/cram_codecs.c	/^int cram_huffman_decode_null(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_decoder	cram/cram_codecs.h	/^} cram_huffman_decoder;$/;"	t	typeref:struct:__anon69
cram_huffman_encode_char	cram/cram_codecs.c	/^int cram_huffman_encode_char(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_encode_char0	cram/cram_codecs.c	/^int cram_huffman_encode_char0(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_encode_free	cram/cram_codecs.c	/^void cram_huffman_encode_free(cram_codec *c) {$/;"	f
cram_huffman_encode_init	cram/cram_codecs.c	/^cram_codec *cram_huffman_encode_init(cram_stats *st,$/;"	f
cram_huffman_encode_int	cram/cram_codecs.c	/^int cram_huffman_encode_int(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_encode_int0	cram/cram_codecs.c	/^int cram_huffman_encode_int0(cram_slice *slice, cram_codec *c,$/;"	f
cram_huffman_encode_store	cram/cram_codecs.c	/^int cram_huffman_encode_store(cram_codec *c, cram_block *b, char *prefix,$/;"	f
cram_huffman_encoder	cram/cram_codecs.h	/^} cram_huffman_encoder;$/;"	t	typeref:struct:__anon70
cram_index	cram/cram_structs.h	/^typedef struct cram_index {$/;"	s
cram_index	cram/cram_structs.h	/^} cram_index;$/;"	t	typeref:struct:cram_index
cram_index_build	cram/cram_index.c	/^int cram_index_build(cram_fd *fd, const char *fn_base, const char *fn_idx) {$/;"	f
cram_index_build_multiref	cram/cram_index.c	/^static int cram_index_build_multiref(cram_fd *fd,$/;"	f	file:
cram_index_free	cram/cram_index.c	/^void cram_index_free(cram_fd *fd) {$/;"	f
cram_index_free_recurse	cram/cram_index.c	/^static void cram_index_free_recurse(cram_index *e) {$/;"	f	file:
cram_index_load	cram/cram_index.c	/^int cram_index_load(cram_fd *fd, const char *fn, const char *fn_idx) {$/;"	f
cram_index_query	cram/cram_index.c	/^cram_index *cram_index_query(cram_fd *fd, int refid, int pos, $/;"	f
cram_init_tables	cram/cram_io.c	/^static void cram_init_tables(cram_fd *fd) {$/;"	f	file:
cram_io_h	Makefile	/^cram_io_h = cram\/cram_io.h $(cram_misc_h)$/;"	m
cram_itr_query	sam.c	/^static hts_itr_t *cram_itr_query(const hts_idx_t *idx, int tid, int beg, int end, hts_readrec_func *readrec)$/;"	f	file:
cram_job	cram/cram_io.c	/^} cram_job;$/;"	t	typeref:struct:__anon67	file:
cram_load_reference	cram/cram_io.c	/^int cram_load_reference(cram_fd *fd, char *fn) {$/;"	f
cram_major_vers	cram/cram_external.c	/^int cram_major_vers(cram_fd *fd) { return CRAM_MAJOR_VERS(fd->version); }$/;"	f
cram_map	cram/cram_structs.h	/^typedef struct cram_map {$/;"	s
cram_map	cram/cram_structs.h	/^} cram_map;$/;"	t	typeref:struct:cram_map
cram_metrics	cram/cram_structs.h	/^} cram_metrics;$/;"	t	typeref:struct:__anon80
cram_metrics	htslib/cram.h	/^typedef struct cram_metrics cram_metrics;$/;"	t	typeref:struct:cram_metrics
cram_minor_vers	cram/cram_external.c	/^int cram_minor_vers(cram_fd *fd) { return CRAM_MINOR_VERS(fd->version); }$/;"	f
cram_misc_h	Makefile	/^cram_misc_h = cram\/misc.h $(cram_os_h)$/;"	m
cram_mstrand	cram/cram_structs.h	465;"	d
cram_name2id	sam.c	/^static int cram_name2id(void *fdv, const char *ref)$/;"	f	file:
cram_name_len	cram/cram_structs.h	463;"	d
cram_new_block	cram/cram_io.c	/^cram_block *cram_new_block(enum cram_content_type content_type,$/;"	f
cram_new_compression_header	cram/cram_io.c	/^cram_block_compression_hdr *cram_new_compression_header(void) {$/;"	f
cram_new_container	cram/cram_io.c	/^cram_container *cram_new_container(int nrec, int nslice) {$/;"	f
cram_new_metrics	cram/cram_io.c	/^cram_metrics *cram_new_metrics(void) {$/;"	f
cram_new_slice	cram/cram_io.c	/^cram_slice *cram_new_slice(enum cram_content_type type, int nrecs) {$/;"	f
cram_next_container	cram/cram_encode.c	/^static cram_container *cram_next_container(cram_fd *fd, bam_seq_t *b) {$/;"	f	file:
cram_next_slice	cram/cram_decode.c	/^static cram_slice *cram_next_slice(cram_fd *fd, cram_container **cp) {$/;"	f	file:
cram_nop_decode_reset	cram/cram_codecs.c	/^void cram_nop_decode_reset(cram_codec *c) {}$/;"	f
cram_not_enough_bits	cram/cram_codecs.h	/^static inline int cram_not_enough_bits(cram_block *blk, int nbits) {$/;"	f
cram_open	cram/cram_io.c	/^cram_fd *cram_open(const char *filename, const char *mode) {$/;"	f
cram_open_trace_file_h	Makefile	/^cram_open_trace_file_h = cram\/open_trace_file.h cram\/mFILE.h$/;"	m
cram_option	htslib/hts.h	244;"	d
cram_os_h	Makefile	/^cram_os_h = cram\/os.h $(htslib_hts_endian_h)$/;"	m
cram_populate_ref	cram/cram_io.c	/^static int cram_populate_ref(cram_fd *fd, int id, ref_entry *r) {$/;"	f	file:
cram_put_bam_seq	cram/cram_encode.c	/^int cram_put_bam_seq(cram_fd *fd, bam_seq_t *b) {$/;"	f
cram_qname	cram/cram_structs.h	458;"	d
cram_qual	cram/cram_structs.h	460;"	d
cram_range	cram/cram_structs.h	/^} cram_range;$/;"	t	typeref:struct:__anon94
cram_read_SAM_hdr	cram/cram_io.c	/^SAM_hdr *cram_read_SAM_hdr(cram_fd *fd) {$/;"	f
cram_read_block	cram/cram_io.c	/^cram_block *cram_read_block(cram_fd *fd) {$/;"	f
cram_read_container	cram/cram_io.c	/^cram_container *cram_read_container(cram_fd *fd) {$/;"	f
cram_read_file_def	cram/cram_io.c	/^cram_file_def *cram_read_file_def(cram_fd *fd) {$/;"	f
cram_read_slice	cram/cram_io.c	/^cram_slice *cram_read_slice(cram_fd *fd) {$/;"	f
cram_readrec	sam.c	/^static int cram_readrec(BGZF *ignored, void *fpv, void *bv, int *tid, int *beg, int *end)$/;"	f	file:
cram_record	cram/cram_structs.h	/^typedef struct cram_record {$/;"	s
cram_record	cram/cram_structs.h	/^} cram_record;$/;"	t	typeref:struct:cram_record
cram_ref_decr	cram/cram_io.c	/^void cram_ref_decr(refs_t *r, int id) {$/;"	f
cram_ref_decr_locked	cram/cram_io.c	/^static void cram_ref_decr_locked(refs_t *r, int id) {$/;"	f	file:
cram_ref_incr	cram/cram_io.c	/^void cram_ref_incr(refs_t *r, int id) {$/;"	f
cram_ref_incr_locked	cram/cram_io.c	/^static void cram_ref_incr_locked(refs_t *r, int id) {$/;"	f	file:
cram_ref_load	cram/cram_io.c	/^ref_entry *cram_ref_load(refs_t *r, int id, int is_md5) {$/;"	f
cram_sam_header_h	Makefile	/^cram_sam_header_h = cram\/sam_header.h cram\/string_alloc.h cram\/pooled_alloc.h $(htslib_khash_h) $(htslib_kstring_h)$/;"	m
cram_samtools_h	Makefile	/^cram_samtools_h = cram\/cram_samtools.h $(htslib_sam_h) $(cram_sam_header_h)$/;"	m
cram_seek	cram/cram_io.c	/^int cram_seek(cram_fd *fd, off_t offset, int whence) {$/;"	f
cram_seek_to_refpos	cram/cram_index.c	/^int cram_seek_to_refpos(cram_fd *fd, cram_range *r) {$/;"	f
cram_seq	cram/cram_structs.h	459;"	d
cram_seqi	cram/cram_structs.h	462;"	d
cram_set_header	cram/cram_io.c	/^int cram_set_header(cram_fd *fd, SAM_hdr *hdr) {$/;"	f
cram_set_option	cram/cram_io.c	/^int cram_set_option(cram_fd *fd, enum hts_fmt_option opt, ...) {$/;"	f
cram_set_voption	cram/cram_io.c	/^int cram_set_voption(cram_fd *fd, enum hts_fmt_option opt, va_list args) {$/;"	f
cram_slice	cram/cram_structs.h	/^typedef struct cram_slice {$/;"	s
cram_slice	cram/cram_structs.h	/^} cram_slice;$/;"	t	typeref:struct:cram_slice
cram_slice	htslib/cram.h	/^typedef struct cram_slice cram_slice;$/;"	t	typeref:struct:cram_slice
cram_slice_hdr_get_num_blocks	cram/cram_external.c	/^int32_t cram_slice_hdr_get_num_blocks(cram_block_slice_hdr *hdr) {$/;"	f
cram_stats	cram/cram_structs.h	/^typedef struct cram_stats {$/;"	s
cram_stats	cram/cram_structs.h	/^} cram_stats;$/;"	t	typeref:struct:cram_stats
cram_stats_add	cram/cram_stats.c	/^void cram_stats_add(cram_stats *st, int32_t val) {$/;"	f
cram_stats_create	cram/cram_stats.c	/^cram_stats *cram_stats_create(void) {$/;"	f
cram_stats_del	cram/cram_stats.c	/^void cram_stats_del(cram_stats *st, int32_t val) {$/;"	f
cram_stats_dump	cram/cram_stats.c	/^void cram_stats_dump(cram_stats *st) {$/;"	f
cram_stats_encoding	cram/cram_stats.c	/^enum cram_encoding cram_stats_encoding(cram_fd *fd, cram_stats *st) {$/;"	f
cram_stats_free	cram/cram_stats.c	/^void cram_stats_free(cram_stats *st) {$/;"	f
cram_store_container	cram/cram_io.c	/^int cram_store_container(cram_fd *fd, cram_container *c, char *dat, int *size)$/;"	f
cram_strand	cram/cram_structs.h	464;"	d
cram_structs_h	Makefile	/^cram_structs_h = cram\/cram_structs.h $(htslib_thread_pool_h) cram\/string_alloc.h $(htslib_khash_h)$/;"	m
cram_sub_matrix	cram/cram_structs.h	/^    char cram_sub_matrix[32][32];	\/\/ base substituion codes$/;"	m	struct:cram_fd
cram_subexp_decode	cram/cram_codecs.c	/^int cram_subexp_decode(cram_slice *slice, cram_codec *c, cram_block *in, char *out, int *out_size) {$/;"	f
cram_subexp_decode_free	cram/cram_codecs.c	/^void cram_subexp_decode_free(cram_codec *c) {$/;"	f
cram_subexp_decode_init	cram/cram_codecs.c	/^cram_codec *cram_subexp_decode_init(char *data, int size,$/;"	f
cram_subexp_decoder	cram/cram_codecs.h	/^} cram_subexp_decoder;$/;"	t	typeref:struct:__anon73
cram_tag_map	cram/cram_structs.h	/^typedef struct cram_tag_map {$/;"	s
cram_tag_map	cram/cram_structs.h	/^} cram_tag_map;$/;"	t	typeref:struct:cram_tag_map
cram_to_bam	cram/cram_decode.c	/^static int cram_to_bam(SAM_hdr *bfd, cram_fd *fd, cram_slice *s,$/;"	f	file:
cram_transcode_rg	cram/cram_external.c	/^int cram_transcode_rg(cram_fd *in, cram_fd *out,$/;"	f
cram_uncompress_block	cram/cram_io.c	/^int cram_uncompress_block(cram_block *b) {$/;"	f
cram_update_curr_slice	cram/cram_encode.c	/^void cram_update_curr_slice(cram_container *c) {$/;"	f
cram_write_SAM_hdr	cram/cram_io.c	/^int cram_write_SAM_hdr(cram_fd *fd, SAM_hdr *hdr) {$/;"	f
cram_write_block	cram/cram_io.c	/^int cram_write_block(cram_fd *fd, cram_block *b) {$/;"	f
cram_write_container	cram/cram_io.c	/^int cram_write_container(cram_fd *fd, cram_container *c) {$/;"	f
cram_write_file_def	cram/cram_io.c	/^int cram_write_file_def(cram_fd *fd, cram_file_def *def) {$/;"	f
crc32	cram/cram_structs.h	/^    uint32_t crc32;       \/\/ CRC32$/;"	m	struct:cram_container
crc32	cram/cram_structs.h	/^    uint32_t crc32;$/;"	m	struct:cram_block
crecs	cram/cram_structs.h	/^    cram_record *crecs;$/;"	m	struct:cram_slice
creg	synced_bcf_reader.c	/^    int nregs, mregs, creg;$/;"	m	struct:_region_t	file:
csi	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
cstate_t	sam.c	/^} cstate_t;$/;"	t	typeref:struct:__anon4	file:
ctr	cram/cram_structs.h	/^    cram_container *ctr;$/;"	m	struct:cram_fd
ctrl_fd	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
curl	hfile_libcurl.c	/^} curl = { { 0, 0, NULL }, NULL, PTHREAD_MUTEX_INITIALIZER };$/;"	v	typeref:struct:__anon103	file:
curr_beg	htslib/hts.h	/^    int curr_tid, curr_beg, curr_end;$/;"	m	struct:__anon14
curr_c_rec	cram/cram_structs.h	/^    int max_c_rec, curr_c_rec;   \/\/ current and max recs per container$/;"	m	struct:cram_container
curr_end	htslib/hts.h	/^    int curr_tid, curr_beg, curr_end;$/;"	m	struct:__anon14
curr_job	bgzf.c	/^    bgzf_job *curr_job;$/;"	m	struct:bgzf_mtaux_t	file:
curr_off	htslib/hts.h	/^    uint64_t curr_off;$/;"	m	struct:__anon14
curr_rec	cram/cram_structs.h	/^    int max_rec, curr_rec;       \/\/ current and max recs per slice$/;"	m	struct:cram_container
curr_ref	cram/cram_structs.h	/^    int curr_ref;                \/\/ current ref ID. -2 for no previous$/;"	m	struct:cram_container
curr_serial	thread_pool_internal.h	/^    uint64_t curr_serial;            \/\/ current serial (next input)$/;"	m	struct:hts_tpool_process
curr_slice	cram/cram_structs.h	/^    int max_slice, curr_slice;   \/\/ maximum number of slices$/;"	m	struct:cram_container
curr_tid	htslib/hts.h	/^    int curr_tid, curr_beg, curr_end;$/;"	m	struct:__anon14
current	multipart.c	/^    size_t nparts, maxparts, current;$/;"	m	struct:__anon104	file:
currentfp	multipart.c	/^    hFILE *currentfp;$/;"	m	struct:__anon104	file:
custom	htslib/hts.h	/^    no_compression, gzip, bgzf, custom,$/;"	e	enum:htsCompression
custom_free	test/test-regidx.c	/^void custom_free(void *payload)$/;"	f
custom_parse	test/test-regidx.c	/^int custom_parse(const char *line, char **chr_beg, char **chr_end, reg_t *reg, void *payload, void *usr)$/;"	f
cygpath	test/test.pl	/^sub cygpath {$/;"	s
d	htslib/hts.h	/^    float d, e;$/;"	m	struct:probaln_par_t
d	htslib/vcf.h	/^    bcf_dec_t d; \/\/ lazy evaluation: $d is not generated by bcf_read(), but by explicitly calling bcf_unpack()$/;"	m	struct:__anon25
d	md5.c	/^	hts_md5_u32plus a, b, c, d;$/;"	m	struct:hts_md5_context	file:
d	test/hts_endian.c	/^    double d;$/;"	m	struct:__anon47	file:
data	cram/cram_structs.h	/^    unsigned char    *data;$/;"	m	struct:cram_block
data	cram/mFILE.h	/^    char *data;$/;"	m	struct:__anon58
data	htslib/sam.h	/^    uint8_t *data;$/;"	m	struct:__anon38
data	sam.c	/^    void *data;$/;"	m	struct:__bam_plp_t	file:
data	thread_pool_internal.h	/^    void *data;      \/\/ result itself$/;"	m	struct:hts_tpool_result
data_series	cram/cram_structs.h	/^    unsigned int data_series; \/\/ See cram_fields enum below$/;"	m	struct:cram_block_compression_hdr
datarootdir	Makefile	/^datarootdir = $(prefix)\/share$/;"	m
date	hfile_s3.c	/^    char date[40];$/;"	m	struct:__anon53	file:
debase64	textutils.c	/^static int debase64(char c)$/;"	f	file:
debug_buffer	synced_bcf_reader.c	/^void debug_buffer(FILE *fp, bcf_sr_t *reader)$/;"	f
debug_buffers	synced_bcf_reader.c	/^void debug_buffers(FILE *fp, bcf_srs_t *files)$/;"	f
debug_vbuf	bcf_sr_sort.c	/^void debug_vbuf(sr_sort_t *srt)$/;"	f
debug_vsets	bcf_sr_sort.c	/^void debug_vsets(sr_sort_t *srt)$/;"	f
decode	cram/cram_codecs.h	/^    int (*decode)(cram_slice *slice, struct cram_codec *codec,$/;"	m	struct:cram_codec
decode_init	cram/cram_codecs.c	/^static cram_codec *(*decode_init[])(char *data,$/;"	v	file:
decode_md	cram/cram_structs.h	/^    int decode_md; \/\/ Whether to export MD and NM tags$/;"	m	struct:cram_fd
decompress_peek	hts.c	/^static size_t decompress_peek(hFILE *fp, unsigned char *dest, size_t destsize)$/;"	f	file:
deflate_block	bgzf.c	/^static int deflate_block(BGZF *fp, int block_length)$/;"	f	file:
dehex	textutils.c	/^static int dehex(char c)$/;"	f	file:
depth	htslib/ksort.h	/^	int depth;$/;"	m	struct:__anon33
destroy	hfile_internal.h	/^    void (*destroy)(void);$/;"	m	struct:hFILE_plugin
dict	htslib/tbx.h	/^    void *dict;$/;"	m	struct:__anon35
dict	htslib/vcf.h	/^    void *dict[3];          \/\/ ID dictionary, contig dict and sample dict$/;"	m	struct:__anon19
direction	vcf_sweep.c	/^    int direction;          \/\/ to tell if the direction has changed$/;"	m	struct:_bcf_sweep_t	file:
dirty	htslib/vcf.h	/^    int nhrec, dirty;$/;"	m	struct:__anon19
dirv	hts_internal.h	/^    void *dirv;  \/\/ DIR * privately$/;"	m	struct:hts_path_itr
doit_square	thread_pool.c	/^void *doit_square(void *arg) {$/;"	f
doit_square_u	thread_pool.c	/^void *doit_square_u(void *arg) {$/;"	f
double_to_le	htslib/hts_endian.h	/^static inline void double_to_le(double val, uint8_t *buf) {$/;"	f
drand48	htslib/hts_os.h	38;"	d
dsize	cram/pooled_alloc.h	/^    size_t dsize;$/;"	m	struct:__anon55
dummy	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
dummy	htslib/hts.h	/^    uint32_t read_rest:1, finished:1, is_cram:1, dummy:29;$/;"	m	struct:__anon14
dump_char	vcf.c	/^static const char *dump_char(char *buffer, char c)$/;"	f	file:
dump_pmatrix	test/test-bcf-sr.pl	/^sub dump_pmatrix$/;"	s
dup_stdout	htsfile.c	/^static htsFile *dup_stdout(const char *mode)$/;"	f	file:
e	cram/cram_structs.h	/^    struct cram_index *e; \/\/ array of size nslice$/;"	m	struct:cram_index	typeref:struct:cram_index::cram_index
e	htslib/hts.h	/^    float d, e;$/;"	m	struct:probaln_par_t
e_beta	cram/cram_codecs.h	/^	cram_beta_decoder            e_beta;$/;"	m	union:cram_codec::__anon78
e_byte_array_len	cram/cram_codecs.h	/^	cram_byte_array_len_encoder  e_byte_array_len;$/;"	m	union:cram_codec::__anon78
e_byte_array_stop	cram/cram_codecs.h	/^	cram_byte_array_stop_decoder e_byte_array_stop;$/;"	m	union:cram_codec::__anon78
e_external	cram/cram_codecs.h	/^	cram_external_decoder        e_external;$/;"	m	union:cram_codec::__anon78
e_huffman	cram/cram_codecs.h	/^	cram_huffman_encoder         e_huffman;$/;"	m	union:cram_codec::__anon78
easy	hfile_libcurl.c	/^    CURL *easy;$/;"	m	struct:__anon100	file:
easy_errno	hfile_libcurl.c	/^static int easy_errno(CURL *easy, CURLcode err)$/;"	f	file:
ec	htslib/tbx.h	/^    int32_t sc, bc, ec; \/\/ seq col., beg col. and end col.$/;"	m	struct:__anon34
ed_is_big	htslib/hts.h	/^static inline int ed_is_big(void)$/;"	f
ed_swap_2	htslib/hts.h	/^static inline uint16_t ed_swap_2(uint16_t v)$/;"	f
ed_swap_2p	htslib/hts.h	/^static inline void *ed_swap_2p(void *x)$/;"	f
ed_swap_4	htslib/hts.h	/^static inline uint32_t ed_swap_4(uint32_t v)$/;"	f
ed_swap_4p	htslib/hts.h	/^static inline void *ed_swap_4p(void *x)$/;"	f
ed_swap_8	htslib/hts.h	/^static inline uint64_t ed_swap_8(uint64_t v)$/;"	f
ed_swap_8p	htslib/hts.h	/^static inline void *ed_swap_8p(void *x)$/;"	f
elt	htslib/kbitset.h	/^	size_t elt;$/;"	m	struct:kbitset_iter_t
embed_ref	cram/cram_structs.h	/^    int embed_ref;$/;"	m	struct:cram_fd
empty_container	cram/cram_structs.h	/^    int empty_container; 		\/\/ Marker for EOF block$/;"	m	struct:cram_fd
encode	cram/cram_codecs.h	/^    int (*encode)(cram_slice *slice, struct cram_codec *codec,$/;"	m	struct:cram_codec
encode_init	cram/cram_codecs.c	/^static cram_codec *(*encode_init[])(cram_stats *stx,$/;"	v	file:
encode_utf8	textutils.c	/^static char *encode_utf8(char *s, unsigned x)$/;"	f	file:
encoding	cram/cram_structs.h	/^    enum cram_encoding encoding;$/;"	m	struct:cram_map	typeref:enum:cram_map::cram_encoding
end	cram/cram_structs.h	/^    int     end;    \/\/                     1.1$/;"	m	struct:cram_index
end	cram/cram_structs.h	/^    int end;$/;"	m	struct:__anon94
end	htslib/hfile.h	/^    char *buffer, *begin, *end, *limit;$/;"	m	struct:hFILE
end	htslib/hts.h	/^    int tid, beg, end, n_off, i;$/;"	m	struct:__anon14
end	htslib/regidx.h	/^    uint32_t start, end;$/;"	m	struct:__anon26
end	htslib/synced_bcf_reader.h	/^    int start, end;         \/\/ current position: start, end of the region (0-based)$/;"	m	struct:_bcf_sr_regions_t
end	sam.c	/^    int k, x, y, end;$/;"	m	struct:__anon4	file:
end	sam.c	/^    int32_t beg, end;$/;"	m	struct:__linkbuf_t	file:
end	synced_bcf_reader.c	/^    uint32_t start, end;$/;"	m	struct:__anon105	file:
end	tbx.c	/^    int64_t beg, end;$/;"	m	struct:__anon113	file:
end_offset	bgzf.c	/^    int64_t end_offset;$/;"	m	struct:__anon51	file:
end_prev	regidx.c	/^    int rid_prev, start_prev, end_prev;$/;"	m	struct:_regidx_t	file:
entry	hts_internal.h	/^    kstring_t path, entry;$/;"	m	struct:hts_path_itr
entry_dir_l	hts_internal.h	/^    size_t prefix_len, suffix_len, entry_dir_l;$/;"	m	struct:hts_path_itr
eof	bgzf.c	/^    int eof;$/;"	m	struct:bgzf_mtaux_t	file:
eof	cram/cram_structs.h	/^    int eof;$/;"	m	struct:cram_fd
eof	cram/mFILE.h	/^    int eof;$/;"	m	struct:__anon58
eof	thread_pool.c	/^    int eof; \/\/ set with last job.$/;"	m	struct:__anon111	file:
erand48	htslib/hts_os.h	37;"	d
err	cram/cram_structs.h	/^    int            err;$/;"	m	struct:cram_fd
errcode	bgzf.c	/^    int errcode;$/;"	m	struct:bgzf_job	file:
errcode	bgzf.c	/^    int errcode;$/;"	m	struct:bgzf_mtaux_t	file:
errcode	htslib/bgzf.h	/^    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;$/;"	m	struct:BGZF
errcode	htslib/vcf.h	/^    int errcode;    \/\/ one of BCF_ERR_* codes$/;"	m	struct:__anon25
errmod_cal	errmod.c	/^int errmod_cal(const errmod_t *em, int n, int m, uint16_t *bases, float *q)$/;"	f
errmod_destroy	errmod.c	/^void errmod_destroy(errmod_t *em)$/;"	f
errmod_init	errmod.c	/^errmod_t *errmod_init(double depcorr)$/;"	f
errmod_t	htslib/hts.h	/^typedef struct errmod_t errmod_t;$/;"	t	typeref:struct:errmod_t
errnum	htslib/synced_bcf_reader.h	/^    bcf_sr_error errnum;$/;"	m	struct:__anon31
error	bgzip.c	/^static void error(const char *format, ...)$/;"	f	file:
error	htsfile.c	/^void error(const char *format, ...)$/;"	f
error	sam.c	/^    int is_eof, max_plp, error, maxcnt;$/;"	m	struct:__bam_plp_t	file:
error	tabix.c	/^static void error(const char *format, ...)$/;"	f	file:
error	test/test-bcf-sr.c	/^void error(const char *format, ...)$/;"	f
error	test/test-bcf-sr.pl	/^sub error$/;"	s
error	test/test-regidx.c	/^void error(const char *format, ...)$/;"	f
error	test/test.pl	/^sub error$/;"	s
exec_prefix	Makefile	/^exec_prefix = $(prefix)$/;"	m
exit_code	cram/cram_decode.c	/^    int exit_code;$/;"	m	struct:__anon95	file:
expand_cache_path	cram/cram_io.c	/^void expand_cache_path(char *path, char *dir, char *fn) {$/;"	f
expand_path	cram/open_trace_file.c	/^static char *expand_path(char *file, char *dirname) {$/;"	f	file:
expand_tilde_open	hfile_s3.c	/^static FILE *expand_tilde_open(const char *fname, const char *mode)$/;"	f	file:
expected_template_count	cram/cram_encode.c	/^static int expected_template_count(bam_seq_t *b) {$/;"	f	file:
explicit_regs	htslib/synced_bcf_reader.h	/^    int explicit_regs;  \/\/ was the list of regions se by bcf_sr_set_regions or guessed from tabix index?$/;"	m	struct:__anon31
external	cram/cram_codecs.h	/^	cram_external_decoder        external;$/;"	m	union:cram_codec::__anon78
extra	hfile_libcurl.c	/^    hdrlist extra;                   \/\/ List of headers from callback$/;"	m	struct:__anon99	file:
f	htslib/sam.h	/^    double f;$/;"	m	union:__anon39
f	htslib/vcf.h	/^        float f;   \/\/ float value$/;"	m	union:__anon22::__anon23
f	test/hts_endian.c	/^    float f;$/;"	m	struct:__anon46	file:
f_bgzf	test/test_bgzf.c	/^    FILE *f_bgzf;$/;"	m	struct:__anon48	file:
f_idx	test/test_bgzf.c	/^    FILE *f_idx;$/;"	m	struct:__anon48	file:
f_plain	test/test_bgzf.c	/^    FILE *f_plain;$/;"	m	struct:__anon48	file:
fai_build	faidx.c	/^int fai_build(const char *fn) {$/;"	f
fai_build3	faidx.c	/^int fai_build3(const char *fn, const char *fnfai, const char *fngzi)$/;"	f
fai_build_core	faidx.c	/^faidx_t *fai_build_core(BGZF *bgzf)$/;"	f
fai_destroy	faidx.c	/^void fai_destroy(faidx_t *fai)$/;"	f
fai_fetch	faidx.c	/^char *fai_fetch(const faidx_t *fai, const char *str, int *len)$/;"	f
fai_insert_index	faidx.c	/^static inline int fai_insert_index(faidx_t *idx, const char *name, int64_t len, int line_len, int line_blen, uint64_t offset)$/;"	f	file:
fai_load	faidx.c	/^faidx_t *fai_load(const char *fn)$/;"	f
fai_load3	faidx.c	/^faidx_t *fai_load3(const char *fn, const char *fnfai, const char *fngzi,$/;"	f
fai_load_options	htslib/faidx.h	/^enum fai_load_options {$/;"	g
fai_read	faidx.c	/^static faidx_t *fai_read(hFILE *fp, const char *fname)$/;"	f	file:
fai_retrieve	faidx.c	/^static char *fai_retrieve(const faidx_t *fai, const faidx1_t *val,$/;"	f	file:
fai_save	faidx.c	/^static int fai_save(const faidx_t *fai, hFILE *fp) {$/;"	f	file:
faidx1	test/sam.c	/^static void faidx1(const char *filename)$/;"	f	file:
faidx1_t	faidx.c	/^} faidx1_t;$/;"	t	typeref:struct:__anon112	file:
faidx_fetch_nseq	faidx.c	/^int faidx_fetch_nseq(const faidx_t *fai)$/;"	f
faidx_fetch_seq	faidx.c	/^char *faidx_fetch_seq(const faidx_t *fai, const char *c_name, int p_beg_i, int p_end_i, int *len)$/;"	f
faidx_has_seq	faidx.c	/^int faidx_has_seq(const faidx_t *fai, const char *seq)$/;"	f
faidx_iseq	faidx.c	/^const char *faidx_iseq(const faidx_t *fai, int i)$/;"	f
faidx_nseq	faidx.c	/^int faidx_nseq(const faidx_t *fai)$/;"	f
faidx_seq_len	faidx.c	/^int faidx_seq_len(const faidx_t *fai, const char *seq)$/;"	f
faidx_t	htslib/faidx.h	/^typedef struct __faidx_t faidx_t;$/;"	t	typeref:struct:__faidx_t
fail	test/hfile.c	/^void HTS_NORETURN fail(const char *format, ...)$/;"	f
fail	test/sam.c	/^static void HTS_FORMAT(HTS_PRINTF_FMT, 1, 2) fail(const char *fmt, ...)$/;"	f
failed	test/test.pl	/^sub failed$/;"	s
fd	cram/cram_decode.c	/^    cram_fd *fd;$/;"	m	struct:__anon95	file:
fd	cram/cram_io.c	/^    cram_fd *fd;$/;"	m	struct:__anon67	file:
fd	hfile.c	/^    int fd;$/;"	m	struct:__anon107	file:
fd	htslib/knetfile.h	/^	int type, fd;$/;"	m	struct:knetFile_s
fd_backend	hfile.c	/^static const struct hFILE_backend fd_backend =$/;"	v	typeref:struct:hFILE_backend	file:
fd_close	hfile.c	/^static int fd_close(hFILE *fpv)$/;"	f	file:
fd_flush	hfile.c	/^static int fd_flush(hFILE *fpv)$/;"	f	file:
fd_read	hfile.c	/^static ssize_t fd_read(hFILE *fpv, void *buffer, size_t nbytes)$/;"	f	file:
fd_seek	hfile.c	/^static off_t fd_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
fd_write	hfile.c	/^static ssize_t fd_write(hFILE *fpv, const void *buffer, size_t nbytes)$/;"	f	file:
feature	cram/cram_structs.h	/^    int32_t feature;      \/\/ idx to s->feature$/;"	m	struct:cram_record
features	cram/cram_structs.h	/^    cram_feature *features;$/;"	m	struct:cram_slice
file	htslib/synced_bcf_reader.h	/^    htsFile *file;$/;"	m	struct:__anon29
file	htslib/synced_bcf_reader.h	/^    htsFile *file;$/;"	m	struct:_bcf_sr_regions_t
file	vcf_sweep.c	/^    htsFile *file;$/;"	m	struct:_bcf_sweep_t	file:
file_def	cram/cram_structs.h	/^    cram_file_def *file_def;$/;"	m	struct:cram_fd
file_exists	cram/files.c	/^int file_exists(char * fn)$/;"	f
file_id	cram/cram_structs.h	/^    char    file_id[20];      \/\/ Filename or SHA1 checksum$/;"	m	struct:cram_file_def
file_size	cram/files.c	/^int file_size(char * fn)$/;"	f
file_size	hfile_libcurl.c	/^    off_t file_size;$/;"	m	struct:__anon100	file:
file_size	htslib/knetfile.h	/^    int64_t file_size;$/;"	m	struct:knetFile_s
file_type	tabix.c	/^int file_type(const char *fname)$/;"	f
file_type_error	htslib/synced_bcf_reader.h	/^    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,$/;"	e	enum:__anon30
filter_ids	htslib/synced_bcf_reader.h	/^    int nfilter_ids, *filter_ids;   \/\/ -1 for ".", otherwise filter id as returned by bcf_hdr_id2int$/;"	m	struct:__anon29
fin	test/hfile.c	/^hFILE *fin = NULL;$/;"	v
final_result	hfile_libcurl.c	/^    CURLcode final_result;  \/\/ easy result code for finished transfers$/;"	m	struct:__anon100	file:
find_chrom_header_line	vcf.c	/^static char *find_chrom_header_line(char *s)$/;"	f	file:
find_file_dir	cram/open_trace_file.c	/^static mFILE *find_file_dir(char *file, char *dirname) {$/;"	f	file:
find_file_url	cram/open_trace_file.c	/^mFILE *find_file_url(char *file, char *url) {$/;"	f
find_path	cram/open_trace_file.c	/^char *find_path(char *file, char *path) {$/;"	f
find_scheme_handler	hfile.c	/^static const struct hFILE_scheme_handler *find_scheme_handler(const char *s)$/;"	f	file:
finished	hfile_libcurl.c	/^    unsigned finished : 1;  \/\/ wait_perform() tells us transfer is complete$/;"	m	struct:__anon100	file:
finished	hts.c	/^        int last_coor, last_tid, save_tid, finished;$/;"	m	struct:__hts_idx_t::__anon3	file:
finished	htslib/hts.h	/^    uint32_t read_rest:1, finished:1, is_cram:1, dummy:29;$/;"	m	struct:__anon14
finished	htslib/kstring.h	/^	int sep, finished;$/;"	m	struct:__anon32
first_base	cram/cram_structs.h	/^    int first_base, last_base;$/;"	m	struct:cram_fd
first_base	cram/cram_structs.h	/^    int ref_start, first_base, last_base, ref_id, ref_end;$/;"	m	struct:cram_container
first_container	cram/cram_structs.h	/^    off_t first_container;$/;"	m	struct:cram_fd
fixed	hfile_libcurl.c	/^    hdrlist fixed;                   \/\/ List of headers supplied at hopen()$/;"	m	struct:__anon99	file:
flag	htslib/sam.h	/^    uint16_t flag;$/;"	m	struct:__anon37
flags	cram/cram_structs.h	/^    int32_t flags;        \/\/ BF$/;"	m	struct:cram_record
float_to_le	htslib/hts_endian.h	/^static inline void float_to_le(float val, uint8_t *buf) {$/;"	f
flt	htslib/vcf.h	/^    int *flt;   \/\/ FILTER keys in the dictionary$/;"	m	struct:__anon24
flush	htslib/hfile.h	/^	int (*flush)(void* cb_data);$/;"	m	struct:hFILE_callback_ops
flush_buffer	hfile.c	/^static ssize_t flush_buffer(hFILE *fp)$/;"	f	file:
flush_pending	bgzf.c	/^    int flush_pending;$/;"	m	struct:bgzf_mtaux_t	file:
flush_pos	cram/mFILE.h	/^    size_t flush_pos;$/;"	m	struct:__anon58
fmt	hts.c	/^    int fmt, min_shift, n_lvls, n_bins;$/;"	m	struct:__hts_idx_t	file:
fmt	hts_internal.h	/^    int fmt;$/;"	m	struct:hts_cram_idx_t
fmt	htslib/vcf.h	/^    bcf_fmt_t *fmt;     \/\/ FORMAT and individual sample$/;"	m	struct:__anon24
fmt_aux_t	vcf.c	/^} fmt_aux_t;$/;"	t	typeref:struct:__anon50	file:
fn	cram/cram_structs.h	/^    char *fn;              \/\/ current file opened$/;"	m	struct:__anon93
fn	cram/cram_structs.h	/^    char *fn;$/;"	m	struct:ref_entry
fn	htslib/hts.h	/^    char *fn, *fn_aux;$/;"	m	struct:__anon9
fn_aux	htslib/hts.h	/^    char *fn, *fn_aux;$/;"	m	struct:__anon9
fname	htslib/synced_bcf_reader.h	/^    char *fname;$/;"	m	struct:__anon29
fname	htslib/synced_bcf_reader.h	/^    char *fname;$/;"	m	struct:_bcf_sr_regions_t
fnext	textutils.c	/^static char fnext(void *arg1, void *arg2, hts_json_token *token)$/;"	f	file:
format	htslib/hts.h	/^    enum htsExactFormat format;$/;"	m	struct:htsFormat	typeref:enum:htsFormat::htsExactFormat
format	htslib/hts.h	/^    htsFormat format;$/;"	m	struct:__anon9
format_category	hts.c	/^static enum htsFormatCategory format_category(enum htsExactFormat fmt)$/;"	f	file:
format_maximum	htslib/hts.h	/^    format_maximum = 32767$/;"	e	enum:htsExactFormat
fout	test/hfile.c	/^hFILE *fout = NULL;$/;"	v
fp	bgzf.c	/^    BGZF *fp;$/;"	m	struct:bgzf_job	file:
fp	cram/cram_structs.h	/^    BGZF *fp;              \/\/ and the hFILE* to go with it.$/;"	m	struct:__anon93
fp	cram/cram_structs.h	/^    struct hFILE  *fp;$/;"	m	struct:cram_fd	typeref:struct:cram_fd::hFILE
fp	cram/mFILE.h	/^    FILE *fp;$/;"	m	struct:__anon58
fp	htslib/bgzf.h	/^    struct hFILE *fp; \/\/ actual file handle$/;"	m	struct:BGZF	typeref:struct:BGZF::hFILE
fp	htslib/hts.h	/^    } fp;$/;"	m	struct:__anon9	typeref:union:__anon9::__anon10
fp	vcf_sweep.c	/^    BGZF *fp;$/;"	m	struct:_bcf_sweep_t	file:
free	cram/cram_codecs.h	/^    void (*free)(struct cram_codec *codec);$/;"	m	struct:cram_codec
free	cram/pooled_alloc.h	/^    void *free;$/;"	m	struct:__anon55
free	regidx.c	/^    regidx_free_f free;     \/\/ function to free any data allocated by regidx_parse_f$/;"	m	struct:_regidx_t	file:
free_all_parts	multipart.c	/^static void free_all_parts(hFILE_multipart *fp)$/;"	f	file:
free_auth_data	hfile_s3.c	/^static void free_auth_data(s3_auth_data *ad) {$/;"	f	file:
free_block	bgzf.c	/^    void *free_block;$/;"	m	struct:bgzf_mtaux_t	file:
free_cache	bgzf.c	/^static void free_cache(BGZF *fp) {}$/;"	f	file:
free_cache	bgzf.c	/^static void free_cache(BGZF *fp)$/;"	f	file:
free_headers	hfile_libcurl.c	/^static void free_headers(hdrlist *hdrs, int completely) {$/;"	f	file:
free_part	multipart.c	/^static void free_part(hfile_part *p)$/;"	f	file:
freq	cram/rANS_byte.h	/^    uint16_t freq;      \/\/ Symbol frequency.$/;"	m	struct:__anon57
freqs	cram/cram_structs.h	/^    int freqs[MAX_STAT_VAL];$/;"	m	struct:cram_stats
fscan_string	textutils.c	/^static void fscan_string(hFILE *fp, kstring_t *d)$/;"	f	file:
fsum	errmod.c	/^    double fsum[16], bsum[16];$/;"	m	struct:__anon119	file:
ftruncate	cram/os.h	200;"	d
ftruncate	cram/os.h	212;"	d
full_path	cram/cram_io.c	/^static void full_path(char *out, char *in) {$/;"	f	file:
func	sam.c	/^    bam_plp_auto_f func;$/;"	m	struct:__bam_plp_t	file:
func	thread_pool_internal.h	/^    void *(*func)(void *arg);$/;"	m	struct:hts_tpool_job
g_cstate_null	sam.c	/^static cstate_t g_cstate_null = { -1, 0, 0, 0 };$/;"	v	file:
g_magic	bgzf.c	/^static const uint8_t g_magic[19] = "\\037\\213\\010\\4\\0\\0\\0\\0\\0\\377\\6\\0\\102\\103\\2\\0\\0\\0";$/;"	v	file:
g_qual2prob	probaln.c	/^static float g_qual2prob[256];$/;"	v	file:
gamma	cram/cram_codecs.h	/^	cram_gamma_decoder           gamma;$/;"	m	union:cram_codec::__anon78
gcs_open	hfile_gcs.c	/^static hFILE *gcs_open(const char *url, const char *mode)$/;"	f	file:
gcs_rewrite	hfile_gcs.c	/^gcs_rewrite(const char *gsurl, const char *mode, int mode_has_colon,$/;"	f	file:
gcs_vopen	hfile_gcs.c	/^static hFILE *gcs_vopen(const char *url, const char *mode_colon, va_list args0)$/;"	f	file:
get_bits_MSB	cram/cram_codecs.c	/^static inline unsigned int get_bits_MSB(cram_block *block, int nbits) {$/;"	f	file:
get_cache_basedir	cram/cram_io.c	/^static const char *get_cache_basedir(const char **extra) {$/;"	f	file:
get_header_list	hfile_libcurl.c	/^static struct curl_slist * get_header_list(hFILE_libcurl *fp) {$/;"	f	file:
get_int_aux_val	sam.c	/^static inline int64_t get_int_aux_val(uint8_t type, const uint8_t *s,$/;"	f	file:
get_int_threadid	cram/cram_io.c	/^static unsigned get_int_threadid() {$/;"	f	file:
get_intv	tbx.c	/^static inline int get_intv(tbx_t *tbx, kstring_t *str, tbx_intv_t *intv, int is_add)$/;"	f	file:
get_name_suffix	bgzf.c	/^static char * get_name_suffix(const char *bname, const char *suffix)$/;"	f	file:
get_one_bits_MSB	cram/cram_codecs.c	/^static int get_one_bits_MSB(cram_block *block) {$/;"	f	file:
get_severity_tag	hts.c	/^static char get_severity_tag(enum htsLogLevel severity)$/;"	f	file:
get_tid	tbx.c	/^static inline int get_tid(tbx_t *tbx, const char *ss, int is_add)$/;"	f	file:
get_type_name	vcf.c	/^static const char *get_type_name(int type) {$/;"	f	file:
get_zero_bits_MSB	cram/cram_codecs.c	/^static int get_zero_bits_MSB(cram_block *block) {$/;"	f	file:
gettid	cram/cram_io.c	78;"	d	file:
grp	bcf_sr_sort.h	/^    grp_t *grp;             \/\/ list of VCF representatives, each with a unique combination of duplicate lines$/;"	m	struct:__anon118
grp_create_key	bcf_sr_sort.c	/^char *grp_create_key(sr_sort_t *srt)$/;"	f
grp_str2int	bcf_sr_sort.h	/^    void *grp_str2int;$/;"	m	struct:__anon118
grp_t	bcf_sr_sort.h	/^grp_t;$/;"	t	typeref:struct:__anon116
gz_def_cnt	cram/cram_structs.h	/^    int gz_def_cnt;$/;"	m	struct:__anon80
gz_def_extra	cram/cram_structs.h	/^    double gz_def_extra;$/;"	m	struct:__anon80
gz_rle_cnt	cram/cram_structs.h	/^    int gz_rle_cnt;$/;"	m	struct:__anon80
gz_rle_extra	cram/cram_structs.h	/^    double gz_rle_extra;$/;"	m	struct:__anon80
gz_stream	htslib/bgzf.h	/^    z_stream *gz_stream;\/\/ for gzip-compressed files$/;"	m	struct:BGZF
gzi	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
gzip	htslib/hts.h	/^    no_compression, gzip, bgzf, custom,$/;"	e	enum:htsCompression
h	cram/cram_decode.c	/^    SAM_hdr *h;$/;"	m	struct:__anon95	file:
h	cram/cram_structs.h	/^    khash_t(m_i2i) *h;$/;"	m	struct:cram_stats
h	cram/sam_header.h	/^    khash_t(sam_hdr) *h;$/;"	m	struct:__anon65
hFILE	htslib/hfile.h	/^typedef struct hFILE {$/;"	s
hFILE	htslib/hfile.h	/^} hFILE;$/;"	t	typeref:struct:hFILE
hFILE_backend	hfile_internal.h	/^struct hFILE_backend {$/;"	s
hFILE_callback_ops	htslib/hfile.h	/^typedef struct  hFILE_callback_ops {$/;"	s
hFILE_callback_ops	htslib/hfile.h	/^} hFILE_callback_ops;$/;"	t	typeref:struct:hFILE_callback_ops
hFILE_cb	hfile.c	/^} hFILE_cb;$/;"	t	typeref:struct:__anon108	file:
hFILE_fd	hfile.c	/^} hFILE_fd;$/;"	t	typeref:struct:__anon107	file:
hFILE_libcurl	hfile_libcurl.c	/^} hFILE_libcurl;$/;"	t	typeref:struct:__anon100	file:
hFILE_mem	hfile.c	/^} hFILE_mem;$/;"	t	typeref:struct:__anon109	file:
hFILE_multipart	multipart.c	/^} hFILE_multipart;$/;"	t	typeref:struct:__anon104	file:
hFILE_net	hfile_net.c	/^} hFILE_net;$/;"	t	typeref:struct:__anon42	file:
hFILE_plugin	hfile_internal.h	/^struct hFILE_plugin {$/;"	s
hFILE_plugin_list	hfile.c	/^struct hFILE_plugin_list {$/;"	s	file:
hFILE_scheme_handler	hfile_internal.h	/^struct hFILE_scheme_handler {$/;"	s
h_meta	cram/cram_structs.h	/^    khash_t(refs) *h_meta; \/\/ ref_entry*, index by name$/;"	m	struct:__anon93
has_errno	htslib/hfile.h	/^    int has_errno;$/;"	m	struct:hFILE
has_filter	synced_bcf_reader.c	/^static inline int has_filter(bcf_sr_t *reader, bcf1_t *line)$/;"	f	file:
has_line	htslib/synced_bcf_reader.h	/^    int *has_line;      \/\/ Corresponds to return value of bcf_sr_next_line but is not limited by sizeof(int). Use bcf_sr_has_line macro to query.$/;"	m	struct:__anon31
hclearerr	htslib/hfile.h	/^static inline void hclearerr(hFILE *fp)$/;"	f
hclose	hfile.c	/^int hclose(hFILE *fp)$/;"	f
hclose_abruptly	hfile.c	/^void hclose_abruptly(hFILE *fp)$/;"	f
hdopen	hfile.c	/^hFILE *hdopen(int fd, const char *mode)$/;"	f
hdr	cram/cram_structs.h	/^    cram_block_slice_hdr *hdr;$/;"	m	struct:cram_slice
hdr	vcf_sweep.c	/^    bcf_hdr_t *hdr;$/;"	m	struct:_bcf_sweep_t	file:
hdr_block	cram/cram_structs.h	/^    cram_block *hdr_block;$/;"	m	struct:cram_slice
hdr_from_dict	sam.c	/^static bam_hdr_t *hdr_from_dict(sdict_t *d)$/;"	f	file:
hdrlist	hfile_libcurl.c	/^} hdrlist;$/;"	t	typeref:struct:__anon98	file:
head	sam.c	/^    lbnode_t *head, *tail;$/;"	m	struct:__bam_plp_t	file:
header	cram/cram_structs.h	/^    SAM_hdr       *header;$/;"	m	struct:cram_fd
header	htslib/synced_bcf_reader.h	/^    bcf_hdr_t *header;$/;"	m	struct:__anon29
header_error	htslib/synced_bcf_reader.h	/^    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error$/;"	e	enum:__anon30
header_only	tabix.c	/^    int print_header, header_only;$/;"	m	struct:__anon97	file:
headers	hfile_libcurl.c	/^    http_headers headers;$/;"	m	struct:__anon100	file:
headers	hfile_s3.c	/^    char *headers[3];$/;"	m	struct:__anon53	file:
headers	multipart.c	/^    char **headers;$/;"	m	struct:hfile_part	file:
herrno	htslib/hfile.h	/^static inline int herrno(hFILE *fp)$/;"	f
hfile	htslib/hts.h	/^        struct hFILE *hfile;$/;"	m	union:__anon9::__anon10	typeref:struct:__anon9::__anon10::hFILE
hfile_add_scheme_handler	hfile.c	/^void hfile_add_scheme_handler(const char *scheme,$/;"	f
hfile_always_local	hfile.c	/^int hfile_always_local (const char *fname) { return 0; }$/;"	f
hfile_always_remote	hfile.c	/^int hfile_always_remote(const char *fname) { return 1; }$/;"	f
hfile_destroy	hfile.c	/^void hfile_destroy(hFILE *fp)$/;"	f
hfile_exit	hfile.c	/^static void hfile_exit()$/;"	f	file:
hfile_init	hfile.c	/^hFILE *hfile_init(size_t struct_size, const char *mode, size_t capacity)$/;"	f
hfile_init_fixed	hfile.c	/^hFILE *hfile_init_fixed(size_t struct_size, const char *mode,$/;"	f
hfile_internal_h	Makefile	/^hfile_internal_h = hfile_internal.h $(htslib_hfile_h)$/;"	m
hfile_oflags	hfile.c	/^int hfile_oflags(const char *mode)$/;"	f
hfile_part	multipart.c	/^typedef struct hfile_part {$/;"	s	file:
hfile_part	multipart.c	/^} hfile_part;$/;"	t	typeref:struct:hfile_part	file:
hfile_plugin_init_net	hfile_net.c	/^int hfile_plugin_init_net(struct hFILE_plugin *self)$/;"	f
hfile_set_blksize	hfile.c	/^int hfile_set_blksize(hFILE *fp, size_t bufsiz) {$/;"	f
hflush	hfile.c	/^int hflush(hFILE *fp)$/;"	f
hgacc_t	kfunc.c	/^} hgacc_t;$/;"	t	typeref:struct:__anon7	file:
hgetc	htslib/hfile.h	/^static inline int hgetc(hFILE *fp)$/;"	f
hgetc2	hfile.c	/^int hgetc2(hFILE *fp)$/;"	f
hgetdelim	hfile.c	/^ssize_t hgetdelim(char *buffer, size_t size, int delim, hFILE *fp)$/;"	f
hgetln	htslib/hfile.h	/^hgetln(char *buffer, size_t size, hFILE *fp)$/;"	f
hgets	hfile.c	/^char *hgets(char *buffer, int size, hFILE *fp)$/;"	f
hi	md5.c	/^	hts_md5_u32plus lo, hi;$/;"	m	struct:hts_md5_context	file:
hisremote	hfile.c	/^int hisremote(const char *fname)$/;"	f
hit_eof	bgzf.c	/^    int hit_eof;  \/\/ r\/w entirely within main thread$/;"	m	struct:bgzf_mtaux_t	file:
hit_eof	bgzf.c	/^    int hit_eof;$/;"	m	struct:bgzf_job	file:
hopen	hfile.c	/^hFILE *hopen(const char *fname, const char *mode, ...)$/;"	f
hopen_callback	hfile.c	/^hFILE *hopen_callback(hFILE_callback_ops ops, const char* mode)$/;"	f
hopen_fd	hfile.c	/^static hFILE *hopen_fd(const char *filename, const char *mode)$/;"	f	file:
hopen_fd_fileuri	hfile.c	/^static hFILE *hopen_fd_fileuri(const char *url, const char *mode)$/;"	f	file:
hopen_fd_stdinout	hfile.c	/^static hFILE *hopen_fd_stdinout(const char *mode)$/;"	f	file:
hopen_htsget_redirect	multipart.c	/^hFILE *hopen_htsget_redirect(hFILE *hfile, const char *mode)$/;"	f
hopen_libcurl	hfile_libcurl.c	/^static hFILE *hopen_libcurl(const char *url, const char *modes)$/;"	f	file:
hopen_mem	hfile.c	/^static hFILE *hopen_mem(const char *url, const char *mode)$/;"	f	file:
hopen_net	hfile_net.c	/^hFILE *hopen_net(const char *filename, const char *mode)$/;"	f
hopen_unknown_scheme	hfile.c	/^static hFILE *hopen_unknown_scheme(const char *fname, const char *mode)$/;"	f	file:
host	htslib/knetfile.h	/^	char *host, *port;$/;"	m	struct:knetFile_s
hpeek	hfile.c	/^ssize_t hpeek(hFILE *fp, void *buffer, size_t nbytes)$/;"	f
hputc	htslib/hfile.h	/^static inline int hputc(int c, hFILE *fp)$/;"	f
hputc2	hfile.c	/^int hputc2(int c, hFILE *fp)$/;"	f
hputs	htslib/hfile.h	/^static inline int hputs(const char *text, hFILE *fp)$/;"	f
hputs2	hfile.c	/^int hputs2(const char *text, size_t totalbytes, size_t ncopied, hFILE *fp)$/;"	f
hread	htslib/hfile.h	/^hread(hFILE *fp, void *buffer, size_t nbytes)$/;"	f
hread2	hfile.c	/^ssize_t hread2(hFILE *fp, void *destv, size_t nbytes, size_t nread)$/;"	f
hread_uint64	bgzf.c	/^static inline int hread_uint64(uint64_t *xptr, hFILE *f)$/;"	f	file:
hrec	htslib/vcf.h	/^    bcf_hrec_t **hrec;$/;"	m	struct:__anon19
hrec	htslib/vcf.h	/^    bcf_hrec_t *hrec[3];$/;"	m	struct:__anon17
hrec_add_idx	vcf.c	/^void hrec_add_idx(bcf_hrec_t *hrec, int idx)$/;"	f
hseek	hfile.c	/^off_t hseek(hFILE *fp, off_t offset, int whence)$/;"	f
htell	htslib/hfile.h	/^static inline off_t htell(hFILE *fp)$/;"	f
htsCompression	htslib/hts.h	/^enum htsCompression {$/;"	g
htsExactFormat	htslib/hts.h	/^enum htsExactFormat {$/;"	g
htsFile	htslib/hts.h	/^} htsFile;$/;"	t	typeref:struct:__anon9
htsFormat	htslib/hts.h	/^typedef struct htsFormat {$/;"	s
htsFormat	htslib/hts.h	/^} htsFormat;$/;"	t	typeref:struct:htsFormat
htsFormatCategory	htslib/hts.h	/^enum htsFormatCategory {$/;"	g
htsLogLevel	htslib/hts_log.h	/^enum htsLogLevel {$/;"	g
htsThreadPool	htslib/hts.h	/^} htsThreadPool;$/;"	t	typeref:struct:__anon11
hts_base64_decoded_length	textutils.c	/^size_t hts_base64_decoded_length(size_t len)$/;"	f
hts_bin_bot	htslib/hts.h	/^static inline int hts_bin_bot(int bin, int n_lvls)$/;"	f
hts_bin_first	htslib/hts.h	544;"	d
hts_bin_parent	htslib/hts.h	545;"	d
hts_check_EOF	hts.c	/^int hts_check_EOF(htsFile *fp)$/;"	f
hts_close	hts.c	/^int hts_close(htsFile *fp)$/;"	f
hts_cram_idx_t	hts_internal.h	/^typedef struct hts_cram_idx_t {$/;"	s
hts_cram_idx_t	hts_internal.h	/^} hts_cram_idx_t;$/;"	t	typeref:struct:hts_cram_idx_t
hts_decode_base64	textutils.c	/^int hts_decode_base64(char *dest, size_t *destlen, const char *s)$/;"	f
hts_decode_percent	textutils.c	/^int hts_decode_percent(char *dest, size_t *destlen, const char *s)$/;"	f
hts_detect_format	hts.c	/^int hts_detect_format(hFILE *hfile, htsFormat *fmt)$/;"	f
hts_drand48	hts_os.c	/^double hts_drand48(void) { return drand48(); }$/;"	f
hts_drand48	win/rand.c	/^hts_drand48(void)$/;"	f
hts_erand48	hts_os.c	/^double hts_erand48(unsigned short xseed[3]) { return erand48(xseed); }$/;"	f
hts_erand48	win/rand.c	/^hts_erand48(unsigned short xseed[3])$/;"	f
hts_expand	htslib/hts.h	83;"	d
hts_expand0	htslib/hts.h	112;"	d
hts_file_type	hts.c	/^int hts_file_type(const char *fname)$/;"	f
hts_fmt_option	htslib/hts.h	/^enum hts_fmt_option {$/;"	g
hts_format_description	hts.c	/^char *hts_format_description(const htsFormat *format)$/;"	f
hts_format_file_extension	hts.c	/^const char *hts_format_file_extension(const htsFormat *format) {$/;"	f
hts_get_bgzfp	hts.c	/^BGZF *hts_get_bgzfp(htsFile *fp)$/;"	f
hts_get_format	hts.c	/^const htsFormat *hts_get_format(htsFile *fp)$/;"	f
hts_get_log_level	hts.c	/^enum htsLogLevel hts_get_log_level()$/;"	f
hts_getline	hts.c	/^int hts_getline(htsFile *fp, int delimiter, kstring_t *str)$/;"	f
hts_hfile	hts.c	/^static hFILE *hts_hfile(htsFile *fp) {$/;"	f	file:
hts_hopen	hts.c	/^htsFile *hts_hopen(hFILE *hfile, const char *fn, const char *mode)$/;"	f
hts_httphdr_callback	hfile_internal.h	/^typedef int (* hts_httphdr_callback) (void *cb_data, char ***hdrs);$/;"	t
hts_id2name_f	htslib/hts.h	/^    typedef const char *(*hts_id2name_f)(void*, int);$/;"	t
hts_idx_destroy	hts.c	/^void hts_idx_destroy(hts_idx_t *idx)$/;"	f
hts_idx_finish	hts.c	/^void hts_idx_finish(hts_idx_t *idx, uint64_t final_offset)$/;"	f
hts_idx_get_meta	hts.c	/^uint8_t *hts_idx_get_meta(hts_idx_t *idx, uint32_t *l_meta)$/;"	f
hts_idx_get_n_no_coor	hts.c	/^uint64_t hts_idx_get_n_no_coor(const hts_idx_t* idx)$/;"	f
hts_idx_get_stat	hts.c	/^int hts_idx_get_stat(const hts_idx_t* idx, int tid, uint64_t* mapped, uint64_t* unmapped)$/;"	f
hts_idx_getfn	hts.c	/^char *hts_idx_getfn(const char *fn, const char *ext)$/;"	f
hts_idx_init	hts.c	/^hts_idx_t *hts_idx_init(int n, int fmt, uint64_t offset0, int min_shift, int n_lvls)$/;"	f
hts_idx_load	hts.c	/^hts_idx_t *hts_idx_load(const char *fn, int fmt)$/;"	f
hts_idx_load2	hts.c	/^hts_idx_t *hts_idx_load2(const char *fn, const char *fnidx)$/;"	f
hts_idx_load_core	hts.c	/^static int hts_idx_load_core(hts_idx_t *idx, BGZF *fp, int fmt)$/;"	f	file:
hts_idx_load_local	hts.c	/^static hts_idx_t *hts_idx_load_local(const char *fn)$/;"	f	file:
hts_idx_push	hts.c	/^int hts_idx_push(hts_idx_t *idx, int tid, int beg, int end, uint64_t offset, int is_mapped)$/;"	f
hts_idx_save	hts.c	/^int hts_idx_save(const hts_idx_t *idx, const char *fn, int fmt)$/;"	f
hts_idx_save_as	hts.c	/^int hts_idx_save_as(const hts_idx_t *idx, const char *fn, const char *fnidx, int fmt)$/;"	f
hts_idx_save_core	hts.c	/^static int hts_idx_save_core(const hts_idx_t *idx, BGZF *fp, int fmt)$/;"	f	file:
hts_idx_seqnames	hts.c	/^const char **hts_idx_seqnames(const hts_idx_t *idx, int *n, hts_id2name_f getid, void *hdr)$/;"	f
hts_idx_set_meta	hts.c	/^int hts_idx_set_meta(hts_idx_t *idx, uint32_t l_meta, uint8_t *meta,$/;"	f
hts_idx_t	htslib/hts.h	/^typedef struct __hts_idx_t hts_idx_t;$/;"	t	typeref:struct:__hts_idx_t
hts_internal_h	Makefile	/^hts_internal_h = hts_internal.h $(htslib_hts_h)$/;"	m
hts_itr_destroy	hts.c	/^void hts_itr_destroy(hts_itr_t *iter)$/;"	f
hts_itr_next	hts.c	/^int hts_itr_next(BGZF *fp, hts_itr_t *iter, void *r, void *data)$/;"	f
hts_itr_query	hts.c	/^hts_itr_t *hts_itr_query(const hts_idx_t *idx, int tid, int beg, int end, hts_readrec_func *readrec)$/;"	f
hts_itr_query_func	htslib/hts.h	/^    typedef hts_itr_t *hts_itr_query_func(const hts_idx_t *idx, int tid, int beg, int end, hts_readrec_func *readrec);$/;"	t
hts_itr_querys	hts.c	/^hts_itr_t *hts_itr_querys(const hts_idx_t *idx, const char *reg, hts_name2id_f getid, void *hdr, hts_itr_query_func *itr_query, hts_readrec_func *readrec)$/;"	f
hts_itr_t	htslib/hts.h	/^} hts_itr_t;$/;"	t	typeref:struct:__anon14
hts_json_fnext	textutils.c	/^char hts_json_fnext(struct hFILE *fp, hts_json_token *token, kstring_t *kstr)$/;"	f
hts_json_fskip_value	textutils.c	/^char hts_json_fskip_value(struct hFILE *fp, char type)$/;"	f
hts_json_nextfn	textutils.c	/^typedef char hts_json_nextfn(void *arg1, void *arg2, hts_json_token *token);$/;"	t	file:
hts_json_snext	textutils.c	/^char hts_json_snext(char *str, size_t *state, hts_json_token *token)$/;"	f
hts_json_sskip_value	textutils.c	/^char hts_json_sskip_value(char *str, size_t *state, char type)$/;"	f
hts_json_token	hts_internal.h	/^typedef struct hts_json_token {$/;"	s
hts_json_token	hts_internal.h	/^} hts_json_token;$/;"	t	typeref:struct:hts_json_token
hts_log	hts.c	/^void hts_log(enum htsLogLevel severity, const char *context, const char *format, ...)$/;"	f
hts_log_debug	htslib/hts_log.h	84;"	d
hts_log_error	htslib/hts_log.h	75;"	d
hts_log_info	htslib/hts_log.h	81;"	d
hts_log_trace	htslib/hts_log.h	87;"	d
hts_log_warning	htslib/hts_log.h	78;"	d
hts_lrand48	hts_os.c	/^double hts_lrand48(void) { return lrand48(); }$/;"	f
hts_lrand48	win/rand.c	/^hts_lrand48(void)$/;"	f
hts_md5_context	htslib/hts.h	/^    typedef struct hts_md5_context hts_md5_context;$/;"	t	typeref:struct:hts_md5_context
hts_md5_context	md5.c	/^struct hts_md5_context {$/;"	s	file:
hts_md5_destroy	md5.c	/^void hts_md5_destroy(hts_md5_context *ctx)$/;"	f
hts_md5_final	md5.c	/^void hts_md5_final(unsigned char *result, hts_md5_context *ctx)$/;"	f
hts_md5_hex	md5.c	/^void hts_md5_hex(char *hex, const unsigned char *digest)$/;"	f
hts_md5_init	md5.c	/^hts_md5_context *hts_md5_init(void)$/;"	f
hts_md5_reset	md5.c	/^void hts_md5_reset(hts_md5_context *ctx)$/;"	f
hts_md5_u32plus	md5.c	/^typedef unsigned int hts_md5_u32plus;$/;"	t	file:
hts_md5_update	md5.c	/^void hts_md5_update(hts_md5_context *ctx, const void *data, unsigned long size)$/;"	f
hts_name2id_f	htslib/hts.h	/^    typedef int (*hts_name2id_f)(void*, const char*);$/;"	t
hts_open	hts.c	/^htsFile *hts_open(const char *fn, const char *mode) {$/;"	f
hts_open_callback	hts.c	/^htsFile *hts_open_callback(const char* fn, hFILE_callback_ops* ops, const char* mode)$/;"	f
hts_open_format	hts.c	/^htsFile *hts_open_format(const char *fn, const char *mode, const htsFormat *fmt)$/;"	f
hts_open_format_impl	hts.c	/^static htsFile *hts_open_format_impl(const char *fn, const char *mode, const htsFormat *fmt, hFILE* hf)$/;"	f	file:
hts_opt	htslib/hts.h	/^typedef struct hts_opt {$/;"	s
hts_opt	htslib/hts.h	/^} hts_opt;$/;"	t	typeref:struct:hts_opt
hts_opt_add	hts.c	/^int hts_opt_add(hts_opt **opts, const char *c_arg) {$/;"	f
hts_opt_apply	hts.c	/^int hts_opt_apply(htsFile *fp, hts_opt *opts) {$/;"	f
hts_opt_free	hts.c	/^void hts_opt_free(hts_opt *opts) {$/;"	f
hts_pair64_t	htslib/hts.h	/^} hts_pair64_t;$/;"	t	typeref:struct:__anon13
hts_parse_decimal	hts.c	/^long long hts_parse_decimal(const char *str, char **strend, int flags)$/;"	f
hts_parse_format	hts.c	/^int hts_parse_format(htsFormat *format, const char *str) {$/;"	f
hts_parse_opt_list	hts.c	/^int hts_parse_opt_list(htsFormat *fmt, const char *str) {$/;"	f
hts_parse_reg	hts.c	/^const char *hts_parse_reg(const char *s, int *beg, int *end)$/;"	f
hts_path_itr	hts_internal.h	/^struct hts_path_itr {$/;"	s
hts_path_itr_next	plugin.c	/^const char *hts_path_itr_next(struct hts_path_itr *itr)$/;"	f
hts_path_itr_setup	plugin.c	/^void hts_path_itr_setup(struct hts_path_itr *itr, const char *path,$/;"	f
hts_process_opts	hts.c	/^static int hts_process_opts(htsFile *fp, const char *opts) {$/;"	f	file:
hts_readlines	hts.c	/^char **hts_readlines(const char *fn, int *_n)$/;"	f
hts_readlist	hts.c	/^char **hts_readlist(const char *string, int is_file, int *_n)$/;"	f
hts_readrec_func	htslib/hts.h	/^typedef int hts_readrec_func(BGZF *fp, void *data, void *r, int *tid, int *beg, int *end);$/;"	t
hts_realloc_or_die	hts.c	/^size_t hts_realloc_or_die(size_t n, size_t m, size_t m_sz, size_t size,$/;"	f
hts_reg2bin	htslib/hts.h	/^static inline int hts_reg2bin(int64_t beg, int64_t end, int min_shift, int n_lvls)$/;"	f
hts_set_cache_size	hts.c	/^void hts_set_cache_size(htsFile *fp, int n)$/;"	f
hts_set_fai_filename	hts.c	/^int hts_set_fai_filename(htsFile *fp, const char *fn_aux)$/;"	f
hts_set_log_level	hts.c	/^void hts_set_log_level(enum htsLogLevel level)$/;"	f
hts_set_opt	hts.c	/^int hts_set_opt(htsFile *fp, enum hts_fmt_option opt, ...) {$/;"	f
hts_set_thread_pool	hts.c	/^int hts_set_thread_pool(htsFile *fp, htsThreadPool *p) {$/;"	f
hts_set_threads	hts.c	/^int hts_set_threads(htsFile *fp, int n)$/;"	f
hts_srand48	hts_os.c	/^void hts_srand48(long seed) { return srand48(seed); }$/;"	f
hts_srand48	win/rand.c	/^hts_srand48(long seed)$/;"	f
hts_tpool	htslib/thread_pool.h	/^typedef struct hts_tpool hts_tpool;$/;"	t	typeref:struct:hts_tpool
hts_tpool	thread_pool_internal.h	/^struct hts_tpool {$/;"	s
hts_tpool_add_result	thread_pool.c	/^static int hts_tpool_add_result(hts_tpool_job *j, void *data) {$/;"	f	file:
hts_tpool_delete_result	thread_pool.c	/^void hts_tpool_delete_result(hts_tpool_result *r, int free_data) {$/;"	f
hts_tpool_destroy	thread_pool.c	/^void hts_tpool_destroy(hts_tpool *p) {$/;"	f
hts_tpool_dispatch	thread_pool.c	/^int hts_tpool_dispatch(hts_tpool *p, hts_tpool_process *q,$/;"	f
hts_tpool_dispatch2	thread_pool.c	/^int hts_tpool_dispatch2(hts_tpool *p, hts_tpool_process *q,$/;"	f
hts_tpool_init	thread_pool.c	/^hts_tpool *hts_tpool_init(int n) {$/;"	f
hts_tpool_job	thread_pool_internal.h	/^typedef struct hts_tpool_job {$/;"	s
hts_tpool_job	thread_pool_internal.h	/^} hts_tpool_job;$/;"	t	typeref:struct:hts_tpool_job
hts_tpool_kill	thread_pool.c	/^void hts_tpool_kill(hts_tpool *p) {$/;"	f
hts_tpool_next_result	thread_pool.c	/^hts_tpool_result *hts_tpool_next_result(hts_tpool_process *q) {$/;"	f
hts_tpool_next_result_locked	thread_pool.c	/^static hts_tpool_result *hts_tpool_next_result_locked(hts_tpool_process *q) {$/;"	f	file:
hts_tpool_next_result_wait	thread_pool.c	/^hts_tpool_result *hts_tpool_next_result_wait(hts_tpool_process *q) {$/;"	f
hts_tpool_process	htslib/thread_pool.h	/^typedef struct hts_tpool_process hts_tpool_process;$/;"	t	typeref:struct:hts_tpool_process
hts_tpool_process	thread_pool_internal.h	/^struct hts_tpool_process {$/;"	s
hts_tpool_process_attach	thread_pool.c	/^void hts_tpool_process_attach(hts_tpool *p, hts_tpool_process *q) {$/;"	f
hts_tpool_process_destroy	thread_pool.c	/^void hts_tpool_process_destroy(hts_tpool_process *q) {$/;"	f
hts_tpool_process_detach	thread_pool.c	/^void hts_tpool_process_detach(hts_tpool *p, hts_tpool_process *q) {$/;"	f
hts_tpool_process_empty	thread_pool.c	/^int hts_tpool_process_empty(hts_tpool_process *q) {$/;"	f
hts_tpool_process_flush	thread_pool.c	/^int hts_tpool_process_flush(hts_tpool_process *q) {$/;"	f
hts_tpool_process_init	thread_pool.c	/^hts_tpool_process *hts_tpool_process_init(hts_tpool *p, int qsize, int in_only) {$/;"	f
hts_tpool_process_len	thread_pool.c	/^int hts_tpool_process_len(hts_tpool_process *q) {$/;"	f
hts_tpool_process_qsize	thread_pool.c	/^int hts_tpool_process_qsize(hts_tpool_process *q) {$/;"	f
hts_tpool_process_ref_decr	thread_pool.c	/^void hts_tpool_process_ref_decr(hts_tpool_process *q) {$/;"	f
hts_tpool_process_ref_incr	thread_pool.c	/^void hts_tpool_process_ref_incr(hts_tpool_process *q) {$/;"	f
hts_tpool_process_reset	thread_pool.c	/^int hts_tpool_process_reset(hts_tpool_process *q, int free_results) {$/;"	f
hts_tpool_process_shutdown	thread_pool.c	/^void hts_tpool_process_shutdown(hts_tpool_process *q) {$/;"	f
hts_tpool_process_sz	thread_pool.c	/^int hts_tpool_process_sz(hts_tpool_process *q) {$/;"	f
hts_tpool_result	htslib/thread_pool.h	/^typedef struct hts_tpool_result hts_tpool_result;$/;"	t	typeref:struct:hts_tpool_result
hts_tpool_result	thread_pool_internal.h	/^struct hts_tpool_result {$/;"	s
hts_tpool_result_data	thread_pool.c	/^void *hts_tpool_result_data(hts_tpool_result *r) {$/;"	f
hts_tpool_size	thread_pool.c	/^int hts_tpool_size(hts_tpool *p) {$/;"	f
hts_tpool_wake_dispatch	thread_pool.c	/^void hts_tpool_wake_dispatch(hts_tpool_process *q) {$/;"	f
hts_tpool_worker	thread_pool_internal.h	/^} hts_tpool_worker;$/;"	t	typeref:struct:__anon6
hts_useek	hts.c	/^int hts_useek(htsFile *fp, long uoffset, int where)$/;"	f
hts_utell	hts.c	/^long hts_utell(htsFile *fp)$/;"	f
hts_verbose	hts.c	/^int hts_verbose = HTS_LOG_WARNING;$/;"	v
hts_version	hts.c	/^const char *hts_version()$/;"	f
htsget	htslib/hts.h	/^    htsget,$/;"	e	enum:htsExactFormat
htslib_bgzf_h	htslib_vars.mk	/^htslib_bgzf_h = $(HTSPREFIX)htslib\/bgzf.h $(htslib_hts_defs_h)$/;"	m
htslib_cram_h	htslib_vars.mk	/^htslib_cram_h = $(HTSPREFIX)htslib\/cram.h $(htslib_hts_h)$/;"	m
htslib_default_libs	Makefile	/^htslib_default_libs = -lz -lm -lbz2 -llzma$/;"	m
htslib_faidx_h	htslib_vars.mk	/^htslib_faidx_h = $(HTSPREFIX)htslib\/faidx.h $(htslib_hts_defs_h)$/;"	m
htslib_hfile_h	htslib_vars.mk	/^htslib_hfile_h = $(HTSPREFIX)htslib\/hfile.h $(htslib_hts_defs_h)$/;"	m
htslib_hts_defs_h	htslib_vars.mk	/^htslib_hts_defs_h = $(HTSPREFIX)htslib\/hts_defs.h$/;"	m
htslib_hts_endian_h	htslib_vars.mk	/^htslib_hts_endian_h = $(HTSPREFIX)htslib\/hts_endian.h$/;"	m
htslib_hts_h	htslib_vars.mk	/^htslib_hts_h = $(HTSPREFIX)htslib\/hts.h $(htslib_hts_defs_h) $(htslib_hts_log_h)$/;"	m
htslib_hts_log_h	htslib_vars.mk	/^htslib_hts_log_h = $(HTSPREFIX)htslib\/hts_log.h$/;"	m
htslib_kbitset_h	htslib_vars.mk	/^htslib_kbitset_h = $(HTSPREFIX)htslib\/kbitset.h$/;"	m
htslib_kfunc_h	htslib_vars.mk	/^htslib_kfunc_h = $(HTSPREFIX)htslib\/kfunc.h$/;"	m
htslib_khash_h	htslib_vars.mk	/^htslib_khash_h = $(HTSPREFIX)htslib\/khash.h$/;"	m
htslib_khash_str2int_h	htslib_vars.mk	/^htslib_khash_str2int_h = $(HTSPREFIX)htslib\/khash_str2int.h $(htslib_khash_h)$/;"	m
htslib_klist_h	htslib_vars.mk	/^htslib_klist_h = $(HTSPREFIX)htslib\/klist.h$/;"	m
htslib_knetfile_h	htslib_vars.mk	/^htslib_knetfile_h = $(HTSPREFIX)htslib\/knetfile.h$/;"	m
htslib_kseq_h	htslib_vars.mk	/^htslib_kseq_h = $(HTSPREFIX)htslib\/kseq.h$/;"	m
htslib_ksort_h	htslib_vars.mk	/^htslib_ksort_h = $(HTSPREFIX)htslib\/ksort.h$/;"	m
htslib_kstring_h	htslib_vars.mk	/^htslib_kstring_h = $(HTSPREFIX)htslib\/kstring.h$/;"	m
htslib_regidx_h	htslib_vars.mk	/^htslib_regidx_h = $(HTSPREFIX)htslib\/regidx.h$/;"	m
htslib_sam_h	htslib_vars.mk	/^htslib_sam_h = $(HTSPREFIX)htslib\/sam.h $(htslib_hts_h)$/;"	m
htslib_synced_bcf_reader_h	htslib_vars.mk	/^htslib_synced_bcf_reader_h = $(HTSPREFIX)htslib\/synced_bcf_reader.h $(htslib_hts_h) $(htslib_vcf_h) $(htslib_tbx_h)$/;"	m
htslib_tbx_h	htslib_vars.mk	/^htslib_tbx_h = $(HTSPREFIX)htslib\/tbx.h $(htslib_hts_h)$/;"	m
htslib_thread_pool_h	htslib_vars.mk	/^htslib_thread_pool_h = $(HTSPREFIX)htslib\/thread_pool.h$/;"	m
htslib_vcf_h	htslib_vars.mk	/^htslib_vcf_h = $(HTSPREFIX)htslib\/vcf.h $(htslib_hts_h) $(htslib_kstring_h) $(htslib_hts_defs_h) $(htslib_hts_endian_h)$/;"	m
htslib_vcf_sweep_h	htslib_vars.mk	/^htslib_vcf_sweep_h = $(HTSPREFIX)htslib\/vcf_sweep.h $(htslib_hts_h) $(htslib_vcf_h)$/;"	m
htslib_vcfutils_h	htslib_vars.mk	/^htslib_vcfutils_h = $(HTSPREFIX)htslib\/vcfutils.h $(htslib_vcf_h)$/;"	m
http_headers	hfile_libcurl.c	/^} http_headers;$/;"	t	typeref:struct:__anon99	file:
http_host	htslib/knetfile.h	/^	char *path, *http_host;$/;"	m	struct:knetFile_s
http_status_errno	hfile_libcurl.c	/^static int http_status_errno(int status)$/;"	f	file:
huffman	cram/cram_codecs.h	/^	cram_huffman_decoder         huffman;$/;"	m	union:cram_codec::__anon78
hwrite	htslib/hfile.h	/^hwrite(hFILE *fp, const void *buffer, size_t nbytes)$/;"	f
hwrite2	hfile.c	/^ssize_t hwrite2(hFILE *fp, const void *srcv, size_t totalbytes, size_t ncopied)$/;"	f
hwrite_uint64	bgzf.c	/^static inline int hwrite_uint64(uint64_t x, hFILE *f)$/;"	f	file:
hypergeo	kfunc.c	/^static double hypergeo(int n11, int n1_, int n_1, int n)$/;"	f	file:
hypergeo_acc	kfunc.c	/^static double hypergeo_acc(int n11, int n1_, int n_1, int n, hgacc_t *aux)$/;"	f	file:
i	cram/cram_structs.h	/^	} i;$/;"	m	union:cram_feature::__anon81	typeref:struct:cram_feature::__anon81::__anon88
i	cram/cram_structs.h	/^    int i;$/;"	m	union:__anon79
i	htslib/hts.h	/^        int i;$/;"	m	union:hts_opt::__anon12
i	htslib/hts.h	/^    int tid, beg, end, n_off, i;$/;"	m	struct:__anon14
i	htslib/kbitset.h	/^	int i;$/;"	m	struct:kbitset_iter_t
i	htslib/regidx.h	/^    int i, n;$/;"	m	struct:__anon27
i	htslib/sam.h	/^    int64_t i;$/;"	m	union:__anon39
i	htslib/vcf.h	/^        int32_t i; \/\/ integer value$/;"	m	union:__anon22::__anon23
i16	test/hts_endian.c	/^    int16_t  i16;$/;"	m	struct:__anon43	file:
i16_to_le	htslib/hts_endian.h	/^static inline void i16_to_le(int16_t val, uint8_t *buf) {$/;"	f
i32	test/hts_endian.c	/^    int32_t  i32;$/;"	m	struct:__anon44	file:
i32_to_le	htslib/hts_endian.h	/^static inline void i32_to_le(int32_t val, uint8_t *buf) {$/;"	f
i64	test/hts_endian.c	/^    int64_t  i64;$/;"	m	struct:__anon45	file:
i64_to_le	htslib/hts_endian.h	/^static inline void i64_to_le(int64_t val, uint8_t *buf) {$/;"	f
id	cram/sam_header.h	/^    int id;           \/\/ numerical ID$/;"	m	struct:__anon63
id	cram/sam_header.h	/^    int id;           \/\/ numerical ID$/;"	m	struct:__anon64
id	hfile_s3.c	/^    kstring_t id;$/;"	m	struct:__anon53	file:
id	htslib/sam.h	/^    uint64_t id;$/;"	m	struct:__anon38
id	htslib/vcf.h	/^    bcf_idpair_t *id[3];$/;"	m	struct:__anon19
id	htslib/vcf.h	/^    char *id, *als;     \/\/ ID and REF+ALT block (\\0-seperated)$/;"	m	struct:__anon24
id	htslib/vcf.h	/^    int id;             \/\/ id: numeric tag id, the corresponding string is bcf_hdr_t::id[BCF_DT_ID][$id].key$/;"	m	struct:__anon21
id	htslib/vcf.h	/^    int id;$/;"	m	struct:__anon17
id	sam.c	/^    uint64_t id;$/;"	m	struct:__bam_plp_t	file:
identify	htsfile.c	/^enum { identify, view_headers, view_all } mode = identify;$/;"	e	enum:__anon96	file:
idx	cram/cram_structs.h	/^    int32_t  idx; \/* offset into data *\/$/;"	m	struct:cram_block
idx	htslib/bgzf.h	/^    bgzidx_t *idx;      \/\/ BGZF index$/;"	m	struct:BGZF
idx	htslib/tbx.h	/^    hts_idx_t *idx;$/;"	m	struct:__anon35
idx	regidx.c	/^    int *idx, nidx;$/;"	m	struct:__anon41	file:
idx	thread_pool_internal.h	/^    int idx;$/;"	m	struct:__anon6
idx	vcf_sweep.c	/^    uint64_t *idx;          \/\/ uncompressed offsets of VCF\/BCF records$/;"	m	struct:_bcf_sweep_t	file:
idx_build_otf	htslib/bgzf.h	/^    int idx_build_otf;  \/\/ build index on the fly, set by bgzf_index_build_init()$/;"	m	struct:BGZF
idx_done	vcf_sweep.c	/^    int idx_done;           \/\/ the index is built during the first pass$/;"	m	struct:_bcf_sweep_t	file:
idx_format_name	hts.c	/^static char * idx_format_name(int fmt) {$/;"	f	file:
idx_load_failed	htslib/synced_bcf_reader.h	/^    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,$/;"	e	enum:__anon30
idx_suffix	test/test_bgzf.c	/^const char *idx_suffix  = ".gzi";$/;"	v
idx_write_int32	hts.c	/^static inline ssize_t HTS_RESULT_USED idx_write_int32(BGZF *fp, int32_t x)$/;"	f	file:
idx_write_uint32	hts.c	/^static inline ssize_t HTS_RESULT_USED idx_write_uint32(BGZF *fp, uint32_t x)$/;"	f	file:
idx_write_uint64	hts.c	/^static inline ssize_t HTS_RESULT_USED idx_write_uint64(BGZF *fp, uint64_t x)$/;"	f	file:
ignore_md5	cram/cram_structs.h	/^    int ignore_md5;$/;"	m	struct:cram_fd
ignore_sam_err	htslib/sam.h	/^    int32_t n_targets, ignore_sam_err;$/;"	m	struct:__anon36
iidx	vcf_sweep.c	/^    int iidx, nidx, midx;   \/\/ i: current offset; n: used; m: allocated$/;"	m	struct:_bcf_sweep_t	file:
in_only	thread_pool_internal.h	/^    int in_only;                     \/\/ if true, don't queue result up.$/;"	m	struct:hts_tpool_process
includedir	Makefile	/^includedir  = $(prefix)\/include$/;"	m
indel	htslib/sam.h	/^    int indel, level;$/;"	m	struct:__anon40
index	cram/cram_structs.h	/^    cram_index *index;                  \/\/ array, sizeof index_sz$/;"	m	struct:cram_fd
index_file	htslib/hts.h	/^    index_file,       \/\/ Index file associated with some data file$/;"	e	enum:htsFormatCategory
index_sz	cram/cram_structs.h	/^    int         index_sz;$/;"	m	struct:cram_fd
indiv	htslib/vcf.h	/^    kstring_t shared, indiv;$/;"	m	struct:__anon25
indiv_dirty	htslib/vcf.h	/^    int indiv_dirty;    \/\/ if set, indiv.s must be recreated on BCF output$/;"	m	struct:__anon24
inflate_block	bgzf.c	/^static int inflate_block(BGZF* fp, int block_length)$/;"	f	file:
inflate_gzip_block	bgzf.c	/^static int inflate_gzip_block(BGZF *fp, int cached)$/;"	f	file:
info	htslib/vcf.h	/^    bcf_info_t *info;   \/\/ INFO$/;"	m	struct:__anon24
info	htslib/vcf.h	/^    uint32_t info[3];  \/\/ stores Number:20, var:4, Type:4, ColType:4 in info[0..2]$/;"	m	struct:__anon17
init_add_plugin	hfile.c	/^static int init_add_plugin(void *obj, int (*init)(struct hFILE_plugin *),$/;"	f	file:
init_filters	synced_bcf_reader.c	/^static int *init_filters(bcf_hdr_t *hdr, const char *filters, int *nfilters)$/;"	f	file:
init_mstdin	cram/mFILE.c	/^static void init_mstdin(void) {$/;"	f	file:
input_empty_c	thread_pool_internal.h	/^    pthread_cond_t input_empty_c;    \/\/ Input queue has become empty$/;"	m	struct:hts_tpool_process
input_head	thread_pool_internal.h	/^    hts_tpool_job    *input_head;    \/\/ input list$/;"	m	struct:hts_tpool_process
input_not_full_c	thread_pool_internal.h	/^    pthread_cond_t input_not_full_c; \/\/ Input queue is no longer full$/;"	m	struct:hts_tpool_process
input_tail	thread_pool_internal.h	/^    hts_tpool_job    *input_tail;$/;"	m	struct:hts_tpool_process
insert_to_b	hts.c	/^static inline int insert_to_b(bidx_t *b, int bin, uint64_t beg, uint64_t end)$/;"	f	file:
insert_to_l	hts.c	/^static inline int insert_to_l(lidx_t *l, int64_t _beg, int64_t _end, uint64_t offset, int min_shift)$/;"	f	file:
int32_decode	cram/cram_io.c	/^int int32_decode(cram_fd *fd, int32_t *val) {$/;"	f
int32_encode	cram/cram_io.c	/^int int32_encode(cram_fd *fd, int32_t val) {$/;"	f
int32_get_blk	cram/cram_io.c	/^int int32_get_blk(cram_block *b, int32_t *val) {$/;"	f
int32_put_blk	cram/cram_io.c	/^int int32_put_blk(cram_block *b, int32_t val) {$/;"	f
int64tostr	knetfile.c	/^char *int64tostr(char *buf, int64_t x)$/;"	f
io_task	bgzf.c	/^    pthread_t io_task;$/;"	m	struct:bgzf_mtaux_t	file:
is_be	htslib/bgzf.h	/^    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;$/;"	m	struct:BGZF
is_be	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
is_bgzf	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
is_bin	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
is_bin	htslib/synced_bcf_reader.h	/^    int is_bin;             \/\/ is open in binary mode (tabix access)$/;"	m	struct:_bcf_sr_regions_t
is_compressed	htslib/bgzf.h	/^    unsigned last_block_eof:1, is_compressed:1, is_gzip:1;$/;"	m	struct:BGZF
is_cram	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
is_cram	htslib/hts.h	/^    uint32_t read_rest:1, finished:1, is_cram:1, dummy:29;$/;"	m	struct:__anon14
is_del	htslib/sam.h	/^    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, aux:28;$/;"	m	struct:__anon40
is_directory	cram/files.c	/^int is_directory(char * fn)$/;"	f
is_dns_compliant	hfile_s3.c	/^static int is_dns_compliant(const char *s0, const char *slim)$/;"	f	file:
is_eof	sam.c	/^    int is_eof, max_plp, error, maxcnt;$/;"	m	struct:__bam_plp_t	file:
is_escaped	vcf.c	/^static inline int is_escaped(const char *min, const char *str)$/;"	f	file:
is_file	cram/files.c	/^int is_file(char * fn)$/;"	f
is_file_newer	test/test.pl	/^sub is_file_newer$/;"	s
is_gt	vcf.c	/^    uint64_t is_gt:1, max_g:31, max_l:32;$/;"	m	struct:__anon50	file:
is_gzip	htslib/bgzf.h	/^    unsigned last_block_eof:1, is_compressed:1, is_gzip:1;$/;"	m	struct:BGZF
is_head	htslib/sam.h	/^    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, aux:28;$/;"	m	struct:__anon40
is_md5	cram/cram_structs.h	/^    int is_md5;            \/\/ Reference comes from a raw seq found by MD5$/;"	m	struct:ref_entry
is_read	hfile_libcurl.c	/^    unsigned is_read : 1;   \/\/ Opened in read mode$/;"	m	struct:__anon100	file:
is_ready	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
is_refskip	htslib/sam.h	/^    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, aux:28;$/;"	m	struct:__anon40
is_socket	hfile.c	/^    unsigned is_socket:1;$/;"	m	struct:__anon107	file:
is_tail	htslib/sam.h	/^    uint32_t is_del:1, is_head:1, is_tail:1, is_refskip:1, aux:28;$/;"	m	struct:__anon40
is_write	htslib/bgzf.h	/^    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;$/;"	m	struct:BGZF
is_write	htslib/hts.h	/^    uint32_t is_bin:1, is_write:1, is_be:1, is_cram:1, is_bgzf:1, dummy:27;$/;"	m	struct:__anon9
isalnum_c	hts_internal.h	/^static inline int isalnum_c(char c) { return isalnum((unsigned char) c); }$/;"	f
isalpha_c	hts_internal.h	/^static inline int isalpha_c(char c) { return isalpha((unsigned char) c); }$/;"	f
isdigit_c	hts_internal.h	/^static inline int isdigit_c(char c) { return isdigit((unsigned char) c); }$/;"	f
iseq	htslib/synced_bcf_reader.h	/^    int iseq;               \/\/ current position: chr name, index to snames$/;"	m	struct:_bcf_sr_regions_t
isgraph_c	hts_internal.h	/^static inline int isgraph_c(char c) { return isgraph((unsigned char) c); }$/;"	f
isize	htslib/sam.h	/^    int32_t isize;$/;"	m	struct:__anon37
islower_c	hts_internal.h	/^static inline int islower_c(char c) { return islower((unsigned char) c); }$/;"	f
isprint_c	hts_internal.h	/^static inline int isprint_c(char c) { return isprint((unsigned char) c); }$/;"	f
isspace_c	hts_internal.h	/^static inline int isspace_c(char c) { return isspace((unsigned char) c); }$/;"	f
isupper_c	hts_internal.h	/^static inline int isupper_c(char c) { return isupper((unsigned char) c); }$/;"	f
iswap_int2	cram/os.h	115;"	d
iswap_int4	cram/os.h	109;"	d
iswap_int8	cram/os.h	99;"	d
iter	sam.c	/^    bam_plp_t *iter;$/;"	m	struct:__bam_mplp_t	file:
iterator	test/test-vcf-api.c	/^void iterator(const char *fname)$/;"	f
iterators1	test/sam.c	/^static void iterators1(void)$/;"	f	file:
itf8_bytes	cram/cram_io.c	/^const int itf8_bytes[16] = {$/;"	v
itf8_decode	cram/cram_io.c	/^int itf8_decode(cram_fd *fd, int32_t *val_p) {$/;"	f
itf8_decode_crc	cram/cram_io.c	/^int itf8_decode_crc(cram_fd *fd, int32_t *val_p, uint32_t *crc) {$/;"	f
itf8_encode	cram/cram_io.c	/^int itf8_encode(cram_fd *fd, int32_t val) {$/;"	f
itf8_get	cram/cram_io.h	/^static inline int itf8_get(char *cp, int32_t *val_p) {$/;"	f
itf8_put	cram/cram_io.h	/^static inline int itf8_put(char *cp, int32_t val) {$/;"	f
itf8_put_blk	cram/cram_io.c	/^int itf8_put_blk(cram_block *blk, int val) {$/;"	f
itf8_size	cram/cram_io.h	264;"	d
itr	htslib/synced_bcf_reader.h	/^    hts_itr_t *itr;         \/\/ tabix iterator$/;"	m	struct:_bcf_sr_regions_t
itr	htslib/synced_bcf_reader.h	/^    hts_itr_t *itr;$/;"	m	struct:__anon29
job_pending	cram/cram_structs.h	/^    void *job_pending;$/;"	m	struct:cram_fd
job_pool	bgzf.c	/^    pool_alloc_t *job_pool;$/;"	m	struct:bgzf_mtaux_t	file:
job_pool_m	bgzf.c	/^    pthread_mutex_t job_pool_m;$/;"	m	struct:bgzf_mtaux_t	file:
jobs_pending	bgzf.c	/^    int jobs_pending; \/\/ number of jobs waiting$/;"	m	struct:bgzf_mtaux_t	file:
json	htslib/hts.h	/^    json HTS_DEPRECATED_ENUM("Use htsExactFormat 'htsget' instead") = htsget,$/;"	e	enum:htsExactFormat
k	cram/cram_codecs.h	/^    int32_t k;$/;"	m	struct:__anon73
k	sam.c	/^    int k, x, y, end;$/;"	m	struct:__anon4	file:
kbitset_iter_t	htslib/kbitset.h	/^typedef struct kbitset_iter_t {$/;"	s
kbitset_iter_t	htslib/kbitset.h	/^} kbitset_iter_t;$/;"	t	typeref:struct:kbitset_iter_t
kbitset_t	htslib/kbitset.h	/^typedef struct kbitset_t {$/;"	s
kbitset_t	htslib/kbitset.h	/^} kbitset_t;$/;"	t	typeref:struct:kbitset_t
kbs_bitwise_or	bcf_sr_sort.c	/^static inline void kbs_bitwise_or(kbitset_t *dst, kbitset_t *src)$/;"	f	file:
kbs_clear	htslib/kbitset.h	/^static inline void kbs_clear(kbitset_t *bs)$/;"	f
kbs_delete	htslib/kbitset.h	/^static inline void kbs_delete(kbitset_t *bs, int i)$/;"	f
kbs_destroy	htslib/kbitset.h	/^static inline void kbs_destroy(kbitset_t *bs)$/;"	f
kbs_exists	htslib/kbitset.h	/^static inline int kbs_exists(const kbitset_t *bs, int i)$/;"	f
kbs_init	htslib/kbitset.h	/^static inline kbitset_t *kbs_init(size_t ni)$/;"	f
kbs_init2	htslib/kbitset.h	/^static inline kbitset_t *kbs_init2(size_t ni, int fill)$/;"	f
kbs_insert	htslib/kbitset.h	/^static inline void kbs_insert(kbitset_t *bs, int i)$/;"	f
kbs_insert_all	htslib/kbitset.h	/^static inline void kbs_insert_all(kbitset_t *bs)$/;"	f
kbs_logical_and	bcf_sr_sort.c	/^static inline int kbs_logical_and(kbitset_t *bs1, kbitset_t *bs2)$/;"	f	file:
kbs_next	htslib/kbitset.h	/^static inline int kbs_next(const kbitset_t *bs, kbitset_iter_t *itr)$/;"	f
kbs_resize	bcf_sr_sort.c	/^static inline kbitset_t *kbs_resize(kbitset_t *bs, size_t ni)$/;"	f	file:
kbs_start	htslib/kbitset.h	/^static inline void kbs_start(kbitset_iter_t *itr)$/;"	f
kcalloc	htslib/khash.h	180;"	d
keep_samples	htslib/vcf.h	/^    uint8_t *keep_samples;$/;"	m	struct:__anon19
key	bcf_sr_sort.h	/^    char *key;              \/\/ only for debugging$/;"	m	struct:__anon116
key	cram/cram_structs.h	/^    int key;    \/* 0xe0 + 3 bytes *\/$/;"	m	struct:cram_map
key	htslib/vcf.h	/^    char *key;      \/\/ The part before '=', i.e. FILTER\/INFO\/FORMAT\/contig\/fileformat etc.$/;"	m	struct:__anon16
key	htslib/vcf.h	/^    const char *key;$/;"	m	struct:__anon18
key	htslib/vcf.h	/^    int key;        \/\/ key: numeric tag id, the corresponding string is bcf_hdr_t::id[BCF_DT_ID][$key].key$/;"	m	struct:__anon22
key	vcf.c	/^    int key, max_m, size, offset;$/;"	m	struct:__anon50	file:
keys	htslib/vcf.h	/^    char **keys, **vals;    \/\/ The key=value pairs$/;"	m	struct:__anon16
kf_betai	kfunc.c	/^double kf_betai(double a, double b, double x)$/;"	f
kf_betai_aux	kfunc.c	/^static double kf_betai_aux(double a, double b, double x)$/;"	f	file:
kf_erfc	kfunc.c	/^double kf_erfc(double x)$/;"	f
kf_gammap	kfunc.c	/^double kf_gammap(double s, double z)$/;"	f
kf_gammaq	kfunc.c	/^double kf_gammaq(double s, double z)$/;"	f
kf_lgamma	kfunc.c	/^double kf_lgamma(double z)$/;"	f
kfree	htslib/khash.h	189;"	d
kftp_connect	knetfile.c	/^int kftp_connect(knetFile *ftp)$/;"	f
kftp_connect_file	knetfile.c	/^int kftp_connect_file(knetFile *fp)$/;"	f
kftp_get_response	knetfile.c	/^static int kftp_get_response(knetFile *ftp)$/;"	f	file:
kftp_parse_url	knetfile.c	/^knetFile *kftp_parse_url(const char *fn, const char *mode)$/;"	f
kftp_pasv_connect	knetfile.c	/^static int kftp_pasv_connect(knetFile *ftp)$/;"	f	file:
kftp_pasv_prep	knetfile.c	/^static int kftp_pasv_prep(knetFile *ftp)$/;"	f	file:
kftp_reconnect	knetfile.c	/^int kftp_reconnect(knetFile *ftp)$/;"	f
kftp_send_cmd	knetfile.c	/^static int kftp_send_cmd(knetFile *ftp, const char *cmd, int is_get)$/;"	f	file:
kget_int32	cram/cram_index.c	/^static int kget_int32(kstring_t *k, size_t *pos, int32_t *val_p) {$/;"	f	file:
kget_int64	cram/cram_index.c	/^static int kget_int64(kstring_t *k, size_t *pos, int64_t *val_p) {$/;"	f	file:
kgetline	kstring.c	/^int kgetline(kstring_t *s, kgets_func *fgets_fn, void *fp)$/;"	f
kgets_func	htslib/kstring.h	/^	typedef char *kgets_func(char *, int, void *);$/;"	t
kh_begin	htslib/khash.h	528;"	d
kh_clear	htslib/khash.h	453;"	d
kh_cstr_t	htslib/khash.h	/^typedef const char *kh_cstr_t;$/;"	t
kh_del	htslib/khash.h	491;"	d
kh_destroy	htslib/khash.h	446;"	d
kh_end	htslib/khash.h	535;"	d
kh_exist	htslib/khash.h	499;"	d
kh_foreach	htslib/khash.h	558;"	d
kh_foreach_value	htslib/khash.h	572;"	d
kh_get	htslib/khash.h	483;"	d
kh_init	htslib/khash.h	439;"	d
kh_inline	htslib/khash.h	148;"	d
kh_inline	htslib/khash.h	150;"	d
kh_int64_hash_equal	htslib/khash.h	389;"	d
kh_int64_hash_func	htslib/khash.h	385;"	d
kh_int_hash_equal	htslib/khash.h	379;"	d
kh_int_hash_func	htslib/khash.h	375;"	d
kh_int_hash_func2	htslib/khash.h	422;"	d
kh_key	htslib/khash.h	507;"	d
kh_n_buckets	htslib/khash.h	549;"	d
kh_put	htslib/khash.h	474;"	d
kh_resize	htslib/khash.h	461;"	d
kh_size	htslib/khash.h	542;"	d
kh_str_hash_equal	htslib/khash.h	410;"	d
kh_str_hash_func	htslib/khash.h	406;"	d
kh_val	htslib/khash.h	516;"	d
kh_value	htslib/khash.h	521;"	d
khash_str2int_destroy	htslib/khash_str2int.h	/^static inline void khash_str2int_destroy(void *_hash)$/;"	f
khash_str2int_destroy_free	htslib/khash_str2int.h	/^static inline void khash_str2int_destroy_free(void *_hash)$/;"	f
khash_str2int_get	htslib/khash_str2int.h	/^static inline int khash_str2int_get(void *_hash, const char *str, int *value)$/;"	f
khash_str2int_has_key	htslib/khash_str2int.h	/^static inline int khash_str2int_has_key(void *_hash, const char *str)$/;"	f
khash_str2int_inc	htslib/khash_str2int.h	/^static inline int khash_str2int_inc(void *_hash, const char *str)$/;"	f
khash_str2int_init	htslib/khash_str2int.h	/^static inline void *khash_str2int_init(void)$/;"	f
khash_str2int_set	htslib/khash_str2int.h	/^static inline int khash_str2int_set(void *_hash, const char *str, int value)$/;"	f
khash_str2int_size	htslib/khash_str2int.h	/^static inline int khash_str2int_size(void *_hash)$/;"	f
khash_t	htslib/khash.h	432;"	d
khint32_t	htslib/khash.h	/^typedef unsigned int khint32_t;$/;"	t
khint32_t	htslib/khash.h	/^typedef unsigned long khint32_t;$/;"	t
khint64_t	htslib/khash.h	/^typedef unsigned long khint64_t;$/;"	t
khint64_t	htslib/khash.h	/^typedef unsigned long long khint64_t;$/;"	t
khint_t	htslib/khash.h	/^typedef khint32_t khint_t;$/;"	t
khiter_t	htslib/khash.h	/^typedef khint_t khiter_t;$/;"	t
khttp_connect_file	knetfile.c	/^int khttp_connect_file(knetFile *fp)$/;"	f
khttp_parse_url	knetfile.c	/^knetFile *khttp_parse_url(const char *fn, const char *mode)$/;"	f
kl_begin	htslib/klist.h	127;"	d
kl_destroy	htslib/klist.h	131;"	d
kl_end	htslib/klist.h	128;"	d
kl_init	htslib/klist.h	130;"	d
kl_next	htslib/klist.h	126;"	d
kl_pushp	htslib/klist.h	132;"	d
kl_shift	htslib/klist.h	133;"	d
kl_val	htslib/klist.h	125;"	d
klib_unused	htslib/khash.h	156;"	d
klib_unused	htslib/khash.h	158;"	d
klib_unused	htslib/klist.h	33;"	d
klib_unused	htslib/klist.h	35;"	d
klist_t	htslib/klist.h	124;"	d
kliter_t	htslib/klist.h	123;"	d
kmalloc	htslib/khash.h	183;"	d
kmemmem	kstring.c	/^void *kmemmem(const void *_str, int n, const void *_pat, int m, int **_prep)$/;"	f
kmempool_t	htslib/klist.h	71;"	d
kmp_alloc	htslib/klist.h	74;"	d
kmp_destroy	htslib/klist.h	73;"	d
kmp_free	htslib/klist.h	75;"	d
kmp_init	htslib/klist.h	72;"	d
knetFile	htslib/knetfile.h	/^} knetFile;$/;"	t	typeref:struct:knetFile_s
knetFile_s	htslib/knetfile.h	/^typedef struct knetFile_s {$/;"	s
knet_close	knetfile.c	/^int knet_close(knetFile *fp)$/;"	f
knet_dopen	knetfile.c	/^knetFile *knet_dopen(int fd, const char *mode)$/;"	f
knet_fileno	htslib/knetfile.h	67;"	d
knet_open	knetfile.c	/^knetFile *knet_open(const char *fn, const char *mode)$/;"	f
knet_read	knetfile.c	/^ssize_t knet_read(knetFile *fp, void *buf, size_t len)$/;"	f
knet_seek	knetfile.c	/^off_t knet_seek(knetFile *fp, off_t off, int whence)$/;"	f
knet_tell	htslib/knetfile.h	66;"	d
knet_win32_destroy	knetfile.c	/^void knet_win32_destroy()$/;"	f
knet_win32_init	knetfile.c	/^int knet_win32_init()$/;"	f
kputc	htslib/kstring.h	/^static inline int kputc(int c, kstring_t *s)$/;"	f
kputc_	htslib/kstring.h	/^static inline int kputc_(int c, kstring_t *s)$/;"	f
kputd	kstring.c	/^int kputd(double d, kstring_t *s) {$/;"	f
kputl	htslib/kstring.h	/^static inline int kputl(long c, kstring_t *s)$/;"	f
kputs	htslib/kstring.h	/^static inline int kputs(const char *p, kstring_t *s)$/;"	f
kputsn	htslib/kstring.h	/^static inline int kputsn(const char *p, int l, kstring_t *s)$/;"	f
kputsn_	htslib/kstring.h	/^static inline int kputsn_(const void *p, int l, kstring_t *s)$/;"	f
kputuw	htslib/kstring.h	/^static inline int kputuw(unsigned c, kstring_t *s)$/;"	f
kputw	htslib/kstring.h	/^static inline int kputw(int c, kstring_t *s)$/;"	f
krealloc	htslib/khash.h	186;"	d
kroundup32	bgzf.c	1607;"	d	file:
kroundup32	faidx.c	60;"	d	file:
kroundup32	htslib/hts.h	59;"	d
kroundup32	htslib/khash.h	176;"	d
kroundup32	htslib/kseq.h	91;"	d
kroundup32	htslib/kstring.h	36;"	d
kroundup_size_t	htslib/kstring.h	40;"	d
ksBM_prep	kstring.c	/^static int *ksBM_prep(const ubyte_t *pat, int m)$/;"	f	file:
ks_combsort	htslib/ksort.h	277;"	d
ks_eof	htslib/kseq.h	49;"	d
ks_heapadjust	htslib/ksort.h	280;"	d
ks_heapmake	htslib/ksort.h	279;"	d
ks_heapsort	htslib/ksort.h	278;"	d
ks_introsort	htslib/ksort.h	276;"	d
ks_isort_stack_t	htslib/ksort.h	/^} ks_isort_stack_t;$/;"	t	typeref:struct:__anon33
ks_ksmall	htslib/ksort.h	281;"	d
ks_len	htslib/kstring.h	/^static inline size_t ks_len(kstring_t *s)$/;"	f
ks_lt_generic	htslib/ksort.h	284;"	d
ks_lt_str	htslib/ksort.h	285;"	d
ks_mergesort	htslib/ksort.h	275;"	d
ks_release	htslib/kstring.h	/^static inline char *ks_release(kstring_t *s)$/;"	f
ks_resize	htslib/kstring.h	/^static inline int ks_resize(kstring_t *s, size_t size)$/;"	f
ks_rewind	htslib/kseq.h	50;"	d
ks_shuffle	htslib/ksort.h	282;"	d
ks_str	htslib/kstring.h	/^static inline char *ks_str(kstring_t *s)$/;"	f
ks_tokaux_t	htslib/kstring.h	/^} ks_tokaux_t;$/;"	t	typeref:struct:__anon32
kseq_rewind	htslib/kseq.h	167;"	d
ksplit	htslib/kstring.h	/^static inline int *ksplit(kstring_t *s, int delimiter, int *n)$/;"	f
ksplit_core	kstring.c	/^int ksplit_core(char *s, int delimiter, int *_max, int **_offsets)$/;"	f
ksprintf	kstring.c	/^int ksprintf(kstring_t *s, const char *fmt, ...)$/;"	f
ksstr_t	htslib/ksort.h	/^typedef const char *ksstr_t;$/;"	t
kstring_t	htslib/bgzf.h	/^} kstring_t;$/;"	t	typeref:struct:__kstring_t
kstring_t	htslib/hts.h	/^} kstring_t;$/;"	t	typeref:struct:__kstring_t
kstring_t	htslib/kseq.h	/^} kstring_t;$/;"	t	typeref:struct:__kstring_t
kstring_t	htslib/kstring.h	/^} kstring_t;$/;"	t	typeref:struct:__kstring_t
kstrnstr	kstring.c	/^char *kstrnstr(const char *str, const char *pat, int n, int **_prep)$/;"	f
kstrstr	kstring.c	/^char *kstrstr(const char *str, const char *pat, int **_prep)$/;"	f
kstrtok	kstring.c	/^char *kstrtok(const char *str, const char *sep, ks_tokaux_t *aux)$/;"	f
kt_fisher_exact	kfunc.c	/^double kt_fisher_exact(int n11, int n12, int n21, int n22, double *_left, double *_right, double *two)$/;"	f
kvsprintf	kstring.c	/^int kvsprintf(kstring_t *s, const char *fmt, va_list ap)$/;"	f
l	htslib/bgzf.h	/^    size_t l, m;$/;"	m	struct:__kstring_t
l	htslib/hts.h	/^    size_t l, m;$/;"	m	struct:__kstring_t
l	htslib/kseq.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
l	htslib/kstring.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
l_data	htslib/sam.h	/^    int l_data;$/;"	m	struct:__anon38
l_extranul	htslib/sam.h	/^    uint8_t l_extranul;$/;"	m	struct:__anon37
l_meta	hts.c	/^    uint32_t l_meta;$/;"	m	struct:__hts_idx_t	file:
l_qname	htslib/sam.h	/^    uint8_t l_qname;$/;"	m	struct:__anon37
l_qseq	htslib/sam.h	/^    int32_t l_qseq;$/;"	m	struct:__anon37
l_text	htslib/sam.h	/^    uint32_t l_text;$/;"	m	struct:__anon36
lals	vcf_sweep.c	/^    char *lals;$/;"	m	struct:_bcf_sweep_t	file:
lals_len	vcf_sweep.c	/^    int lrid, lpos, lnals, lals_len, mlals;   \/\/ to check uniqueness of a record$/;"	m	struct:_bcf_sweep_t	file:
landmark	cram/cram_structs.h	/^    int32_t *landmark;$/;"	m	struct:cram_block_compression_hdr
landmark	cram/cram_structs.h	/^    int32_t *landmark;$/;"	m	struct:cram_container
last	cram/cram_structs.h	/^    ref_entry *last;       \/\/ Last queried sequence$/;"	m	struct:__anon93
last_apos	cram/cram_structs.h	/^    int last_apos, max_apos;$/;"	m	struct:cram_slice
last_base	cram/cram_structs.h	/^    int first_base, last_base;$/;"	m	struct:cram_fd
last_base	cram/cram_structs.h	/^    int ref_start, first_base, last_base, ref_id, ref_end;$/;"	m	struct:cram_container
last_bin	hts.c	/^        uint32_t last_bin, save_bin;$/;"	m	struct:__hts_idx_t::__anon3	file:
last_block_eof	htslib/bgzf.h	/^    unsigned last_block_eof:1, is_compressed:1, is_gzip:1;$/;"	m	struct:BGZF
last_coor	hts.c	/^        int last_coor, last_tid, save_tid, finished;$/;"	m	struct:__hts_idx_t::__anon3	file:
last_id	cram/cram_structs.h	/^    int last_id;           \/\/ Used in cram_ref_decr_locked to delay free$/;"	m	struct:__anon93
last_off	hts.c	/^        uint64_t last_off, save_off;$/;"	m	struct:__hts_idx_t::__anon3	file:
last_pos	cram/cram_structs.h	/^    int last_pos;                \/\/ last record position$/;"	m	struct:cram_container
last_slice	cram/cram_structs.h	/^    int last_slice;                     \/\/ number of recs encoded in last slice$/;"	m	struct:cram_fd
last_slice	cram/cram_structs.h	/^    int last_slice;              \/\/ number of reads in last slice (0 for 1st)$/;"	m	struct:cram_container
last_tid	hts.c	/^        int last_coor, last_tid, save_tid, finished;$/;"	m	struct:__hts_idx_t::__anon3	file:
lazy_flush	bgzf.c	/^static inline int lazy_flush(BGZF *fp)$/;"	f	file:
lazy_flush	bgzf.c	/^static int lazy_flush(BGZF *fp)$/;"	f	file:
lbinom	kfunc.c	/^static double lbinom(int n, int k)$/;"	f	file:
lbnode_t	sam.c	/^} lbnode_t;$/;"	t	typeref:struct:__linkbuf_t	file:
le_int2	cram/os.h	/^static inline uint16_t le_int2(uint16_t x) {$/;"	f
le_int2	cram/os.h	149;"	d
le_int2	cram/os.h	152;"	d
le_int4	cram/os.h	/^static inline uint32_t le_int4(uint32_t x) {$/;"	f
le_int4	cram/os.h	148;"	d
le_int4	cram/os.h	151;"	d
le_to_double	htslib/hts_endian.h	/^static inline double le_to_double(const uint8_t *buf) {$/;"	f
le_to_float	htslib/hts_endian.h	/^static inline float le_to_float(const uint8_t *buf) {$/;"	f
le_to_i16	htslib/hts_endian.h	/^static inline int16_t le_to_i16(const uint8_t *buf) {$/;"	f
le_to_i32	htslib/hts_endian.h	/^static inline int32_t le_to_i32(const uint8_t *buf) {$/;"	f
le_to_i64	htslib/hts_endian.h	/^static inline int64_t le_to_i64(const uint8_t *buf) {$/;"	f
le_to_i8	htslib/hts_endian.h	/^static inline int8_t le_to_i8(const uint8_t *buf) {$/;"	f
le_to_u16	htslib/hts_endian.h	/^static inline uint16_t le_to_u16(const uint8_t *buf) {$/;"	f
le_to_u32	htslib/hts_endian.h	/^static inline uint32_t le_to_u32(const uint8_t *buf) {$/;"	f
le_to_u64	htslib/hts_endian.h	/^static inline uint64_t le_to_u64(const uint8_t *buf) {$/;"	f
left	htslib/ksort.h	/^	void *left, *right;$/;"	m	struct:__anon33
len	cram/cram_codecs.h	/^    int32_t len;$/;"	m	struct:__anon68
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon84
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon86
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon87
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon89
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon90
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon91
len	cram/cram_structs.h	/^	    int len;$/;"	m	struct:cram_feature::__anon81::__anon92
len	cram/cram_structs.h	/^    int     len;    \/\/                     1.1 - size of slice in bytes$/;"	m	struct:cram_index
len	cram/cram_structs.h	/^    int32_t len;          \/\/ RL$/;"	m	struct:cram_record
len	cram/sam_header.h	/^    int   len;$/;"	m	struct:SAM_hdr_tag_s
len	cram/sam_header.h	/^    uint32_t len;$/;"	m	struct:__anon62
len	faidx.c	/^    int64_t len;$/;"	m	struct:__anon112	file:
len	hfile_libcurl.c	/^        size_t len;$/;"	m	struct:__anon100::__anon101	file:
len	htslib/vcf.h	/^    int type, len;  \/\/ type: one of BCF_BT_* types; len: vector length, 1 for scalars$/;"	m	struct:__anon22
len_codec	cram/cram_codecs.h	/^    struct cram_codec *len_codec;$/;"	m	struct:__anon75	typeref:struct:__anon75::cram_codec
len_codec	cram/cram_codecs.h	/^    struct cram_codec *len_codec;$/;"	m	struct:__anon77	typeref:struct:__anon77::cram_codec
len_dat	cram/cram_codecs.h	/^    void *len_dat;$/;"	m	struct:__anon77
len_encoding	cram/cram_codecs.h	/^    enum cram_encoding len_encoding;$/;"	m	struct:__anon77	typeref:enum:__anon77::cram_encoding
length	cram/cram_structs.h	/^    int32_t  length;$/;"	m	struct:cram_container
length	cram/cram_structs.h	/^    int64_t length;$/;"	m	struct:ref_entry
level	cram/cram_structs.h	/^    int level;$/;"	m	struct:cram_fd
level	htslib/sam.h	/^    int indel, level;$/;"	m	struct:__anon40
lfact	errmod.c	47;"	d	file:
libcurl_backend	hfile_libcurl.c	/^static const struct hFILE_backend libcurl_backend =$/;"	v	typeref:struct:hFILE_backend	file:
libcurl_close	hfile_libcurl.c	/^static int libcurl_close(hFILE *fpv)$/;"	f	file:
libcurl_exit	hfile_libcurl.c	/^static void libcurl_exit()$/;"	f	file:
libcurl_open	hfile_libcurl.c	/^libcurl_open(const char *url, const char *modes, http_headers *headers)$/;"	f	file:
libcurl_read	hfile_libcurl.c	/^static ssize_t libcurl_read(hFILE *fpv, void *bufferv, size_t nbytes)$/;"	f	file:
libcurl_seek	hfile_libcurl.c	/^static off_t libcurl_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
libcurl_write	hfile_libcurl.c	/^static ssize_t libcurl_write(hFILE *fpv, const void *bufferv, size_t nbytes)$/;"	f	file:
libdir	Makefile	/^libdir      = $(exec_prefix)\/lib$/;"	m
libexecdir	Makefile	/^libexecdir  = $(exec_prefix)\/libexec$/;"	m
lidx	hts.c	/^    lidx_t *lidx;$/;"	m	struct:__hts_idx_t	file:
lidx_t	hts.c	/^} lidx_t;$/;"	t	typeref:struct:__anon2	file:
limit	htslib/hfile.h	/^    char *buffer, *begin, *end, *limit;$/;"	m	struct:hFILE
line	htslib/hts.h	/^    kstring_t line;$/;"	m	struct:__anon9
line	htslib/synced_bcf_reader.h	/^    kstring_t line;         \/\/ holder of the current line, set only when reading from tabix-indexed files$/;"	m	struct:_bcf_sr_regions_t
line_blen	faidx.c	/^    int32_t line_len, line_blen;$/;"	m	struct:__anon112	file:
line_len	faidx.c	/^    int32_t line_len, line_blen;$/;"	m	struct:__anon112	file:
line_length	cram/cram_structs.h	/^    int line_length;$/;"	m	struct:ref_entry
line_skip	htslib/tbx.h	/^    int32_t meta_char, line_skip;$/;"	m	struct:__anon34
lineno	htslib/hts.h	/^    int64_t lineno;$/;"	m	struct:__anon9
list	hfile_libcurl.c	/^    struct curl_slist *list;$/;"	m	struct:__anon98	typeref:struct:__anon98::curl_slist	file:
list	hts.c	/^    hts_pair64_t *list;$/;"	m	struct:__anon1	file:
lnals	vcf_sweep.c	/^    int lrid, lpos, lnals, lals_len, mlals;   \/\/ to check uniqueness of a record$/;"	m	struct:_bcf_sweep_t	file:
lo	md5.c	/^	hts_md5_u32plus lo, hi;$/;"	m	struct:hts_md5_context	file:
load_block_from_cache	bgzf.c	/^static int load_block_from_cache(BGZF *fp, int64_t block_address) {return 0;}$/;"	f	file:
load_block_from_cache	bgzf.c	/^static int load_block_from_cache(BGZF *fp, int64_t block_address)$/;"	f	file:
load_hfile_plugins	hfile.c	/^static void load_hfile_plugins()$/;"	f	file:
load_plugin	plugin.c	/^void *load_plugin(void **pluginp, const char *filename, const char *symbol)$/;"	f
load_ref_portion	cram/cram_io.c	/^static char *load_ref_portion(BGZF *fp, ref_entry *e, int start, int end) {$/;"	f	file:
lock	cram/cram_structs.h	/^    pthread_mutex_t lock;  \/\/ Mutex for multi-threaded updating$/;"	m	struct:__anon93
lock	hfile_libcurl.c	/^    pthread_mutex_t lock;$/;"	m	struct:__anon103	file:
loff	hts.c	/^    uint64_t loff;$/;"	m	struct:__anon1	file:
logbinomial_table	errmod.c	/^static double* logbinomial_table( const int n_size )$/;"	f	file:
lossy_read_names	cram/cram_encode.c	/^static int lossy_read_names(cram_fd *fd, cram_container *c, cram_slice *s,$/;"	f	file:
lossy_read_names	cram/cram_structs.h	/^    int lossy_read_names;               \/\/ boolean$/;"	m	struct:cram_fd
lpos	vcf_sweep.c	/^    int lrid, lpos, lnals, lals_len, mlals;   \/\/ to check uniqueness of a record$/;"	m	struct:_bcf_sweep_t	file:
lrand48	htslib/hts_os.h	39;"	d
lrid	vcf_sweep.c	/^    int lrid, lpos, lnals, lals_len, mlals;   \/\/ to check uniqueness of a record$/;"	m	struct:_bcf_sweep_t	file:
ltext	test/test_bgzf.c	/^    size_t ltext;$/;"	m	struct:__anon48	file:
ltf8_bytes	cram/cram_io.c	/^const int ltf8_bytes[256] = {$/;"	v
ltf8_decode	cram/cram_io.c	/^int ltf8_decode(cram_fd *fd, int64_t *val_p) {$/;"	f
ltf8_decode_crc	cram/cram_io.c	/^int ltf8_decode_crc(cram_fd *fd, int64_t *val_p, uint32_t *crc) {$/;"	f
ltf8_get	cram/cram_io.h	/^static inline int ltf8_get(char *cp, int64_t *val_p) {$/;"	f
ltf8_put	cram/cram_io.h	/^static inline int ltf8_put(char *cp, int64_t val) {$/;"	f
lzma_cnt	cram/cram_structs.h	/^    int lzma_cnt;$/;"	m	struct:__anon80
lzma_extra	cram/cram_structs.h	/^    double lzma_extra;$/;"	m	struct:__anon80
lzma_mem_deflate	cram/cram_io.c	/^static char *lzma_mem_deflate(char *data, size_t size, size_t *cdata_size,$/;"	f	file:
lzma_mem_inflate	cram/cram_io.c	/^static char *lzma_mem_inflate(char *cdata, size_t csize, size_t *size) {$/;"	f	file:
m	cram/cram_structs.h	/^    cram_metrics *m; \/\/ used to track aux block compression only$/;"	m	struct:cram_block
m	cram/cram_structs.h	/^    cram_metrics *m;$/;"	m	struct:cram_tag_map
m	cram/cram_structs.h	/^    cram_metrics *m[DS_END];$/;"	m	struct:cram_fd
m	hts.c	/^    int32_t m, n;$/;"	m	struct:__anon1	file:
m	hts.c	/^    int32_t n, m;$/;"	m	struct:__anon2	file:
m	hts.c	/^    int32_t n, m;$/;"	m	struct:__hts_idx_t	file:
m	htslib/bgzf.h	/^    size_t l, m;$/;"	m	struct:__kstring_t
m	htslib/hts.h	/^        int n, m;$/;"	m	struct:__anon14::__anon15
m	htslib/hts.h	/^    size_t l, m;$/;"	m	struct:__kstring_t
m	htslib/kseq.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
m	htslib/kstring.h	/^	size_t l, m;$/;"	m	struct:__kstring_t
m	htslib/vcf.h	/^    int32_t m[3];          \/\/ m: allocated size of the dictionary block in use (see n above)$/;"	m	struct:__anon19
mFILE	cram/mFILE.h	/^} mFILE;$/;"	t	typeref:struct:__anon58
m_allele	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
m_als	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
m_channel	cram/mFILE.c	/^static mFILE *m_channel[3];  \/* stdin, stdout and stderr fakes *\/$/;"	v	file:
m_data	htslib/sam.h	/^    uint32_t m_data;$/;"	m	struct:__anon38
m_flt	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
m_fmt	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
m_id	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
m_info	htslib/vcf.h	/^    int m_fmt, m_info, m_id, m_als, m_allele, m_flt; \/\/ allocated size (high-water mark); do not change$/;"	m	struct:__anon24
magic	cram/cram_structs.h	/^    char    magic[4];$/;"	m	struct:cram_file_def
main	bgzip.c	/^int main(int argc, char **argv)$/;"	f
main	cram/pooled_alloc.c	/^int main(void) {$/;"	f
main	cram/rANS_static.c	/^int main(int argc, char **argv) {$/;"	f
main	htsfile.c	/^int main(int argc, char **argv)$/;"	f
main	kfunc.c	/^int main(int argc, char *argv[])$/;"	f
main	knetfile.c	/^int main(void)$/;"	f
main	kstring.c	/^int main()$/;"	f
main	probaln.c	/^int main(int argc, char *argv[])$/;"	f
main	tabix.c	/^int main(int argc, char *argv[])$/;"	f
main	test/fieldarith.c	/^int main(int argc, char **argv)$/;"	f
main	test/hfile.c	/^int main(void)$/;"	f
main	test/hts_endian.c	/^int main(int argc, char **argv) {$/;"	f
main	test/sam.c	/^int main(int argc, char **argv)$/;"	f
main	test/test-bcf-sr.c	/^int main(int argc, char *argv[])$/;"	f
main	test/test-bcf-translate.c	/^int main(int argc, char **argv)$/;"	f
main	test/test-regidx.c	/^int main(int argc, char **argv)$/;"	f
main	test/test-vcf-api.c	/^int main(int argc, char **argv)$/;"	f
main	test/test-vcf-sweep.c	/^int main(int argc, char **argv)$/;"	f
main	test/test_bgzf.c	/^int main(int argc, char **argv) {$/;"	f
main	test/test_view.c	/^int main(int argc, char *argv[])$/;"	f
main	test/thrash_threads1.c	/^int main(int argc, char *argv[]) {$/;"	f
main	test/thrash_threads2.c	/^int main(int argc, char *argv[]) {$/;"	f
main	test/thrash_threads3.c	/^int main(int argc, char *argv[]) {$/;"	f
main	test/thrash_threads4.c	/^int main(int argc, char *argv[]) {$/;"	f
main	test/thrash_threads5.c	/^int main(int argc, char *argv[]) {$/;"	f
main	test/thrash_threads6.c	/^int main(int argc, char *argv[]) {$/;"	f
main	thread_pool.c	/^int main(int argc, char **argv) {$/;"	f
major	htslib/hts.h	/^    struct { short major, minor; } version;$/;"	m	struct:htsFormat::__anon8
major_version	cram/cram_io.c	/^static int major_version = 3;$/;"	v	file:
major_version	cram/cram_structs.h	/^    uint8_t major_version;$/;"	m	struct:cram_file_def
mals	htslib/synced_bcf_reader.h	/^    int nals, mals;         \/\/ number of set alleles and the size of allocated array$/;"	m	struct:_bcf_sr_regions_t
man1dir	Makefile	/^man1dir     = $(mandir)\/man1$/;"	m
man5dir	Makefile	/^man5dir     = $(mandir)\/man5$/;"	m
mandir	Makefile	/^mandir      = $(datarootdir)\/man$/;"	m
map_find	cram/cram_decode.c	/^static cram_map *map_find(cram_map **map, unsigned char *key, int id) {$/;"	f	file:
mapped_qs_included	cram/cram_structs.h	/^    int mapped_qs_included;$/;"	m	struct:cram_block_compression_hdr
mask	bcf_sr_sort.h	/^    kbitset_t *mask;        \/\/ which groups are populated in this set (replace with expandable bitmask)$/;"	m	struct:__anon117
mask	bcf_sr_sort.h	/^    kbitset_t *mask;        \/\/ which groups contain the variant$/;"	m	struct:__anon115
mask	htslib/kbitset.h	/^	unsigned long mask;$/;"	m	struct:kbitset_iter_t
mate_flags	cram/cram_structs.h	/^    int32_t mate_flags;   \/\/ MF$/;"	m	struct:cram_record
mate_line	cram/cram_structs.h	/^    int32_t mate_line;    \/\/ index to another cram_record$/;"	m	struct:cram_record
mate_pos	cram/cram_structs.h	/^    int32_t mate_pos;     \/\/ NP$/;"	m	struct:cram_record
mate_ref_id	cram/cram_structs.h	/^    int32_t mate_ref_id;$/;"	m	struct:cram_record
max	sam.c	/^    int cnt, n, max;$/;"	m	struct:__anon5	file:
max_apos	cram/cram_structs.h	/^    int last_apos, max_apos;$/;"	m	struct:cram_slice
max_apos	cram/cram_structs.h	/^    int max_apos;                \/\/ maximum position, used if pos_sorted==0$/;"	m	struct:cram_container
max_c_rec	cram/cram_structs.h	/^    int max_c_rec, curr_c_rec;   \/\/ current and max recs per container$/;"	m	struct:cram_container
max_g	vcf.c	/^    uint64_t is_gt:1, max_g:31, max_l:32;$/;"	m	struct:__anon50	file:
max_l	vcf.c	/^    uint64_t is_gt:1, max_g:31, max_l:32;$/;"	m	struct:__anon50	file:
max_length	cram/string_alloc.h	/^    size_t max_length;$/;"	m	struct:__anon61
max_m	vcf.c	/^    int key, max_m, size, offset;$/;"	m	struct:__anon50	file:
max_plp	sam.c	/^    int is_eof, max_plp, error, maxcnt;$/;"	m	struct:__bam_plp_t	file:
max_pos	sam.c	/^    int32_t tid, pos, max_tid, max_pos;$/;"	m	struct:__bam_plp_t	file:
max_rec	cram/cram_structs.h	/^    int max_rec, curr_rec;       \/\/ current and max recs per slice$/;"	m	struct:cram_container
max_response	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
max_slice	cram/cram_structs.h	/^    int max_slice, curr_slice;   \/\/ maximum number of slices$/;"	m	struct:cram_container
max_tid	sam.c	/^    int32_t tid, pos, max_tid, max_pos;$/;"	m	struct:__bam_plp_t	file:
max_unpack	htslib/synced_bcf_reader.h	/^    int max_unpack;     \/\/ When reading VCFs and knowing some fields will not be needed, boost performance of vcf_parse1$/;"	m	struct:__anon31
max_unpack	htslib/vcf.h	/^    int max_unpack;         \/\/ Set to BCF_UN_STR, BCF_UN_FLT, or BCF_UN_INFO to boost performance of vcf_parse when some of the fields won't be needed$/;"	m	struct:__anon25
maxcnt	sam.c	/^    int is_eof, max_plp, error, maxcnt;$/;"	m	struct:__bam_plp_t	file:
maxparts	multipart.c	/^    size_t nparts, maxparts, current;$/;"	m	struct:__anon104	file:
mbuffer	htslib/synced_bcf_reader.h	/^    int nbuffer, mbuffer;           \/\/ number of cached records (including the current record); number of allocated records$/;"	m	struct:__anon29
mcharp	bcf_sr_sort.h	/^    int moff, noff, *off, mcharp;$/;"	m	struct:__anon118
mcnt	bcf_sr_sort.h	/^    int mcnt, *cnt;         \/\/ number of VCF covered by a varset$/;"	m	struct:__anon118
md5	cram/cram_structs.h	/^    unsigned char md5[16];$/;"	m	struct:cram_block_slice_hdr
md5_print	cram/cram_decode.c	/^static char *md5_print(unsigned char *md5, char *out) {$/;"	f	file:
mem	htslib/vcf.h	/^    kstring_t mem;$/;"	m	struct:__anon19
mem_backend	hfile.c	/^static const struct hFILE_backend mem_backend =$/;"	v	typeref:struct:hFILE_backend	file:
mem_close	hfile.c	/^static int mem_close(hFILE *fpv)$/;"	f	file:
mem_seek	hfile.c	/^static off_t mem_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
mempool_t	sam.c	/^} mempool_t;$/;"	t	typeref:struct:__anon5	file:
merge_rows	test/test-bcf-sr.pl	/^sub merge_rows$/;"	s
merge_vsets	bcf_sr_sort.c	/^int merge_vsets(sr_sort_t *srt, int ivset, int jvset)$/;"	f
meta	hts.c	/^    uint8_t *meta; \/\/ MUST have a terminating NUL on the end$/;"	m	struct:__hts_idx_t	file:
meta_char	htslib/tbx.h	/^    int32_t meta_char, line_skip;$/;"	m	struct:__anon34
method	cram/cram_structs.h	/^    enum cram_block_method  method, orig_method;$/;"	m	struct:cram_block	typeref:enum:cram_block::cram_block_method
method	cram/cram_structs.h	/^    int method;$/;"	m	struct:__anon80
metrics_lock	cram/cram_structs.h	/^    pthread_mutex_t metrics_lock;$/;"	m	struct:cram_fd
mf	cram/cram_structs.h	/^    mFILE *mf;$/;"	m	struct:ref_entry
mfascii	cram/mFILE.c	/^void mfascii(mFILE *mf) {$/;"	f
mfclose	cram/mFILE.c	/^int mfclose(mFILE *mf) {$/;"	f
mfcreate	cram/mFILE.c	/^mFILE *mfcreate(char *data, int size) {$/;"	f
mfcreate_from	cram/mFILE.c	/^mFILE *mfcreate_from(const char *path, const char *mode_str, FILE *fp) {$/;"	f
mfdestroy	cram/mFILE.c	/^int mfdestroy(mFILE *mf) {$/;"	f
mfdetach	cram/mFILE.c	/^int mfdetach(mFILE *mf) {$/;"	f
mfeof	cram/mFILE.c	/^int mfeof(mFILE *mf) {$/;"	f
mfflush	cram/mFILE.c	/^int mfflush(mFILE *mf) {$/;"	f
mfgetc	cram/mFILE.c	/^int mfgetc(mFILE *mf) {$/;"	f
mfgets	cram/mFILE.c	/^char *mfgets(char *s, int size, mFILE *mf) {$/;"	f
mfload	cram/mFILE.c	/^static char *mfload(FILE *fp, const char *fn, size_t *size, int binary) {$/;"	f	file:
mfmmap	cram/mFILE.c	/^int mfmmap(mFILE *mf, FILE *fp, const char *fn) {$/;"	f
mfopen	cram/mFILE.c	/^mFILE *mfopen(const char *path, const char *mode) {$/;"	f
mfread	cram/mFILE.c	/^size_t mfread(void *ptr, size_t size, size_t nmemb, mFILE *mf) {$/;"	f
mfrecreate	cram/mFILE.c	/^void mfrecreate(mFILE *mf, char *data, int size) {$/;"	f
mfreopen	cram/mFILE.c	/^mFILE *mfreopen(const char *path, const char *mode_str, FILE *fp) {$/;"	f
mfseek	cram/mFILE.c	/^int mfseek(mFILE *mf, long offset, int whence) {$/;"	f
mfsteal	cram/mFILE.c	/^void *mfsteal(mFILE *mf, size_t *size_out) {$/;"	f
mftell	cram/mFILE.c	/^long mftell(mFILE *mf) {$/;"	f
mftruncate	cram/mFILE.c	/^void mftruncate(mFILE *mf, long offset) {$/;"	f
mfwrite	cram/mFILE.c	/^size_t mfwrite(void *ptr, size_t size, size_t nmemb, mFILE *mf) {$/;"	f
mgrp	bcf_sr_sort.h	/^    int ngrp, mgrp;$/;"	m	struct:__anon118
midx	vcf_sweep.c	/^    int iidx, nidx, midx;   \/\/ i: current offset; n: used; m: allocated$/;"	m	struct:_bcf_sweep_t	file:
min	sam.c	/^    uint64_t min, *pos;$/;"	m	struct:__bam_mplp_t	file:
min_shift	hts.c	/^    int fmt, min_shift, n_lvls, n_bins;$/;"	m	struct:__hts_idx_t	file:
minor	htslib/hts.h	/^    struct { short major, minor; } version;$/;"	m	struct:htsFormat::__anon8
minor_version	cram/cram_io.c	/^static int minor_version = 0;$/;"	v	file:
minor_version	cram/cram_structs.h	/^    uint8_t minor_version;$/;"	m	struct:cram_file_def
missed_reg_data	htslib/synced_bcf_reader.h	/^    void *missed_reg_data;$/;"	m	struct:_bcf_sr_regions_t
missed_reg_handler	htslib/synced_bcf_reader.h	/^    void (*missed_reg_handler)(struct _bcf_sr_regions_t *, void *);$/;"	m	struct:_bcf_sr_regions_t
mkdir	cram/os.h	209;"	d
mkdir	htslib/hts_os.h	50;"	d
mkdir_prefix	cram/cram_io.c	/^void mkdir_prefix(char *path, int mode) {$/;"	f
mlals	vcf_sweep.c	/^    int lrid, lpos, lnals, lals_len, mlals;   \/\/ to check uniqueness of a record$/;"	m	struct:_bcf_sweep_t	file:
mobile	htslib/hfile.h	/^    unsigned at_eof:1, mobile:1, readonly:1;$/;"	m	struct:hFILE
mode	cram/cram_structs.h	/^    int            mode;     \/\/ 'r' or 'w'$/;"	m	struct:cram_fd
mode	cram/mFILE.h	/^    int mode; \/* open mode in MF_?? define bit pattern *\/$/;"	m	struct:__anon58
mode	hfile_s3.c	/^    char mode;$/;"	m	struct:__anon53	file:
mode	htsfile.c	/^enum { identify, view_headers, view_all } mode = identify;$/;"	v	typeref:enum:__anon96
mode2level	bgzf.c	/^static int mode2level(const char *mode)$/;"	f	file:
moff	bcf_sr_sort.h	/^    int moff, noff, *off, mcharp;$/;"	m	struct:__anon118
moffs	bgzf.c	/^    int noffs, moffs;       \/\/ the size of the index, n:used, m:allocated$/;"	m	struct:__bgzidx_t	file:
mp	sam.c	/^    mempool_t *mp;$/;"	m	struct:__bam_plp_t	file:
mp_alloc	sam.c	/^static inline lbnode_t *mp_alloc(mempool_t *mp)$/;"	f	file:
mp_destroy	sam.c	/^static void mp_destroy(mempool_t *mp)$/;"	f	file:
mp_free	sam.c	/^static inline void mp_free(mempool_t *mp, lbnode_t *p)$/;"	f	file:
mp_init	sam.c	/^static mempool_t *mp_init(void)$/;"	f	file:
mpmat	bcf_sr_sort.h	/^    int mpmat, *pmat;       \/\/ pairing matrix, i-th vset and j-th group accessible as i*ngrp+j$/;"	m	struct:__anon118
mpos	htslib/sam.h	/^    int32_t mpos;$/;"	m	struct:__anon37
mqual	cram/cram_structs.h	/^    int32_t mqual;        \/\/ MQ$/;"	m	struct:cram_record
mrec	bcf_sr_sort.h	/^    int nrec, mrec;$/;"	m	struct:__anon114
mrec	vcf_sweep.c	/^    int nrec, mrec;         \/\/ number of used records; total size of the buffer$/;"	m	struct:_bcf_sweep_t	file:
mregs	regidx.c	/^    int nregs, mregs;   \/\/ n:used, m:alloced$/;"	m	struct:__anon41	file:
mregs	synced_bcf_reader.c	/^    int nregs, mregs, creg;$/;"	m	struct:_region_t	file:
mrewind	cram/mFILE.c	/^void mrewind(mFILE *mf) {$/;"	f
mseq	regidx.c	/^    int nseq, mseq;     \/\/ n:used, m:alloced$/;"	m	struct:_regidx_t	file:
msr	bcf_sr_sort.h	/^    int pos, nsr, msr;$/;"	m	struct:__anon118
mstderr	cram/mFILE.c	/^mFILE *mstderr(void) {$/;"	f
mstdin	cram/mFILE.c	/^mFILE *mstdin(void) {$/;"	f
mstdout	cram/mFILE.c	/^mFILE *mstdout(void) {$/;"	f
mt	htslib/bgzf.h	/^    struct bgzf_mtaux_t *mt; \/\/ only used for multi-threading$/;"	m	struct:BGZF	typeref:struct:BGZF::bgzf_mtaux_t
mt_destroy	bgzf.c	/^static void mt_destroy(mtaux_t *mt)$/;"	f	file:
mt_flush_queue	bgzf.c	/^static int mt_flush_queue(BGZF *fp)$/;"	f	file:
mt_queue	bgzf.c	/^static int mt_queue(BGZF *fp)$/;"	f	file:
mtaux_cmd	bgzf.c	/^enum mtaux_cmd {$/;"	g	file:
mtaux_t	bgzf.c	/^} mtaux_t;$/;"	t	typeref:struct:bgzf_mtaux_t	file:
mtid	htslib/sam.h	/^    int32_t mtid;$/;"	m	struct:__anon37
multi	hfile_libcurl.c	/^    CURLM *multi;$/;"	m	struct:__anon100	file:
multi_errno	hfile_libcurl.c	/^static int multi_errno(CURLMcode errm)$/;"	f	file:
multi_is_exact	bcf_sr_sort.c	/^static int multi_is_exact(var_t *avar, var_t *bvar)$/;"	f	file:
multi_is_exact	test/test-bcf-sr.pl	/^sub multi_is_exact$/;"	s
multi_is_subset	bcf_sr_sort.c	/^static int multi_is_subset(var_t *avar, var_t *bvar)$/;"	f	file:
multi_is_subset	test/test-bcf-sr.pl	/^sub multi_is_subset$/;"	s
multi_seq	cram/cram_structs.h	/^    int multi_seq;               \/\/ true if packing multi seqs per cont\/slice$/;"	m	struct:cram_container
multi_seq	cram/cram_structs.h	/^    int multi_seq;$/;"	m	struct:cram_fd
multipart_backend	multipart.c	/^static const struct hFILE_backend multipart_backend =$/;"	v	typeref:struct:hFILE_backend	file:
multipart_close	multipart.c	/^static int multipart_close(hFILE *fpv)$/;"	f	file:
multipart_read	multipart.c	/^static ssize_t multipart_read(hFILE *fpv, void *buffer, size_t nbytes)$/;"	f	file:
multipart_seek	multipart.c	/^static off_t multipart_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
multipart_write	multipart.c	/^static ssize_t multipart_write(hFILE *fpv, const void *buffer, size_t nbytes)$/;"	f	file:
mungetc	cram/mFILE.c	/^int mungetc(int c, mFILE *mf) {$/;"	f
mvar	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ list of compatible variants that can be output together$/;"	m	struct:__anon117
mvar	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ the variants and their type$/;"	m	struct:__anon116
mvar	bcf_sr_sort.h	/^    int nvar, mvar;$/;"	m	struct:__anon118
mvcf	bcf_sr_sort.h	/^    int nvcf, mvcf, *vcf;   \/\/ the list of readers with the same variants$/;"	m	struct:__anon115
mvset	bcf_sr_sort.h	/^    int nvset, mvset;$/;"	m	struct:__anon118
my_netread	knetfile.c	/^static off_t my_netread(int fd, void *buf, off_t len)$/;"	f	file:
n	hts.c	/^    int32_t m, n;$/;"	m	struct:__anon1	file:
n	hts.c	/^    int32_t n, m;$/;"	m	struct:__anon2	file:
n	hts.c	/^    int32_t n, m;$/;"	m	struct:__hts_idx_t	file:
n	htslib/hts.h	/^        int n, m;$/;"	m	struct:__anon14::__anon15
n	htslib/kbitset.h	/^	size_t n;$/;"	m	struct:kbitset_t
n	htslib/regidx.h	/^    int i, n;$/;"	m	struct:__anon27
n	htslib/vcf.h	/^    int n, size, type;  \/\/ n: number of values per-sample; size: number of bytes per-sample; type: one of BCF_BT_* types$/;"	m	struct:__anon21
n	htslib/vcf.h	/^    int type, n;    \/\/ variant type and the number of bases affected, negative for deletions$/;"	m	struct:__anon20
n	htslib/vcf.h	/^    int32_t n[3];           \/\/ n:the size of the dictionary block in use, (allocated size, m, is below to preserve ABI)$/;"	m	struct:__anon19
n	kfunc.c	/^    int n11, n1_, n_1, n;$/;"	m	struct:__anon7	file:
n	sam.c	/^    int cnt, n, max;$/;"	m	struct:__anon5	file:
n	sam.c	/^    int n;$/;"	m	struct:__bam_mplp_t	file:
n	thread_pool.c	/^    int n;$/;"	m	struct:__anon110	file:
n	thread_pool.c	/^    int n;$/;"	m	struct:squareB_opt	file:
n11	kfunc.c	/^    int n11, n1_, n_1, n;$/;"	m	struct:__anon7	file:
n1_	kfunc.c	/^    int n11, n1_, n_1, n;$/;"	m	struct:__anon7	file:
nTL	cram/cram_structs.h	/^    int nTL;		         \/\/ number of TL entries in TD$/;"	m	struct:cram_block_compression_hdr
nTN	cram/cram_structs.h	/^    int           nTN, aTN;  \/\/ used and allocated size for TN[]$/;"	m	struct:cram_slice
n_1	kfunc.c	/^    int n11, n1_, n_1, n;$/;"	m	struct:__anon7	file:
n_allele	htslib/vcf.h	/^    uint32_t n_info:16, n_allele:16;$/;"	m	struct:__anon25
n_bins	hts.c	/^    int fmt, min_shift, n_lvls, n_bins;$/;"	m	struct:__hts_idx_t	file:
n_cigar	htslib/sam.h	/^    uint32_t n_cigar;$/;"	m	struct:__anon37
n_count	thread_pool_internal.h	/^    int n_count, n_running;$/;"	m	struct:hts_tpool
n_flt	htslib/vcf.h	/^    int n_flt;  \/\/ Number of FILTER fields$/;"	m	struct:__anon24
n_fmt	htslib/vcf.h	/^    uint32_t n_fmt:8, n_sample:24;$/;"	m	struct:__anon25
n_info	htslib/vcf.h	/^    uint32_t n_info:16, n_allele:16;$/;"	m	struct:__anon25
n_input	thread_pool_internal.h	/^    int n_input;                     \/\/ no. items in input queue; was njobs$/;"	m	struct:hts_tpool_process
n_lvls	hts.c	/^    int fmt, min_shift, n_lvls, n_bins;$/;"	m	struct:__hts_idx_t	file:
n_mapped	hts.c	/^        uint64_t n_mapped, n_unmapped;$/;"	m	struct:__hts_idx_t::__anon3	file:
n_no_coor	hts.c	/^    uint64_t n_no_coor;$/;"	m	struct:__hts_idx_t	file:
n_off	htslib/hts.h	/^    int tid, beg, end, n_off, i;$/;"	m	struct:__anon14
n_output	thread_pool_internal.h	/^    int n_output;                    \/\/ no. items in output queue$/;"	m	struct:hts_tpool_process
n_plp	sam.c	/^    int *n_plp;$/;"	m	struct:__bam_mplp_t	file:
n_processing	thread_pool_internal.h	/^    int n_processing;                \/\/ no. items being processed (executing)$/;"	m	struct:hts_tpool_process
n_running	thread_pool_internal.h	/^    int n_count, n_running;$/;"	m	struct:hts_tpool
n_sample	htslib/vcf.h	/^    uint32_t n_fmt:8, n_sample:24;$/;"	m	struct:__anon25
n_smpl	htslib/synced_bcf_reader.h	/^    int *samples, n_smpl;   \/\/ list of columns in the order consistent with bcf_srs_t.samples$/;"	m	struct:__anon29
n_smpl	htslib/synced_bcf_reader.h	/^    int n_smpl;$/;"	m	struct:__anon31
n_targets	htslib/sam.h	/^    int32_t n_targets, ignore_sam_err;$/;"	m	struct:__anon36
n_threads	bgzf.c	/^    int n_threads;$/;"	m	struct:bgzf_mtaux_t	file:
n_threads	htslib/synced_bcf_reader.h	/^    int n_threads;      \/\/ Simple multi-threaded decoding \/ encoding.$/;"	m	struct:__anon31
n_unmapped	hts.c	/^        uint64_t n_mapped, n_unmapped;$/;"	m	struct:__hts_idx_t::__anon3	file:
n_var	htslib/vcf.h	/^    int n_var, var_type;$/;"	m	struct:__anon24
nalloc	cram/cram_structs.h	/^    int nslice, nalloc;   \/\/ total number of slices$/;"	m	struct:cram_index
nals	htslib/synced_bcf_reader.h	/^    int nals, mals;         \/\/ number of set alleles and the size of allocated array$/;"	m	struct:_bcf_sr_regions_t
nalt	bcf_sr_sort.h	/^    int nalt;       \/\/ number of alternate alleles in this record$/;"	m	struct:__anon115
name	cram/cram_structs.h	/^    char *name;$/;"	m	struct:ref_entry
name	cram/cram_structs.h	/^    int32_t name;         \/\/ RN; idx to s->names_blk$/;"	m	struct:cram_record
name	cram/sam_header.h	/^    char *name;$/;"	m	struct:__anon62
name	cram/sam_header.h	/^    char *name;$/;"	m	struct:__anon63
name	cram/sam_header.h	/^    char *name;$/;"	m	struct:__anon64
name	hfile_internal.h	/^    const char *name;$/;"	m	struct:hFILE_plugin
name_blk	cram/cram_structs.h	/^    cram_block *name_blk;$/;"	m	struct:cram_slice
name_len	cram/cram_structs.h	/^    int32_t name_len;$/;"	m	struct:cram_record
name_len	cram/sam_header.h	/^    int name_len;$/;"	m	struct:__anon63
name_len	cram/sam_header.h	/^    int name_len;$/;"	m	struct:__anon64
naux_block	cram/cram_structs.h	/^    int naux_block;$/;"	m	struct:cram_slice
nbits	cram/cram_codecs.h	/^    int32_t nbits;$/;"	m	struct:__anon71
nbuffer	htslib/synced_bcf_reader.h	/^    int nbuffer, mbuffer;           \/\/ number of cached records (including the current record); number of allocated records$/;"	m	struct:__anon29
ncigar	cram/cram_structs.h	/^    int32_t ncigar;$/;"	m	struct:cram_record
ncigar	cram/cram_structs.h	/^    uint32_t   ncigar;$/;"	m	struct:cram_slice
ncodes	cram/cram_codecs.h	/^    int ncodes;$/;"	m	struct:__anon69
net_backend	hfile_net.c	/^static const struct hFILE_backend net_backend =$/;"	v	typeref:struct:hFILE_backend	file:
net_close	hfile_net.c	/^static int net_close(hFILE *fpv)$/;"	f	file:
net_exit	hfile_net.c	/^static void net_exit(void)$/;"	f	file:
net_init	hfile_net.c	/^static int net_init(void)$/;"	f	file:
net_inited	hfile_net.c	/^static int net_inited = 0;$/;"	v	file:
net_read	hfile_net.c	/^static ssize_t net_read(hFILE *fpv, void *buffer, size_t nbytes)$/;"	f	file:
net_seek	hfile_net.c	/^static off_t net_seek(hFILE *fpv, off_t offset, int whence)$/;"	f	file:
netclose	htslib/knetfile.h	37;"	d
netclose	htslib/knetfile.h	42;"	d
netfp	hfile_net.c	/^    knetFile *netfp;$/;"	m	struct:__anon42	file:
netread	htslib/knetfile.h	35;"	d
netread	htslib/knetfile.h	40;"	d
netwrite	htslib/knetfile.h	36;"	d
netwrite	htslib/knetfile.h	41;"	d
new_pool	cram/pooled_alloc.c	/^static pool_t *new_pool(pool_alloc_t *p) {$/;"	f	file:
new_string_pool	cram/string_alloc.c	/^static string_t *new_string_pool(string_alloc_t *a_str) {$/;"	f	file:
next	cram/cram_structs.h	/^    struct cram_map *next; \/\/ for noddy internal hash$/;"	m	struct:cram_map	typeref:struct:cram_map::cram_map
next	cram/cram_structs.h	/^    struct spare_bams *next;$/;"	m	struct:spare_bams	typeref:struct:spare_bams::spare_bams
next	cram/sam_header.h	/^    struct SAM_hdr_item_s *next; \/\/ cirular$/;"	m	struct:SAM_hdr_item_s	typeref:struct:SAM_hdr_item_s::SAM_hdr_item_s
next	cram/sam_header.h	/^    struct SAM_hdr_tag_s *next;$/;"	m	struct:SAM_hdr_tag_s	typeref:struct:SAM_hdr_tag_s::SAM_hdr_tag_s
next	hfile.c	/^    struct hFILE_plugin_list *next;$/;"	m	struct:hFILE_plugin_list	typeref:struct:hFILE_plugin_list::hFILE_plugin_list	file:
next	htslib/hts.h	/^    struct hts_opt *next;$/;"	m	struct:hts_opt	typeref:struct:hts_opt::hts_opt
next	sam.c	/^    struct __linkbuf_t *next;$/;"	m	struct:__linkbuf_t	typeref:struct:__linkbuf_t::__linkbuf_t	file:
next	thread_pool_internal.h	/^    struct hts_tpool_job *next;$/;"	m	struct:hts_tpool_job	typeref:struct:hts_tpool_job::hts_tpool_job
next	thread_pool_internal.h	/^    struct hts_tpool_process *next, *prev;\/\/ to form circular linked list.$/;"	m	struct:hts_tpool_process	typeref:struct:hts_tpool_process::hts_tpool_process
next	thread_pool_internal.h	/^    struct hts_tpool_result *next;$/;"	m	struct:hts_tpool_result	typeref:struct:hts_tpool_result::hts_tpool_result
next_power_2	cram/pooled_alloc.c	/^static int next_power_2(unsigned int v) {$/;"	f	file:
next_serial	thread_pool_internal.h	/^    uint64_t next_serial;            \/\/ next serial for output$/;"	m	struct:hts_tpool_process
next_trial	cram/cram_structs.h	/^    int next_trial;$/;"	m	struct:__anon80
nfailures	test/fieldarith.c	/^int nfailures = 0;$/;"	v
nfeature	cram/cram_structs.h	/^    int32_t nfeature;     \/\/ number of features$/;"	m	struct:cram_record
nfeatures	cram/cram_structs.h	/^    int           nfeatures;$/;"	m	struct:cram_slice
nfilter_ids	htslib/synced_bcf_reader.h	/^    int nfilter_ids, *filter_ids;   \/\/ -1 for ".", otherwise filter id as returned by bcf_hdr_id2int$/;"	m	struct:__anon29
ngrp	bcf_sr_sort.h	/^    int ngrp, mgrp;$/;"	m	struct:__anon118
nhrec	htslib/vcf.h	/^    int nhrec, dirty;$/;"	m	struct:__anon19
nidx	regidx.c	/^    int *idx, nidx;$/;"	m	struct:__anon41	file:
nidx	vcf_sweep.c	/^    int iidx, nidx, midx;   \/\/ i: current offset; n: used; m: allocated$/;"	m	struct:_bcf_sweep_t	file:
njobs	thread_pool_internal.h	/^    int njobs;    \/\/ how many total jobs are waiting in all queues$/;"	m	struct:hts_tpool
nkeys	htslib/vcf.h	/^    int nkeys;              \/\/ Number of structured fields$/;"	m	struct:__anon16
no_compression	htslib/hts.h	/^    no_compression, gzip, bgzf, custom,$/;"	e	enum:htsCompression
no_eof	htslib/synced_bcf_reader.h	/^    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error$/;"	e	enum:__anon30
no_eof_block	htslib/bgzf.h	/^    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;$/;"	m	struct:BGZF
no_memory	htslib/synced_bcf_reader.h	/^    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error$/;"	e	enum:__anon30
no_reconnect	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
no_ref	cram/cram_structs.h	/^    int no_ref;$/;"	m	struct:cram_fd
noff	bcf_sr_sort.h	/^    int moff, noff, *off, mcharp;$/;"	m	struct:__anon118
noffs	bgzf.c	/^    int noffs, moffs;       \/\/ the size of the index, n:used, m:allocated$/;"	m	struct:__bgzidx_t	file:
none_processing_c	thread_pool_internal.h	/^    pthread_cond_t none_processing_c;\/\/ n_processing has hit zero$/;"	m	struct:hts_tpool_process
not_bgzf	htslib/synced_bcf_reader.h	/^    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,$/;"	e	enum:__anon30
nparts	multipart.c	/^    size_t nparts, maxparts, current;$/;"	m	struct:__anon104	file:
npg	cram/sam_header.h	/^    int npg;                  \/\/!< Number of \\@PG lines$/;"	m	struct:__anon65
npg_end	cram/sam_header.h	/^    int npg_end;              \/\/!< Number of terminating \\@PG lines$/;"	m	struct:__anon65
npg_end_alloc	cram/sam_header.h	/^    int npg_end_alloc;        \/\/!< Size of pg_end field$/;"	m	struct:__anon65
npools	cram/pooled_alloc.h	/^    size_t npools;$/;"	m	struct:__anon55
nreaders	htslib/synced_bcf_reader.h	/^    int nreaders;$/;"	m	struct:__anon31
nrec	bcf_sr_sort.h	/^    int nrec, mrec;$/;"	m	struct:__anon114
nrec	vcf_sweep.c	/^    int nrec, mrec;         \/\/ number of used records; total size of the buffer$/;"	m	struct:_bcf_sweep_t	file:
nref	cram/cram_structs.h	/^    int nref;              \/\/ number of ref_entry$/;"	m	struct:__anon93
nref	cram/sam_header.h	/^    int nref;                 \/\/!< Number of \\@SQ lines$/;"	m	struct:__anon65
nregs	regidx.c	/^    int nregs, mregs;   \/\/ n:used, m:alloced$/;"	m	struct:__anon41	file:
nregs	synced_bcf_reader.c	/^    int nregs, mregs, creg;$/;"	m	struct:_region_t	file:
nrg	cram/sam_header.h	/^    int nrg;                  \/\/!< Number of \\@RG lines$/;"	m	struct:__anon65
nrunning	hfile_libcurl.c	/^    int nrunning;$/;"	m	struct:__anon100	file:
nsamp	cram/cram_structs.h	/^    int nsamp; \/\/ total number of values added$/;"	m	struct:cram_stats
nsamples_ori	htslib/vcf.h	/^    int nsamples_ori;           \/\/ for bcf_hdr_set_samples()$/;"	m	struct:__anon19
nseq	cram/cram_structs.h	/^    int     nseq;   \/\/ 1.0 - undocumented$/;"	m	struct:cram_index
nseq	regidx.c	/^    int nseq, mseq;     \/\/ n:used, m:alloced$/;"	m	struct:_regidx_t	file:
nseqs	htslib/synced_bcf_reader.h	/^    int nseqs;              \/\/ number of sequences (chromosomes) in the file$/;"	m	struct:_bcf_sr_regions_t
nslice	cram/cram_structs.h	/^    int nslice, nalloc;   \/\/ total number of slices$/;"	m	struct:cram_index
nsr	bcf_sr_sort.h	/^    int pos, nsr, msr;$/;"	m	struct:__anon118
nstrings	cram/string_alloc.h	/^    size_t nstrings;$/;"	m	struct:__anon61
ntags	cram/cram_structs.h	/^    int32_t ntags;        \/\/ TC$/;"	m	struct:cram_record
ntests	test/fieldarith.c	/^int ntests = 0;$/;"	v
ntransl	htslib/vcf.h	/^    int ntransl, *transl[2];    \/\/ for bcf_translate()$/;"	m	struct:__anon19
num	hfile_libcurl.c	/^    unsigned int num;$/;"	m	struct:__anon98	file:
num_bases	cram/cram_structs.h	/^    int64_t  num_bases;$/;"	m	struct:cram_container
num_blocks	cram/cram_structs.h	/^    int32_t  num_blocks;$/;"	m	struct:cram_container
num_blocks	cram/cram_structs.h	/^    int32_t num_blocks;$/;"	m	struct:cram_block_slice_hdr
num_content_ids	cram/cram_structs.h	/^    int32_t num_content_ids;$/;"	m	struct:cram_block_slice_hdr
num_landmarks	cram/cram_structs.h	/^    int32_t  num_landmarks;$/;"	m	struct:cram_container
num_landmarks	cram/cram_structs.h	/^    int32_t num_landmarks;$/;"	m	struct:cram_block_compression_hdr
num_records	cram/cram_structs.h	/^    int32_t  num_records;$/;"	m	struct:cram_container
num_records	cram/cram_structs.h	/^    int32_t num_records;$/;"	m	struct:cram_block_compression_hdr
num_records	cram/cram_structs.h	/^    int32_t num_records;$/;"	m	struct:cram_block_slice_hdr
nvals	cram/cram_codecs.h	/^    int nvals;$/;"	m	struct:__anon70
nvals	cram/cram_structs.h	/^    int nvals; \/\/ total number of unique values added$/;"	m	struct:cram_stats
nvar	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ list of compatible variants that can be output together$/;"	m	struct:__anon117
nvar	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ the variants and their type$/;"	m	struct:__anon116
nvar	bcf_sr_sort.h	/^    int nvar, mvar;$/;"	m	struct:__anon118
nvcf	bcf_sr_sort.h	/^    int nvcf, mvcf, *vcf;   \/\/ the list of readers with the same variants$/;"	m	struct:__anon115
nvcf	bcf_sr_sort.h	/^    int nvcf;               \/\/ number of readers with the same variants$/;"	m	struct:__anon116
nvset	bcf_sr_sort.h	/^    int nvset, mvset;$/;"	m	struct:__anon118
nwaiting	thread_pool_internal.h	/^    int nwaiting; \/\/ how many workers waiting for new jobs$/;"	m	struct:hts_tpool
o	thread_pool.c	/^    pipe_opt *o;$/;"	m	struct:__anon111	file:
obj	hfile_internal.h	/^    void *obj;$/;"	m	struct:hFILE_plugin
off	bcf_sr_sort.h	/^    int moff, noff, *off, mcharp;$/;"	m	struct:__anon118
off	htslib/hts.h	/^    hts_pair64_t *off;$/;"	m	struct:__anon14
off_beg	hts.c	/^        uint64_t off_beg, off_end;$/;"	m	struct:__hts_idx_t::__anon3	file:
off_end	hts.c	/^        uint64_t off_beg, off_end;$/;"	m	struct:__hts_idx_t::__anon3	file:
offs	bgzf.c	/^    bgzidx1_t *offs;        \/\/ offsets$/;"	m	struct:__bgzidx_t	file:
offset	cram/cram_codecs.h	/^    int32_t offset;$/;"	m	struct:__anon71
offset	cram/cram_codecs.h	/^    int32_t offset;$/;"	m	struct:__anon72
offset	cram/cram_codecs.h	/^    int32_t offset;$/;"	m	struct:__anon73
offset	cram/cram_structs.h	/^    int offset; \/* Offset into a single block of memory *\/$/;"	m	struct:cram_map
offset	cram/cram_structs.h	/^    int64_t offset; \/\/ 1.0                 1.1$/;"	m	struct:cram_index
offset	cram/cram_structs.h	/^    int64_t offset;$/;"	m	struct:ref_entry
offset	cram/cram_structs.h	/^    size_t   offset;$/;"	m	struct:cram_container
offset	cram/mFILE.h	/^    size_t offset;$/;"	m	struct:__anon58
offset	faidx.c	/^    uint64_t offset;$/;"	m	struct:__anon112	file:
offset	hts.c	/^    uint64_t *offset;$/;"	m	struct:__anon2	file:
offset	htslib/hfile.h	/^    off_t offset;$/;"	m	struct:hFILE
offset	htslib/knetfile.h	/^	int64_t offset;$/;"	m	struct:knetFile_s
offset	vcf.c	/^    int key, max_m, size, offset;$/;"	m	struct:__anon50	file:
olap_hash_t	sam.c	/^typedef khash_t(olap_hash) olap_hash_t;$/;"	t	file:
ooc	cram/cram_structs.h	/^    int ooc;                            \/\/ out of containers.$/;"	m	struct:cram_fd
open_failed	htslib/synced_bcf_reader.h	/^    open_failed, not_bgzf, idx_load_failed, file_type_error, api_usage_error,$/;"	e	enum:__anon30
open_nextdir	plugin.c	/^static DIR *open_nextdir(struct hts_path_itr *itr)$/;"	f	file:
open_path_mfile	cram/open_trace_file.c	/^mFILE *open_path_mfile(char *file, char *path, char *relative_to) {$/;"	f
ops	hfile.c	/^	hFILE_callback_ops ops;$/;"	m	struct:__anon108	file:
opt	htslib/hts.h	/^    enum hts_fmt_option opt;  \/\/ tokenised key$/;"	m	struct:hts_opt	typeref:enum:hts_opt::hts_fmt_option
order	cram/sam_header.h	/^    int order;                   \/\/ 0 upwards$/;"	m	struct:SAM_hdr_item_s
orig_method	cram/cram_structs.h	/^    enum cram_block_method  method, orig_method;$/;"	m	struct:cram_block	typeref:enum:cram_block::
out	cram/cram_codecs.h	/^    cram_block *out;$/;"	m	struct:cram_codec
out_queue	bgzf.c	/^    hts_tpool_process *out_queue;$/;"	m	struct:bgzf_mtaux_t	file:
output_avail_c	thread_pool_internal.h	/^    pthread_cond_t output_avail_c;   \/\/ Signalled on each new output$/;"	m	struct:hts_tpool_process
output_head	thread_pool_internal.h	/^    hts_tpool_result *output_head;   \/\/ output list$/;"	m	struct:hts_tpool_process
output_row	test/test-bcf-sr.pl	/^sub output_row$/;"	s
output_tail	thread_pool_internal.h	/^    hts_tpool_result *output_tail;$/;"	m	struct:hts_tpool_process
overlap_push	sam.c	/^static void overlap_push(bam_plp_t iter, lbnode_t *node)$/;"	f	file:
overlap_remove	sam.c	/^static void overlap_remove(bam_plp_t iter, const bam1_t *b)$/;"	f	file:
overlaps	sam.c	/^    olap_hash_t *overlaps;$/;"	m	struct:__bam_plp_t	file:
own_pool	bgzf.c	/^    int own_pool;$/;"	m	struct:bgzf_mtaux_t	file:
own_pool	cram/cram_structs.h	/^    int own_pool;$/;"	m	struct:cram_fd
p	cram/cram_codecs.h	/^    int32_t p; \/\/ next code start value, minus index to codes[]$/;"	m	struct:__anon68
p	cram/cram_structs.h	/^    char *p;$/;"	m	union:__anon79
p	htslib/kstring.h	/^	const char *p; \/\/ end of the current token$/;"	m	struct:__anon32
p	htslib/sam.h	/^    void *p;$/;"	m	union:__anon39
p	htslib/synced_bcf_reader.h	/^    htsThreadPool *p;   \/\/ Our pool, but it can be used by others if needed.$/;"	m	struct:__anon31
p	htslib/vcf.h	/^    uint8_t *p;         \/\/ same as vptr and vptr_* in bcf_info_t below$/;"	m	struct:__anon21
p	kfunc.c	/^    double p;$/;"	m	struct:__anon7	file:
p	thread_pool.c	/^    hts_tpool *p;$/;"	m	struct:__anon110	file:
p	thread_pool.c	/^    hts_tpool *p;$/;"	m	struct:squareB_opt	file:
p	thread_pool_internal.h	/^    struct hts_tpool *p;             \/\/ thread pool$/;"	m	struct:hts_tpool_process	typeref:struct:hts_tpool_process::hts_tpool
p	thread_pool_internal.h	/^    struct hts_tpool *p;$/;"	m	struct:__anon6	typeref:struct:__anon6::hts_tpool
p	thread_pool_internal.h	/^    struct hts_tpool *p;$/;"	m	struct:hts_tpool_job	typeref:struct:hts_tpool_job::hts_tpool
p_free	htslib/vcf.h	/^    uint32_t p_off:31, p_free:1;$/;"	m	struct:__anon21
p_len	htslib/vcf.h	/^    uint32_t p_len;$/;"	m	struct:__anon21
p_off	htslib/vcf.h	/^    uint32_t p_off:31, p_free:1;$/;"	m	struct:__anon21
packInt16	bgzf.c	/^static inline void packInt16(uint8_t *buffer, uint16_t value)$/;"	f	file:
packInt32	bgzf.c	/^static inline void packInt32(uint8_t *buffer, uint32_t value)$/;"	f	file:
pair	bcf_sr_sort.h	/^    int pair;$/;"	m	struct:__anon118
pair	cram/cram_structs.h	/^    khash_t(m_s2i) *pair[2];   \/\/ for identifying read-pairs in this slice.$/;"	m	struct:cram_slice
pair64_lt	hts.c	1271;"	d	file:
pair_keys	cram/cram_structs.h	/^    string_alloc_t *pair_keys; \/\/ Pooled keys for pair hash.$/;"	m	struct:cram_slice
pair_lines	test/test-bcf-sr.pl	/^sub pair_lines$/;"	s
pairing_score	bcf_sr_sort.c	/^int32_t pairing_score(sr_sort_t *srt, int ivset, int jvset)$/;"	f
pairing_score	test/test-bcf-sr.pl	/^sub pairing_score$/;"	s
parse	regidx.c	/^    regidx_parse_f parse;   \/\/ parse one input line$/;"	m	struct:_regidx_t	file:
parse_ga4gh_body_json	multipart.c	/^parse_ga4gh_body_json(hFILE_multipart *fp, hFILE *json,$/;"	f	file:
parse_ga4gh_redirect_json	multipart.c	/^parse_ga4gh_redirect_json(hFILE_multipart *fp, hFILE *json,$/;"	f	file:
parse_ini	hfile_s3.c	/^static void parse_ini(const char *fname, const char *section, ...)$/;"	f	file:
parse_params	test/test-bcf-sr.pl	/^sub parse_params$/;"	s
parse_params	test/test.pl	/^sub parse_params$/;"	s
parse_regions	tabix.c	/^static char **parse_regions(char *regions_fname, char **argv, int argc, int *nregs)$/;"	f	file:
parse_simple	hfile_s3.c	/^static void parse_simple(const char *fname, kstring_t *id, kstring_t *secret)$/;"	f	file:
parse_va_list	hfile_libcurl.c	/^static int parse_va_list(http_headers *headers, va_list args)$/;"	f	file:
parse_version	hts.c	/^parse_version(htsFormat *fmt, const unsigned char *u, const unsigned char *ulim)$/;"	f	file:
parts	multipart.c	/^    hfile_part *parts;$/;"	m	struct:__anon104	file:
passed	test/test.pl	/^sub passed$/;"	s
pasv_ip	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
pasv_port	htslib/knetfile.h	/^	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;$/;"	m	struct:knetFile_s
path	hts_internal.h	/^    kstring_t path, entry;$/;"	m	struct:hts_path_itr
path	htslib/knetfile.h	/^	char *path, *http_host;$/;"	m	struct:knetFile_s
pathdir	hts_internal.h	/^    const char *pathdir, *prefix, *suffix;$/;"	m	struct:hts_path_itr
paused	hfile_libcurl.c	/^    unsigned paused : 1;    \/\/ callback tells us that it has paused transfer$/;"	m	struct:__anon100	file:
payload	htslib/regidx.h	/^    void *payload;$/;"	m	struct:__anon27
payload	regidx.c	/^    void *payload;$/;"	m	struct:__anon41	file:
payload	regidx.c	/^    void *payload;$/;"	m	struct:_regidx_t	file:
payload_size	regidx.c	/^    int payload_size;$/;"	m	struct:_regidx_t	file:
pclose	cram/os.h	199;"	d
pending_c	thread_pool_internal.h	/^    pthread_cond_t  pending_c; \/\/ when waiting for a job$/;"	m	struct:__anon6
perform_again	hfile_libcurl.c	/^    unsigned perform_again : 1;$/;"	m	struct:__anon100	file:
pg	cram/sam_header.h	/^    SAM_PG *pg;		      \/\/!< Array of parsed \\@PG lines$/;"	m	struct:__anon65
pg_end	cram/sam_header.h	/^    int *pg_end;              \/\/!< \\@PG chain termination IDs$/;"	m	struct:__anon65
pg_hash	cram/sam_header.h	/^    khash_t(m_s2i) *pg_hash;  \/\/!< Maps PG ID field to pg[] index$/;"	m	struct:__anon65
pipe_input_thread	thread_pool.c	/^static void *pipe_input_thread(void *arg) {$/;"	f	file:
pipe_job	thread_pool.c	/^} pipe_job;$/;"	t	typeref:struct:__anon111	file:
pipe_opt	thread_pool.c	/^} pipe_opt;$/;"	t	typeref:struct:__anon110	file:
pipe_output_thread	thread_pool.c	/^static void *pipe_output_thread(void *arg) {$/;"	f	file:
pipe_stage1	thread_pool.c	/^static void *pipe_stage1(void *arg) {$/;"	f	file:
pipe_stage1to2	thread_pool.c	/^static void *pipe_stage1to2(void *arg) {$/;"	f	file:
pipe_stage2	thread_pool.c	/^static void *pipe_stage2(void *arg) {$/;"	f	file:
pipe_stage2to3	thread_pool.c	/^static void *pipe_stage2to3(void *arg) {$/;"	f	file:
pipe_stage3	thread_pool.c	/^static void *pipe_stage3(void *arg) {$/;"	f	file:
pkgconfigdir	Makefile	/^pkgconfigdir= $(libdir)\/pkgconfig$/;"	m
plp	sam.c	/^    bam_pileup1_t *plp;$/;"	m	struct:__bam_plp_t	file:
plp	sam.c	/^    const bam_pileup1_t **plp;$/;"	m	struct:__bam_mplp_t	file:
plp_construct	sam.c	/^    int (*plp_construct)(void *data, const bam1_t *b, bam_pileup_cd *cd);$/;"	m	struct:__bam_plp_t	file:
plp_destruct	sam.c	/^    int (*plp_destruct )(void *data, const bam1_t *b, bam_pileup_cd *cd);$/;"	m	struct:__bam_plp_t	file:
plugin	hfile.c	/^    struct hFILE_plugin plugin;$/;"	m	struct:hFILE_plugin_list	typeref:struct:hFILE_plugin_list::hFILE_plugin	file:
plugin_sym	plugin.c	/^void *plugin_sym(void *plugin, const char *name, const char **errmsg)$/;"	f
plugindir	Makefile	/^plugindir =$/;"	m
plugins	hfile.c	/^static struct hFILE_plugin_list *plugins = NULL;$/;"	v	typeref:struct:hFILE_plugin_list	file:
plugins_lock	hfile.c	/^static pthread_mutex_t plugins_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
pmap_t	cram/cram_structs.h	/^} pmap_t;$/;"	t	typeref:union:__anon79
pmat	bcf_sr_sort.h	/^    int mpmat, *pmat;       \/\/ pairing matrix, i-th vset and j-th group accessible as i*ngrp+j$/;"	m	struct:__anon118
pool	bgzf.c	/^    hts_tpool *pool;$/;"	m	struct:bgzf_mtaux_t	file:
pool	cram/cram_structs.h	/^    hts_tpool *pool;$/;"	m	struct:cram_fd
pool	cram/cram_structs.h	/^    string_alloc_t *pool;  \/\/ String pool for holding filenames and SN vals$/;"	m	struct:__anon93
pool	cram/pooled_alloc.h	/^    void   *pool;$/;"	m	struct:__anon54
pool	htslib/hts.h	/^    struct hts_tpool *pool; \/\/ The shared thread pool itself$/;"	m	struct:__anon11	typeref:struct:__anon11::hts_tpool
pool_alloc	cram/pooled_alloc.c	/^void *pool_alloc(pool_alloc_t *p) {$/;"	f
pool_alloc_t	cram/pooled_alloc.h	/^} pool_alloc_t;$/;"	t	typeref:struct:__anon55
pool_create	cram/pooled_alloc.c	/^pool_alloc_t *pool_create(size_t dsize) {$/;"	f
pool_destroy	cram/pooled_alloc.c	/^void pool_destroy(pool_alloc_t *p) {$/;"	f
pool_free	cram/pooled_alloc.c	/^void pool_free(pool_alloc_t *p, void *ptr) {$/;"	f
pool_m	thread_pool_internal.h	/^    pthread_mutex_t pool_m;$/;"	m	struct:hts_tpool
pool_t	cram/pooled_alloc.h	/^} pool_t;$/;"	t	typeref:struct:__anon54
pools	cram/pooled_alloc.h	/^    pool_t *pools;$/;"	m	struct:__anon55
popen	cram/os.h	198;"	d
port	htslib/knetfile.h	/^	char *host, *port;$/;"	m	struct:knetFile_s
pos	bcf_sr_sort.h	/^    int pos, nsr, msr;$/;"	m	struct:__anon118
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon82
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon83
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon84
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon85
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon86
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon87
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon88
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon89
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon90
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon91
pos	cram/cram_structs.h	/^	    int pos;$/;"	m	struct:cram_feature::__anon81::__anon92
pos	htslib/sam.h	/^    int32_t pos;$/;"	m	struct:__anon37
pos	htslib/vcf.h	/^    int32_t pos;  \/\/ POS$/;"	m	struct:__anon25
pos	sam.c	/^    int32_t tid, pos, max_tid, max_pos;$/;"	m	struct:__bam_plp_t	file:
pos	sam.c	/^    uint64_t min, *pos;$/;"	m	struct:__bam_mplp_t	file:
pos_sorted	cram/cram_structs.h	/^    int pos_sorted;              \/\/ boolean, 1=>position sorted data$/;"	m	struct:cram_container
prefix	Makefile	/^prefix      = \/usr\/local$/;"	m
prefix	cram/cram_structs.h	/^    char          *prefix;$/;"	m	struct:cram_fd
prefix	hts_internal.h	/^    const char *pathdir, *prefix, *suffix;$/;"	m	struct:hts_path_itr
prefix_len	hts_internal.h	/^    size_t prefix_len, suffix_len, entry_dir_l;$/;"	m	struct:hts_path_itr
preservation_map	cram/cram_structs.h	/^    khash_t(map) *preservation_map;$/;"	m	struct:cram_block_compression_hdr
preset	htslib/tbx.h	/^    int32_t preset;$/;"	m	struct:__anon34
prev	cram/sam_header.h	/^    struct SAM_hdr_item_s *prev;$/;"	m	struct:SAM_hdr_item_s	typeref:struct:SAM_hdr_item_s::SAM_hdr_item_s
prev	thread_pool_internal.h	/^    struct hts_tpool_process *next, *prev;\/\/ to form circular linked list.$/;"	m	struct:hts_tpool_process	typeref:struct:hts_tpool_process::
prev_id	cram/sam_header.h	/^    int prev_id;      \/\/ -1 if none$/;"	m	struct:__anon64
prev_seq	htslib/synced_bcf_reader.h	/^    int prev_seq, prev_start;$/;"	m	struct:_bcf_sr_regions_t
prev_start	htslib/synced_bcf_reader.h	/^    int prev_seq, prev_start;$/;"	m	struct:_bcf_sr_regions_t
print_header	tabix.c	/^    int print_header, header_only;$/;"	m	struct:__anon97	file:
priority	hfile.c	/^static inline int priority(const struct hFILE_scheme_handler *handler)$/;"	f	file:
priority	hfile_internal.h	/^    int priority;$/;"	m	struct:hFILE_scheme_handler
probaln_glocal	probaln.c	/^int probaln_glocal(const uint8_t *_ref, int l_ref, const uint8_t *_query, int l_query,$/;"	f
probaln_par_t	htslib/hts.h	/^typedef struct probaln_par_t {$/;"	s
probaln_par_t	htslib/hts.h	/^} probaln_par_t;$/;"	t	typeref:struct:probaln_par_t
process_messages	hfile_libcurl.c	/^static void process_messages(hFILE_libcurl *fp)$/;"	f	file:
process_one_read	cram/cram_encode.c	/^static int process_one_read(cram_fd *fd, cram_container *c,$/;"	f	file:
provider	hfile_internal.h	/^    const char *provider;$/;"	m	struct:hFILE_scheme_handler
psize	cram/pooled_alloc.h	/^    size_t psize;$/;"	m	struct:__anon55
ptr	hfile_libcurl.c	/^        union { char *rd; const char *wr; } ptr;$/;"	m	struct:__anon100::__anon101	typeref:union:__anon100::__anon101::__anon102	file:
push_digit	hts.c	/^static inline long long push_digit(long long i, char c)$/;"	f	file:
push_vset	bcf_sr_sort.c	/^void push_vset(sr_sort_t *srt, int ivset)$/;"	f
q	thread_pool.c	/^    hts_tpool_process *q;$/;"	m	struct:squareB_opt	file:
q	thread_pool_internal.h	/^    struct hts_tpool_process *q;$/;"	m	struct:hts_tpool_job	typeref:struct:hts_tpool_job::hts_tpool_process
q1	thread_pool.c	/^    hts_tpool_process *q1;$/;"	m	struct:__anon110	file:
q2	thread_pool.c	/^    hts_tpool_process *q2;$/;"	m	struct:__anon110	file:
q3	thread_pool.c	/^    hts_tpool_process *q3;$/;"	m	struct:__anon110	file:
q_head	thread_pool_internal.h	/^    hts_tpool_process *q_head;$/;"	m	struct:hts_tpool
qpos	htslib/sam.h	/^    int32_t qpos;$/;"	m	struct:__anon40
qs_included	cram/cram_structs.h	/^    int qs_included;$/;"	m	struct:cram_block_compression_hdr
qsize	htslib/hts.h	/^    int qsize;    \/\/ Size of I\/O queue to use for this fp$/;"	m	struct:__anon11
qsize	thread_pool_internal.h	/^    int qsize;                       \/\/ max size of i\/o queues$/;"	m	struct:hts_tpool_process
qual	cram/cram_structs.h	/^	    int qual;$/;"	m	struct:cram_feature::__anon81::__anon83
qual	cram/cram_structs.h	/^	    int qual;$/;"	m	struct:cram_feature::__anon81::__anon85
qual	cram/cram_structs.h	/^    int32_t qual;         \/\/ idx to s->qual_blk$/;"	m	struct:cram_record
qual	htslib/sam.h	/^    uint8_t qual;$/;"	m	struct:__anon37
qual	htslib/vcf.h	/^    float qual;   \/\/ QUAL$/;"	m	struct:__anon25
qual_blk	cram/cram_structs.h	/^    cram_block *qual_blk;$/;"	m	struct:cram_slice
query_chroms	tabix.c	/^static int query_chroms(char *fname)$/;"	f	file:
query_regions	tabix.c	/^static int query_regions(args_t *args, char *fname, char **regs, int nregs)$/;"	f	file:
random	htslib/hts_os.h	56;"	d
random_alt	test/test-bcf-sr.pl	/^sub random_alt$/;"	s
range	cram/cram_structs.h	/^    cram_range range;$/;"	m	struct:cram_fd
rans0_cnt	cram/cram_structs.h	/^    int rans0_cnt;$/;"	m	struct:__anon80
rans0_extra	cram/cram_structs.h	/^    double rans0_extra;$/;"	m	struct:__anon80
rans1_cnt	cram/cram_structs.h	/^    int rans1_cnt;$/;"	m	struct:__anon80
rans1_extra	cram/cram_structs.h	/^    double rans1_extra;$/;"	m	struct:__anon80
rans_compress	cram/rANS_static.c	/^unsigned char *rans_compress(unsigned char *in, unsigned int in_size,$/;"	f
rans_compress_O0	cram/rANS_static.c	/^unsigned char *rans_compress_O0(unsigned char *in, unsigned int in_size,$/;"	f
rans_compress_O1	cram/rANS_static.c	/^unsigned char *rans_compress_O1(unsigned char *in, unsigned int in_size,$/;"	f
rans_uncompress	cram/rANS_static.c	/^unsigned char *rans_uncompress(unsigned char *in, unsigned int in_size,$/;"	f
rans_uncompress_O0	cram/rANS_static.c	/^unsigned char *rans_uncompress_O0(unsigned char *in, unsigned int in_size,$/;"	f
rans_uncompress_O1	cram/rANS_static.c	/^unsigned char *rans_uncompress_O1(unsigned char *in, unsigned int in_size,$/;"	f
rcp_freq	cram/rANS_byte.h	/^    uint32_t rcp_freq;  \/\/ Fixed-point reciprocal frequency$/;"	m	struct:__anon56
rcp_shift	cram/rANS_byte.h	/^    uint16_t rcp_shift; \/\/ Reciprocal shift$/;"	m	struct:__anon56
rd	hfile_libcurl.c	/^        union { char *rd; const char *wr; } ptr;$/;"	m	union:__anon100::__anon101::__anon102	file:
read	htslib/hfile.h	/^	ssize_t (*read)(void* cb_data, void* buf, size_t sz);$/;"	m	struct:hFILE_callback_ops
read_names_included	cram/cram_structs.h	/^    int read_names_included;$/;"	m	struct:cram_block_compression_hdr
read_rest	htslib/hts.h	/^    uint32_t read_rest:1, finished:1, is_cram:1, dummy:29;$/;"	m	struct:__anon14
readers	htslib/synced_bcf_reader.h	/^    bcf_sr_t *readers;$/;"	m	struct:__anon31
readonly	htslib/hfile.h	/^    unsigned at_eof:1, mobile:1, readonly:1;$/;"	m	struct:hFILE
readrec	htslib/hts.h	/^    hts_readrec_func *readrec;$/;"	m	struct:__anon14
rec	bcf_sr_sort.h	/^    bcf1_t **rec;           \/\/ list of VCF records in the readers$/;"	m	struct:__anon115
rec	bcf_sr_sort.h	/^    bcf1_t **rec;$/;"	m	struct:__anon114
rec	vcf_sweep.c	/^    bcf1_t *rec;            \/\/ bcf buffer$/;"	m	struct:_bcf_sweep_t	file:
rec_encoding_map	cram/cram_structs.h	/^    struct cram_map *rec_encoding_map[CRAM_MAP_HASH];$/;"	m	struct:cram_block_compression_hdr	typeref:struct:cram_block_compression_hdr::cram_map
record_counter	cram/cram_structs.h	/^    int64_t        record_counter;$/;"	m	struct:cram_fd
record_counter	cram/cram_structs.h	/^    int64_t  record_counter;$/;"	m	struct:cram_container
record_counter	cram/cram_structs.h	/^    int64_t record_counter;$/;"	m	struct:cram_block_slice_hdr
recv_callback	hfile_libcurl.c	/^static size_t recv_callback(char *ptr, size_t size, size_t nmemb, void *fpv)$/;"	f	file:
ref	cram/cram_structs.h	/^    char *ref, *ref_free;      \/\/ current portion held in memory$/;"	m	struct:cram_fd
ref	cram/cram_structs.h	/^    char *ref;                 \/\/ slice of current reference$/;"	m	struct:cram_slice
ref	cram/cram_structs.h	/^    char *ref;$/;"	m	struct:cram_container
ref	cram/sam_header.h	/^    SAM_SQ *ref;              \/\/!< Array of parsed \\@SQ lines$/;"	m	struct:__anon65
ref_base_id	cram/cram_structs.h	/^    int32_t ref_base_id;    \/* if content_type == MAPPED_SLICE *\/$/;"	m	struct:cram_block_slice_hdr
ref_count	cram/sam_header.h	/^    int ref_count;      \/\/ number of uses of this SAM_hdr$/;"	m	struct:__anon65
ref_count	thread_pool_internal.h	/^    int ref_count;                   \/\/ used to track safe destruction$/;"	m	struct:hts_tpool_process
ref_end	cram/cram_structs.h	/^    int   ref_end;$/;"	m	struct:cram_fd
ref_end	cram/cram_structs.h	/^    int ref_end;               \/\/ end position of current reference;$/;"	m	struct:cram_slice
ref_end	cram/cram_structs.h	/^    int ref_start, first_base, last_base, ref_id, ref_end;$/;"	m	struct:cram_container
ref_entry	cram/cram_structs.h	/^typedef struct ref_entry {$/;"	s
ref_entry	cram/cram_structs.h	/^} ref_entry;$/;"	t	typeref:struct:ref_entry
ref_entry_free_seq	cram/cram_io.c	/^static void ref_entry_free_seq(ref_entry *e) {$/;"	f	file:
ref_fn	cram/cram_structs.h	/^    char *ref_fn;   \/\/ reference fasta filename$/;"	m	struct:cram_fd
ref_free	cram/cram_structs.h	/^    char *ref, *ref_free;      \/\/ current portion held in memory$/;"	m	struct:cram_fd
ref_hash	cram/sam_header.h	/^    khash_t(m_s2i) *ref_hash; \/\/!< Maps SQ SN field to sq[] index$/;"	m	struct:__anon65
ref_id	cram/cram_structs.h	/^    int   ref_id;$/;"	m	struct:cram_fd
ref_id	cram/cram_structs.h	/^    int ref_id;$/;"	m	struct:cram_slice
ref_id	cram/cram_structs.h	/^    int ref_start, first_base, last_base, ref_id, ref_end;$/;"	m	struct:cram_container
ref_id	cram/cram_structs.h	/^    int32_t ref_id;       \/\/ fixed for all recs in slice?$/;"	m	struct:cram_record
ref_id	cram/cram_structs.h	/^    ref_entry **ref_id;    \/\/ ref_entry*, index by ID$/;"	m	struct:__anon93
ref_lock	cram/cram_structs.h	/^    pthread_mutex_t ref_lock;$/;"	m	struct:cram_fd
ref_seq_id	cram/cram_structs.h	/^    int32_t  ref_seq_id;$/;"	m	struct:cram_container
ref_seq_id	cram/cram_structs.h	/^    int32_t ref_seq_id;     \/* if content_type == MAPPED_SLICE *\/$/;"	m	struct:cram_block_slice_hdr
ref_seq_id	cram/cram_structs.h	/^    int32_t ref_seq_id;$/;"	m	struct:cram_block_compression_hdr
ref_seq_span	cram/cram_structs.h	/^    int32_t  ref_seq_span;$/;"	m	struct:cram_container
ref_seq_span	cram/cram_structs.h	/^    int32_t ref_seq_span;   \/* if content_type == MAPPED_SLICE *\/$/;"	m	struct:cram_block_slice_hdr
ref_seq_span	cram/cram_structs.h	/^    int32_t ref_seq_span;$/;"	m	struct:cram_block_compression_hdr
ref_seq_start	cram/cram_structs.h	/^    int32_t  ref_seq_start;$/;"	m	struct:cram_container
ref_seq_start	cram/cram_structs.h	/^    int32_t ref_seq_start;  \/* if content_type == MAPPED_SLICE *\/$/;"	m	struct:cram_block_slice_hdr
ref_seq_start	cram/cram_structs.h	/^    int32_t ref_seq_start;$/;"	m	struct:cram_block_compression_hdr
ref_start	cram/cram_structs.h	/^    int   ref_start;$/;"	m	struct:cram_fd
ref_start	cram/cram_structs.h	/^    int ref_start, first_base, last_base, ref_id, ref_end;$/;"	m	struct:cram_container
ref_start	cram/cram_structs.h	/^    int ref_start;             \/\/ start position of current reference;$/;"	m	struct:cram_slice
refid	cram/cram_structs.h	/^    int     refid;  \/\/ 1.0                 1.1$/;"	m	struct:cram_index
refid	cram/cram_structs.h	/^    int refid;$/;"	m	struct:__anon94
refill_buffer	hfile.c	/^static ssize_t refill_buffer(hFILE *fp)$/;"	f	file:
refs	cram/cram_structs.h	/^    refs_t *refs;              \/\/ ref meta-data structure$/;"	m	struct:cram_fd
refs2id	cram/cram_io.c	/^int refs2id(refs_t *r, SAM_hdr *h) {$/;"	f
refs_create	cram/cram_io.c	/^static refs_t *refs_create(void) {$/;"	f	file:
refs_free	cram/cram_io.c	/^void refs_free(refs_t *r) {$/;"	f
refs_from_header	cram/cram_io.c	/^static int refs_from_header(refs_t *r, cram_fd *fd, SAM_hdr *h) {$/;"	f	file:
refs_load_fai	cram/cram_io.c	/^static refs_t *refs_load_fai(refs_t *r_orig, char *fn, int is_err) {$/;"	f	file:
refs_t	cram/cram_structs.h	/^} refs_t;$/;"	t	typeref:struct:__anon93
refs_t	htslib/cram.h	/^typedef struct refs_t refs_t;$/;"	t	typeref:struct:refs_t
refs_used	cram/cram_structs.h	/^    int *refs_used;       \/\/ array of frequency of ref seq IDs$/;"	m	struct:cram_container
reg	htslib/regidx.h	/^    reg_t *reg;$/;"	m	struct:__anon27
reg2bins	hts.c	/^static inline int reg2bins(int64_t beg, int64_t end, hts_itr_t *itr, int min_shift, int n_lvls)$/;"	f	file:
reg_t	htslib/regidx.h	/^reg_t;$/;"	t	typeref:struct:__anon26
regidx_destroy	regidx.c	/^void regidx_destroy(regidx_t *idx)$/;"	f
regidx_free_f	htslib/regidx.h	/^typedef void (*regidx_free_f)(void *payload);$/;"	t
regidx_init	regidx.c	/^regidx_t *regidx_init(const char *fname, regidx_parse_f parser, regidx_free_f free_f, size_t payload_size, void *usr_dat)$/;"	f
regidx_insert	regidx.c	/^int regidx_insert(regidx_t *idx, char *line)$/;"	f
regidx_nregs	regidx.c	/^int regidx_nregs(regidx_t *idx)$/;"	f
regidx_overlap	regidx.c	/^int regidx_overlap(regidx_t *idx, const char *chr, uint32_t from, uint32_t to, regitr_t *itr)$/;"	f
regidx_parse_bed	regidx.c	/^int regidx_parse_bed(const char *line, char **chr_beg, char **chr_end, reg_t *reg, void *payload, void *usr)$/;"	f
regidx_parse_f	htslib/regidx.h	/^typedef int  (*regidx_parse_f)(const char *line, char **chr_beg, char **chr_end, reg_t *reg, void *payload, void *usr);$/;"	t
regidx_parse_tab	regidx.c	/^int regidx_parse_tab(const char *line, char **chr_beg, char **chr_end, reg_t *reg, void *payload, void *usr)$/;"	f
regidx_seq_names	regidx.c	/^char **regidx_seq_names(regidx_t *idx, int *n)$/;"	f
regidx_seq_nregs	regidx.c	/^int regidx_seq_nregs(regidx_t *idx, const char *seq)$/;"	f
regidx_t	htslib/regidx.h	/^typedef struct _regidx_t regidx_t;$/;"	t	typeref:struct:_regidx_t
region1_t	synced_bcf_reader.c	/^region1_t;$/;"	t	typeref:struct:__anon105	file:
region_list	htslib/hts.h	/^    region_list,      \/\/ Coordinate intervals or regions -- BED, etc$/;"	e	enum:htsFormatCategory
region_t	synced_bcf_reader.c	/^region_t;$/;"	t	typeref:struct:_region_t	file:
regions	htslib/synced_bcf_reader.h	/^    bcf_sr_regions_t *regions, *targets;    \/\/ see bcf_sr_set_[targets|regions] for description$/;"	m	struct:__anon31
regions_fname	tabix.c	/^    char *regions_fname, *targets_fname;$/;"	m	struct:__anon97	file:
regitr_t	htslib/regidx.h	/^regitr_t;$/;"	t	typeref:struct:__anon27
reglist_t	regidx.c	/^reglist_t;$/;"	t	typeref:struct:__anon41	file:
regs	htslib/synced_bcf_reader.h	/^    struct _region_t *regs; \/\/ the regions$/;"	m	struct:_bcf_sr_regions_t	typeref:struct:_bcf_sr_regions_t::_region_t
regs	regidx.c	/^    reg_t *regs;$/;"	m	struct:__anon41	file:
regs	synced_bcf_reader.c	/^    region1_t *regs;$/;"	m	struct:_region_t	file:
reheader_file	tabix.c	/^int reheader_file(const char *fname, const char *header, int ftype, tbx_conf_t *conf)$/;"	f
remove_vset	bcf_sr_sort.c	/^void remove_vset(sr_sort_t *srt, int jvset)$/;"	f
reopen	test/hfile.c	/^void reopen(const char *infname, const char *outfname)$/;"	f
reopen_callback	test/hfile.c	/^void reopen_callback(const char* infname, const char* outfilename)$/;"	f
require_index	htslib/synced_bcf_reader.h	/^    int require_index;  \/\/ Some tools do not need random access$/;"	m	struct:__anon31
required_fields	cram/cram_structs.h	/^    unsigned int required_fields;$/;"	m	struct:cram_fd
reserved	htslib/bgzf.h	/^    unsigned errcode:16, reserved:1, is_write:1, no_eof_block:1, is_be:1;$/;"	m	struct:BGZF
reset	cram/cram_codecs.h	/^    void (*reset)(struct cram_codec *codec); \/\/ used between slices in a container$/;"	m	struct:cram_codec
reset_all_codecs	cram/cram_decode.c	/^static void reset_all_codecs(cram_block_compression_hdr *hdr) {$/;"	f	file:
resolve_cigar2	sam.c	/^static inline int resolve_cigar2(bam_pileup1_t *p, int32_t pos, cstate_t *s)$/;"	f	file:
response	htslib/knetfile.h	/^	char *response, *retr, *size_cmd;$/;"	m	struct:knetFile_s
retr	htslib/knetfile.h	/^	char *response, *retr, *size_cmd;$/;"	m	struct:knetFile_s
revised_method	cram/cram_structs.h	/^    int revised_method;$/;"	m	struct:__anon80
rg	cram/cram_structs.h	/^    int32_t rg;           \/\/ RG$/;"	m	struct:cram_record
rg	cram/sam_header.h	/^    SAM_RG *rg;               \/\/!< Array of parsed \\@RG lines$/;"	m	struct:__anon65
rg_hash	cram/sam_header.h	/^    khash_t(m_s2i) *rg_hash;  \/\/!< Maps RG ID field to rg[] index$/;"	m	struct:__anon65
rid	htslib/vcf.h	/^    int32_t rid;  \/\/ CHROM$/;"	m	struct:__anon25
rid_prev	regidx.c	/^    int rid_prev, start_prev, end_prev;$/;"	m	struct:_regidx_t	file:
right	htslib/ksort.h	/^	void *left, *right;$/;"	m	struct:__anon33
rlen	htslib/vcf.h	/^    int32_t rlen; \/\/ length of REF$/;"	m	struct:__anon25
rqueue	cram/cram_structs.h	/^    hts_tpool_process *rqueue;$/;"	m	struct:cram_fd
run	test/cross_validate.sh	/^run() {$/;"	f
run_out	test/cross_validate.sh	/^run_out() {$/;"	f
run_test	test/tabix/test-tabix.sh	/^run_test() {$/;"	f
run_test	test/test-bcf-sr.pl	/^sub run_test$/;"	s
s	cram/cram_decode.c	/^    cram_slice *s;$/;"	m	struct:__anon95	file:
s	cram/cram_structs.h	/^    struct cram_slice *s; \/\/ Filled out by cram_decode only$/;"	m	struct:cram_record	typeref:struct:cram_record::cram_slice
s	htslib/bgzf.h	/^    char *s;$/;"	m	struct:__kstring_t
s	htslib/hts.h	/^        char *s;$/;"	m	union:hts_opt::__anon12
s	htslib/hts.h	/^    char *s;$/;"	m	struct:__kstring_t
s	htslib/kseq.h	/^	char *s;$/;"	m	struct:__kstring_t
s	htslib/kstring.h	/^	char *s;$/;"	m	struct:__kstring_t
s	sam.c	/^    cstate_t s;$/;"	m	struct:__linkbuf_t	file:
s3_auth_data	hfile_s3.c	/^} s3_auth_data;$/;"	t	typeref:struct:__anon53	file:
s3_open	hfile_s3.c	/^static hFILE *s3_open(const char *url, const char *mode)$/;"	f	file:
s3_rewrite	hfile_s3.c	/^static hFILE * s3_rewrite(const char *s3url, const char *mode, va_list *argsp)$/;"	f	file:
s3_sign	hfile_s3.c	/^s3_sign(unsigned char *digest, kstring_t *key, kstring_t *message)$/;"	f	file:
s3_vopen	hfile_s3.c	/^static hFILE *s3_vopen(const char *url, const char *mode_colon, va_list args0)$/;"	f	file:
s_num_bases	cram/cram_structs.h	/^    uint64_t s_num_bases; \/\/ number of bases in this slice$/;"	m	struct:cram_container
safe_itf8_get	cram/cram_io.h	/^static inline int safe_itf8_get(const char *cp, const char *endp,$/;"	f
safe_ltf8_get	cram/cram_io.h	/^static inline int safe_ltf8_get(const char *cp, const char *endp,$/;"	f
safe_tempdir	test/test.pl	/^sub safe_tempdir$/;"	s
sam	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
samFile	htslib/sam.h	/^    typedef htsFile samFile;$/;"	t
sam_bam_cram_readrec	sam.c	/^static int sam_bam_cram_readrec(BGZF *bgzfp, void *fpv, void *bv, int *tid, int *beg, int *end)$/;"	f	file:
sam_cap_mapq	realn.c	/^int sam_cap_mapq(bam1_t *b, const char *ref, int ref_len, int thres)$/;"	f
sam_close	htslib/sam.h	364;"	d
sam_fields	htslib/hts.h	/^enum sam_fields {$/;"	g
sam_format1	sam.c	/^int sam_format1(const bam_hdr_t *h, const bam1_t *b, kstring_t *str)$/;"	f
sam_hdr_PG_ID	cram/sam_header.c	/^const char *sam_hdr_PG_ID(SAM_hdr *sh, const char *name) {$/;"	f
sam_hdr_add	cram/sam_header.c	/^int sam_hdr_add(SAM_hdr *sh, const char *type, ...) {$/;"	f
sam_hdr_add_PG	cram/sam_header.c	/^int sam_hdr_add_PG(SAM_hdr *sh, const char *name, ...) {$/;"	f
sam_hdr_add_lines	cram/sam_header.c	/^int sam_hdr_add_lines(SAM_hdr *sh, const char *lines, int len) {$/;"	f
sam_hdr_decr_ref	cram/sam_header.c	/^void sam_hdr_decr_ref(SAM_hdr *hdr) {$/;"	f
sam_hdr_dump	cram/sam_header.c	/^void sam_hdr_dump(SAM_hdr *hdr) {$/;"	f
sam_hdr_dup	cram/sam_header.c	/^SAM_hdr *sam_hdr_dup(SAM_hdr *hdr) {$/;"	f
sam_hdr_error	cram/sam_header.c	/^static void sam_hdr_error(char *msg, char *line, int len, int lno) {$/;"	f	file:
sam_hdr_find	cram/sam_header.c	/^SAM_hdr_type *sam_hdr_find(SAM_hdr *hdr, char *type,$/;"	f
sam_hdr_find_key	cram/sam_header.c	/^SAM_hdr_tag *sam_hdr_find_key(SAM_hdr *sh,$/;"	f
sam_hdr_find_line	cram/sam_header.c	/^char *sam_hdr_find_line(SAM_hdr *hdr, char *type,$/;"	f
sam_hdr_find_rg	cram/sam_header.c	/^SAM_RG *sam_hdr_find_rg(SAM_hdr *hdr, const char *rg) {$/;"	f
sam_hdr_free	cram/sam_header.c	/^void sam_hdr_free(SAM_hdr *hdr) {$/;"	f
sam_hdr_incr_ref	cram/sam_header.c	/^void sam_hdr_incr_ref(SAM_hdr *hdr) {$/;"	f
sam_hdr_length	cram/sam_header.c	/^int sam_hdr_length(SAM_hdr *hdr) {$/;"	f
sam_hdr_link_pg	cram/sam_header.c	/^int sam_hdr_link_pg(SAM_hdr *hdr) {$/;"	f
sam_hdr_name2ref	cram/sam_header.c	/^int sam_hdr_name2ref(SAM_hdr *hdr, const char *ref) {$/;"	f
sam_hdr_new	cram/sam_header.c	/^SAM_hdr *sam_hdr_new() {$/;"	f
sam_hdr_parse	sam.c	/^bam_hdr_t *sam_hdr_parse(int l_text, const char *text)$/;"	f
sam_hdr_parse_	cram/sam_header.c	/^SAM_hdr *sam_hdr_parse_(const char *hdr, int len) {$/;"	f
sam_hdr_parse_sort_order	cram/sam_header.c	/^static enum sam_sort_order sam_hdr_parse_sort_order(SAM_hdr *hdr) {$/;"	f	file:
sam_hdr_read	sam.c	/^bam_hdr_t *sam_hdr_read(htsFile *fp)$/;"	f
sam_hdr_rebuild	cram/sam_header.c	/^int sam_hdr_rebuild(SAM_hdr *hdr) {$/;"	f
sam_hdr_sanitise	sam.c	/^static bam_hdr_t *sam_hdr_sanitise(bam_hdr_t *h) {$/;"	f	file:
sam_hdr_sort_order	cram/sam_header.c	/^enum sam_sort_order sam_hdr_sort_order(SAM_hdr *hdr) {$/;"	f
sam_hdr_str	cram/sam_header.c	/^char *sam_hdr_str(SAM_hdr *hdr) {$/;"	f
sam_hdr_update	cram/sam_header.c	/^int sam_hdr_update(SAM_hdr *hdr, SAM_hdr_type *type, ...) {$/;"	f
sam_hdr_update_hashes	cram/sam_header.c	/^static int sam_hdr_update_hashes(SAM_hdr *sh,$/;"	f	file:
sam_hdr_vadd	cram/sam_header.c	/^int sam_hdr_vadd(SAM_hdr *sh, const char *type, va_list ap, ...) {$/;"	f
sam_hdr_write	sam.c	/^int sam_hdr_write(htsFile *fp, const bam_hdr_t *h)$/;"	f
sam_index_build	sam.c	/^int sam_index_build(const char *fn, int min_shift)$/;"	f
sam_index_build2	sam.c	/^int sam_index_build2(const char *fn, const char *fnidx, int min_shift)$/;"	f
sam_index_build3	sam.c	/^int sam_index_build3(const char *fn, const char *fnidx, int min_shift, int nthreads)$/;"	f
sam_index_load	sam.c	/^hts_idx_t *sam_index_load(htsFile *fp, const char *fn)$/;"	f
sam_index_load2	sam.c	/^hts_idx_t *sam_index_load2(htsFile *fp, const char *fn, const char *fnidx)$/;"	f
sam_itr_destroy	htslib/sam.h	353;"	d
sam_itr_next	htslib/sam.h	356;"	d
sam_itr_queryi	sam.c	/^hts_itr_t *sam_itr_queryi(const hts_idx_t *idx, int tid, int beg, int end)$/;"	f
sam_itr_querys	sam.c	/^hts_itr_t *sam_itr_querys(const hts_idx_t *idx, bam_hdr_t *hdr, const char *region)$/;"	f
sam_open	htslib/sam.h	362;"	d
sam_open_format	htslib/sam.h	363;"	d
sam_open_mode	sam.c	/^int sam_open_mode(char *mode, const char *fn, const char *format)$/;"	f
sam_open_mode_opts	sam.c	/^char *sam_open_mode_opts(const char *fn,$/;"	f
sam_parse1	sam.c	/^int sam_parse1(kstring_t *s, bam_hdr_t *h, bam1_t *b)$/;"	f
sam_prob_realn	realn.c	/^int sam_prob_realn(bam1_t *b, const char *ref, int ref_len, int flag)$/;"	f
sam_read1	sam.c	/^int sam_read1(htsFile *fp, bam_hdr_t *h, bam1_t *b)$/;"	f
sam_sort_order	cram/sam_header.h	/^enum sam_sort_order {$/;"	g
sam_to_Ccram	test/cross_validate.sh	/^sam_to_Ccram() {$/;"	f
sam_to_Jcram	test/cross_validate.sh	/^sam_to_Jcram() {$/;"	f
sam_write1	sam.c	/^int sam_write1(htsFile *fp, const bam_hdr_t *h, const bam1_t *b)$/;"	f
samples	htslib/synced_bcf_reader.h	/^    char **samples; \/\/ List of samples$/;"	m	struct:__anon31
samples	htslib/synced_bcf_reader.h	/^    int *samples, n_smpl;   \/\/ list of columns in the order consistent with bcf_srs_t.samples$/;"	m	struct:__anon29
samples	htslib/vcf.h	/^    char **samples;$/;"	m	struct:__anon19
samrecord_layout	test/sam.c	/^static void samrecord_layout(void)$/;"	f	file:
sanitise_SQ_lines	cram/cram_io.c	/^static void sanitise_SQ_lines(cram_fd *fd) {$/;"	f	file:
save_bin	hts.c	/^        uint32_t last_bin, save_bin;$/;"	m	struct:__hts_idx_t::__anon3	file:
save_off	hts.c	/^        uint64_t last_off, save_off;$/;"	m	struct:__hts_idx_t::__anon3	file:
save_tid	hts.c	/^        int last_coor, last_tid, save_tid, finished;$/;"	m	struct:__hts_idx_t::__anon3	file:
save_vcf	test/test-bcf-sr.pl	/^sub save_vcf$/;"	s
sc	htslib/tbx.h	/^    int32_t sc, bc, ec; \/\/ seq col., beg col. and end col.$/;"	m	struct:__anon34
scan_keyword	hts.c	/^scan_keyword(const char *str, char delim, char *buf, size_t buflen)$/;"	f	file:
score	bcf_sr_sort.h	/^    uint8_t score[256];$/;"	m	struct:__anon118
sdict	htslib/sam.h	/^    void *sdict;$/;"	m	struct:__anon36
sdict_t	sam.c	/^typedef khash_t(s2i) sdict_t;$/;"	t	file:
se	tbx.c	/^    char *ss, *se;$/;"	m	struct:__anon113	file:
secret	hfile_s3.c	/^    kstring_t secret;$/;"	m	struct:__anon53	file:
seek	htslib/hfile.h	/^	off_t (*seek)(void* cb_data, off_t ofs, int whence);$/;"	m	struct:hFILE_callback_ops
seek_offset	htslib/knetfile.h	/^	int64_t seek_offset; \/\/ for lazy seek$/;"	m	struct:knetFile_s
send_callback	hfile_libcurl.c	/^static size_t send_callback(char *ptr, size_t size, size_t nmemb, void *fpv)$/;"	f	file:
sep	htslib/kstring.h	/^	int sep, finished;$/;"	m	struct:__anon32
seq	cram/cram_structs.h	/^    char *seq;$/;"	m	struct:ref_entry
seq	cram/cram_structs.h	/^    int32_t seq;          \/\/ idx to s->seqs_blk$/;"	m	struct:cram_record
seq	regidx.c	/^    reglist_t *seq;     \/\/ regions for each sequence$/;"	m	struct:_regidx_t	file:
seq2regs	regidx.c	/^    void *seq2regs;     \/\/ hash for fast lookup from chr name to regions$/;"	m	struct:_regidx_t	file:
seq_hash	htslib/synced_bcf_reader.h	/^    void *seq_hash;         \/\/ keys: sequence names, values: index to seqs$/;"	m	struct:_bcf_sr_regions_t
seq_idx	cram/cram_structs.h	/^	    int seq_idx; \/\/ index to s->seqs_blk$/;"	m	struct:cram_feature::__anon81::__anon84
seq_idx	cram/cram_structs.h	/^	    int seq_idx; \/\/ insertion multiple bases$/;"	m	struct:cram_feature::__anon81::__anon87
seq_idx	cram/cram_structs.h	/^	    int seq_idx; \/\/ soft-clip multiple bases$/;"	m	struct:cram_feature::__anon81::__anon86
seq_names	htslib/synced_bcf_reader.h	/^    char **seq_names;       \/\/ sequence names$/;"	m	struct:_bcf_sr_regions_t
seq_names	regidx.c	/^    char **seq_names;$/;"	m	struct:_regidx_t	file:
seq_nt16_int	hts.c	/^const int seq_nt16_int[] = { 4, 0, 1, 4, 2, 4, 4, 4, 3, 4, 4, 4, 4, 4, 4, 4 };$/;"	v
seq_nt16_str	hts.c	/^const char seq_nt16_str[] = "=ACMGRSVTWYHKDBN";$/;"	v
seq_nt16_table	hts.c	/^const unsigned char seq_nt16_table[256] = {$/;"	v
seqs_blk	cram/cram_structs.h	/^    cram_block *seqs_blk;$/;"	m	struct:cram_slice
seqs_per_slice	cram/cram_structs.h	/^    int seqs_per_slice;$/;"	m	struct:cram_fd
sequence_data	htslib/hts.h	/^    sequence_data,    \/\/ Sequence data -- SAM, BAM, CRAM, etc$/;"	e	enum:htsFormatCategory
serial	thread_pool_internal.h	/^    uint64_t serial; \/\/ sequential number for ordering$/;"	m	struct:hts_tpool_result
serial	thread_pool_internal.h	/^    uint64_t serial;$/;"	m	struct:hts_tpool_job
serialize_float_array	vcf.c	/^static inline int serialize_float_array(kstring_t *s, size_t n, const float *a) {$/;"	f	file:
set_u	probaln.c	44;"	d	file:
setup	test/test_bgzf.c	/^static int setup(const char *src, Files *f) {$/;"	f	file:
share	hfile_libcurl.c	/^    CURLSH *share;$/;"	m	struct:__anon103	file:
share_lock	hfile_libcurl.c	/^static void share_lock(CURL *handle, curl_lock_data data,$/;"	f	file:
share_unlock	hfile_libcurl.c	/^static void share_unlock(CURL *handle, curl_lock_data data, void *userptr) {$/;"	f	file:
shared	htslib/vcf.h	/^    kstring_t shared, indiv;$/;"	m	struct:__anon25
shared_dirty	htslib/vcf.h	/^    int shared_dirty;   \/\/ if set, shared.s must be recreated on BCF output$/;"	m	struct:__anon24
shared_ref	cram/cram_structs.h	/^    int shared_ref;$/;"	m	struct:cram_fd
show_headers	htsfile.c	/^int show_headers = 1;$/;"	v
shutdown	thread_pool_internal.h	/^    int shutdown;                    \/\/ true if pool is being destroyed$/;"	m	struct:hts_tpool_process
shutdown	thread_pool_internal.h	/^    int shutdown; \/\/ true if pool is being destroyed$/;"	m	struct:hts_tpool
size	bgzf.c	/^    int size;$/;"	m	struct:__anon51	file:
size	cram/cram_structs.h	/^    int size;   \/* Size *\/$/;"	m	struct:cram_map
size	cram/mFILE.h	/^    size_t size;$/;"	m	struct:__anon58
size	hfile_libcurl.c	/^    unsigned int size;$/;"	m	struct:__anon98	file:
size	htslib/vcf.h	/^    int n, size, type;  \/\/ n: number of values per-sample; size: number of bytes per-sample; type: one of BCF_BT_* types$/;"	m	struct:__anon21
size	vcf.c	/^    int key, max_m, size, offset;$/;"	m	struct:__anon50	file:
size_cmd	htslib/knetfile.h	/^	char *response, *retr, *size_cmd;$/;"	m	struct:knetFile_s
skip_aux	sam.c	/^static inline uint8_t *skip_aux(uint8_t *s, uint8_t *end)$/;"	f	file:
skip_value	textutils.c	/^static char skip_value(char type, hts_json_nextfn *next, void *arg1, void *arg2)$/;"	f	file:
slice	cram/cram_structs.h	/^    int     slice;  \/\/ 1.0 landmark index, 1.1 landmark value$/;"	m	struct:cram_index
slice	cram/cram_structs.h	/^    struct cram_slice **slices, *slice;$/;"	m	struct:cram_container	typeref:struct:cram_container::
slice_rec	cram/cram_structs.h	/^    int slice_rec;               \/\/ rec no. for start of this slice$/;"	m	struct:cram_container
slices	cram/cram_structs.h	/^    struct cram_slice **slices, *slice;$/;"	m	struct:cram_container	typeref:struct:cram_container::cram_slice
slices_per_container	cram/cram_structs.h	/^    int slices_per_container;$/;"	m	struct:cram_fd
slurp	test/hfile.c	/^char *slurp(const char *filename)$/;"	f
snext	textutils.c	/^static char snext(void *arg1, void *arg2, hts_json_token *token)$/;"	f	file:
socket_connect	knetfile.c	/^static SOCKET socket_connect(const char *host, const char *port)$/;"	f	file:
socket_connect	knetfile.c	/^static int socket_connect(const char *host, const char *port)$/;"	f	file:
socket_wait	knetfile.c	/^static int socket_wait(int fd, int is_read)$/;"	f	file:
soft_blk	cram/cram_structs.h	/^    cram_block *soft_blk;$/;"	m	struct:cram_slice
sort	synced_bcf_reader.c	/^    sr_sort_t sort;$/;"	m	struct:__anon106	file:
sort_order	cram/sam_header.h	/^    enum sam_sort_order sort_order; \/\/!< @HD SO: field$/;"	m	struct:__anon65	typeref:enum:__anon65::sam_sort_order
spare_bams	cram/cram_structs.h	/^typedef struct spare_bams {$/;"	s
spare_bams	cram/cram_structs.h	/^} spare_bams;$/;"	t	typeref:struct:spare_bams
specific	htslib/hts.h	/^    void *specific;  \/\/ format specific options; see struct hts_opt.$/;"	m	struct:htsFormat
squareB_opt	thread_pool.c	/^struct squareB_opt {$/;"	s	file:
sr	bcf_sr_sort.h	/^    bcf_srs_t *sr;$/;"	m	struct:__anon118
sr_sort_t	bcf_sr_sort.h	/^sr_sort_t;$/;"	t	typeref:struct:__anon118
srand48	htslib/hts_os.h	36;"	d
srandom	htslib/hts_os.h	55;"	d
src_bgzf	test/test_bgzf.c	/^    char *src_bgzf;$/;"	m	struct:__anon48	file:
src_idx	test/test_bgzf.c	/^    char *src_idx;$/;"	m	struct:__anon48	file:
src_plain	test/test_bgzf.c	/^    char *src_plain;$/;"	m	struct:__anon48	file:
ss	tbx.c	/^    char *ss, *se;$/;"	m	struct:__anon113	file:
sscan_string	textutils.c	/^static char *sscan_string(char *s)$/;"	f	file:
start	cram/cram_structs.h	/^    int     start;  \/\/ 1.0                 1.1$/;"	m	struct:cram_index
start	cram/cram_structs.h	/^    int start;$/;"	m	struct:__anon94
start	cram/rANS_byte.h	/^    uint16_t start;     \/\/ Start of range.$/;"	m	struct:__anon57
start	htslib/regidx.h	/^    uint32_t start, end;$/;"	m	struct:__anon26
start	htslib/synced_bcf_reader.h	/^    int start, end;         \/\/ current position: start, end of the region (0-based)$/;"	m	struct:_bcf_sr_regions_t
start	synced_bcf_reader.c	/^    uint32_t start, end;$/;"	m	struct:__anon105	file:
start_prev	regidx.c	/^    int rid_prev, start_prev, end_prev;$/;"	m	struct:_regidx_t	file:
stats	cram/cram_structs.h	/^    cram_stats *stats[DS_END];$/;"	m	struct:cram_container
status	htsfile.c	/^int status = EXIT_SUCCESS;  \/* Exit status from main *\/$/;"	v
status	test/sam.c	/^int status;$/;"	v
stop	cram/cram_codecs.h	/^    unsigned char stop;$/;"	m	struct:__anon76
store	cram/cram_codecs.h	/^    int (*store)(struct cram_codec *codec, cram_block *b, char *prefix,$/;"	m	struct:cram_codec
store_bits_MSB	cram/cram_codecs.c	/^static int store_bits_MSB(cram_block *block, unsigned int val, int nbits) {$/;"	f	file:
str	bcf_sr_sort.h	/^    char *str;      \/\/ "A>C" for biallelic records or "A>C,A>CC" for multiallelic records$/;"	m	struct:__anon115
str	bcf_sr_sort.h	/^    kstring_t str;$/;"	m	struct:__anon118
str	cram/sam_header.h	/^    char *str;$/;"	m	struct:SAM_hdr_tag_s
str	cram/string_alloc.h	/^    char *str;$/;"	m	struct:__anon60
str	hts_internal.h	/^    char *str;    \/\/\/< Value as a C string (filled in for all token types)$/;"	m	struct:hts_json_token
str	regidx.c	/^    kstring_t str;$/;"	m	struct:_regidx_t	file:
str	test/sam.c	102;"	d	file:
str_pool	cram/sam_header.h	/^    string_alloc_t *str_pool; \/\/!< Pool of SAM_hdr_tag->str strings$/;"	m	struct:__anon65
strat	cram/cram_structs.h	/^    int strat;$/;"	m	struct:__anon80
streaming	htslib/synced_bcf_reader.h	/^    int streaming;      \/\/ reading mode: index-jumping or streaming$/;"	m	struct:__anon31
string_alloc	cram/string_alloc.c	/^char *string_alloc(string_alloc_t *a_str, size_t length) {$/;"	f
string_alloc_t	cram/string_alloc.h	/^} string_alloc_t;$/;"	t	typeref:struct:__anon61
string_dup	cram/string_alloc.c	/^char *string_dup(string_alloc_t *a_str, char *instr) {$/;"	f
string_ndup	cram/string_alloc.c	/^char *string_ndup(string_alloc_t *a_str, char *instr, size_t len) {$/;"	f
string_pool_create	cram/string_alloc.c	/^string_alloc_t *string_pool_create(size_t max_length) {$/;"	f
string_pool_destroy	cram/string_alloc.c	/^void string_pool_destroy(string_alloc_t *a_str) {$/;"	f
string_t	cram/string_alloc.h	/^} string_t;$/;"	t	typeref:struct:__anon60
stringify_argv	cram/sam_header.c	/^char *stringify_argv(int argc, char *argv[]) {$/;"	f
strings	cram/string_alloc.h	/^    string_t *strings;$/;"	m	struct:__anon61
strtoint64	knetfile.c	/^int64_t strtoint64(const char *buf)$/;"	f
sub_idx	cram/cram_encode.c	/^static int sub_idx(char *key, char val) {$/;"	f	file:
subexp	cram/cram_codecs.h	/^	cram_subexp_decoder          subexp;$/;"	m	union:cram_codec::__anon78
substitution_matrix	cram/cram_structs.h	/^    char substitution_matrix[5][4];$/;"	m	struct:cram_block_compression_hdr
suffix	hts_internal.h	/^    const char *pathdir, *prefix, *suffix;$/;"	m	struct:hts_path_itr
suffix_len	hts_internal.h	/^    size_t prefix_len, suffix_len, entry_dir_l;$/;"	m	struct:hts_path_itr
sw_fill_buffer	vcf_sweep.c	/^static void sw_fill_buffer(bcf_sweep_t *sw)$/;"	f	file:
sw_rec_equal	vcf_sweep.c	/^static inline int sw_rec_equal(bcf_sweep_t *sw, bcf1_t *rec)$/;"	f	file:
sw_rec_save	vcf_sweep.c	/^static void sw_rec_save(bcf_sweep_t *sw, bcf1_t *rec)$/;"	f	file:
sw_seek	vcf_sweep.c	/^static void sw_seek(bcf_sweep_t *sw, int direction)$/;"	f	file:
swap_bins	hts.c	/^static inline void swap_bins(bins_t *p)$/;"	f	file:
swap_data	sam.c	/^static void swap_data(const bam1_core_t *c, int l_data, uint8_t *data, int is_host)$/;"	f	file:
symbol	cram/cram_codecs.h	/^    int32_t symbol;$/;"	m	struct:__anon68
sysconf	cram/os.h	210;"	d
sz_bzip2	cram/cram_structs.h	/^    int sz_bzip2;$/;"	m	struct:__anon80
sz_gz_def	cram/cram_structs.h	/^    int sz_gz_def;$/;"	m	struct:__anon80
sz_gz_rle	cram/cram_structs.h	/^    int sz_gz_rle;$/;"	m	struct:__anon80
sz_lzma	cram/cram_structs.h	/^    int sz_lzma;$/;"	m	struct:__anon80
sz_rans0	cram/cram_structs.h	/^    int sz_rans0;$/;"	m	struct:__anon80
sz_rans1	cram/cram_structs.h	/^    int sz_rans1;$/;"	m	struct:__anon80
t	thread_pool_internal.h	/^    hts_tpool_worker *t;$/;"	m	struct:hts_tpool
t16_bit	test/hts_endian.c	/^static int t16_bit(int verbose) {$/;"	f	file:
t32_bit	test/hts_endian.c	/^static int t32_bit(int verbose) {$/;"	f	file:
t64_bit	test/hts_endian.c	/^static int t64_bit(int verbose) {$/;"	f	file:
t_double	test/hts_endian.c	/^int t_double(int verbose) {$/;"	f
t_float	test/hts_endian.c	/^int t_float(int verbose) {$/;"	f
t_stack	thread_pool_internal.h	/^    int *t_stack, t_stack_top;$/;"	m	struct:hts_tpool
t_stack_top	thread_pool_internal.h	/^    int *t_stack, t_stack_top;$/;"	m	struct:hts_tpool
tab	htslib/kstring.h	/^	uint64_t tab[4];$/;"	m	struct:__anon32
tabix_test	test/tabix/test-tabix.sh	/^tabix_test() {$/;"	f
tag	cram/sam_header.h	/^    SAM_hdr_tag  *tag;$/;"	m	struct:__anon62
tag	cram/sam_header.h	/^    SAM_hdr_tag  *tag;$/;"	m	struct:__anon63
tag	cram/sam_header.h	/^    SAM_hdr_tag  *tag;$/;"	m	struct:__anon64
tag	cram/sam_header.h	/^    SAM_hdr_tag *tag;            \/\/ first tag$/;"	m	struct:SAM_hdr_item_s
tag_encoding_map	cram/cram_structs.h	/^    struct cram_map *tag_encoding_map[CRAM_MAP_HASH];$/;"	m	struct:cram_block_compression_hdr	typeref:struct:cram_block_compression_hdr::cram_map
tag_pool	cram/sam_header.h	/^    pool_alloc_t   *tag_pool; \/\/!< Pool of SAM_hdr_tag structs$/;"	m	struct:__anon65
tags_used	cram/cram_structs.h	/^    khash_t(m_metrics) *tags_used; \/\/ cram_metrics[], per tag types in use.$/;"	m	struct:cram_fd
tags_used	cram/cram_structs.h	/^    khash_t(m_tagmap) *tags_used; \/\/ set of tag types in use, for tag encoding map$/;"	m	struct:cram_container
tail	sam.c	/^    lbnode_t *head, *tail;$/;"	m	struct:__bam_plp_t	file:
target_len	htslib/sam.h	/^    uint32_t *target_len;$/;"	m	struct:__anon36
target_name	htslib/sam.h	/^    char **target_name;$/;"	m	struct:__anon36
targets	htslib/synced_bcf_reader.h	/^    bcf_sr_regions_t *regions, *targets;    \/\/ see bcf_sr_set_[targets|regions] for description$/;"	m	struct:__anon31
targets_als	htslib/synced_bcf_reader.h	/^    int targets_als;    \/\/ subset to targets not only by position but also by alleles?$/;"	m	struct:__anon31
targets_exclude	htslib/synced_bcf_reader.h	/^    int targets_exclude;$/;"	m	struct:__anon31
targets_fname	tabix.c	/^    char *regions_fname, *targets_fname;$/;"	m	struct:__anon97	file:
tbi	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
tbx	htslib/synced_bcf_reader.h	/^    tbx_t *tbx;             \/\/ tabix index$/;"	m	struct:_bcf_sr_regions_t
tbx_bgzf_itr_next	htslib/tbx.h	61;"	d
tbx_conf_bed	tbx.c	/^const tbx_conf_t tbx_conf_bed = { TBX_UCSC, 1, 2, 3, '#', 0 };$/;"	v
tbx_conf_psltbl	tbx.c	/^const tbx_conf_t tbx_conf_psltbl = { TBX_UCSC, 15, 17, 18, '#', 0 };$/;"	v
tbx_conf_sam	tbx.c	/^const tbx_conf_t tbx_conf_sam = { TBX_SAM, 3, 4, 0, '@', 0 };$/;"	v
tbx_conf_t	htslib/tbx.h	/^} tbx_conf_t;$/;"	t	typeref:struct:__anon34
tbx_conf_vcf	tbx.c	/^const tbx_conf_t tbx_conf_vcf = { TBX_VCF, 1, 2, 0, '#', 0 };$/;"	v
tbx_destroy	tbx.c	/^void tbx_destroy(tbx_t *tbx)$/;"	f
tbx_idx	htslib/synced_bcf_reader.h	/^    tbx_t *tbx_idx;$/;"	m	struct:__anon29
tbx_index	tbx.c	/^tbx_t *tbx_index(BGZF *fp, int min_shift, const tbx_conf_t *conf)$/;"	f
tbx_index_build	tbx.c	/^int tbx_index_build(const char *fn, int min_shift, const tbx_conf_t *conf)$/;"	f
tbx_index_build2	tbx.c	/^int tbx_index_build2(const char *fn, const char *fnidx, int min_shift, const tbx_conf_t *conf)$/;"	f
tbx_index_build3	tbx.c	/^int tbx_index_build3(const char *fn, const char *fnidx, int min_shift, int n_threads, const tbx_conf_t *conf)$/;"	f
tbx_index_load	tbx.c	/^tbx_t *tbx_index_load(const char *fn)$/;"	f
tbx_index_load2	tbx.c	/^tbx_t *tbx_index_load2(const char *fn, const char *fnidx)$/;"	f
tbx_intv_t	tbx.c	/^} tbx_intv_t;$/;"	t	typeref:struct:__anon113	file:
tbx_itr_destroy	htslib/tbx.h	57;"	d
tbx_itr_next	htslib/tbx.h	60;"	d
tbx_itr_queryi	htslib/tbx.h	58;"	d
tbx_itr_querys	htslib/tbx.h	59;"	d
tbx_name2id	tbx.c	/^int tbx_name2id(tbx_t *tbx, const char *ss)$/;"	f
tbx_parse1	tbx.c	/^int tbx_parse1(const tbx_conf_t *conf, int len, char *line, tbx_intv_t *intv)$/;"	f
tbx_readrec	tbx.c	/^int tbx_readrec(BGZF *fp, void *tbxv, void *sv, int *tid, int *beg, int *end)$/;"	f
tbx_seqnames	tbx.c	/^const char **tbx_seqnames(tbx_t *tbx, int *n)$/;"	f
tbx_set_meta	tbx.c	/^void tbx_set_meta(tbx_t *tbx)$/;"	f
tbx_t	htslib/tbx.h	/^} tbx_t;$/;"	t	typeref:struct:__anon35
test_and_fetch	hts.c	/^static int test_and_fetch(const char *fn, const char **local_fn)$/;"	f	file:
test_bcf_sr_sort	test/test.pl	/^sub test_bcf_sr_sort$/;"	s
test_bgzf_getline	test/test_bgzf.c	/^static int test_bgzf_getline(Files *f, const char *mode, int nthreads) {$/;"	f	file:
test_check_EOF	test/test_bgzf.c	/^static int test_check_EOF(char *name, int expected) {$/;"	f	file:
test_cmd	test/test.pl	/^sub test_cmd$/;"	s
test_command	test/test.pl	/^sub test_command$/;"	s
test_convert_padded_header	test/test.pl	/^sub test_convert_padded_header$/;"	s
test_embed_eof	test/test_bgzf.c	/^static int test_embed_eof(Files *f, const char *mode, int nthreads) {$/;"	f	file:
test_get_format_values	test/test-vcf-api.c	/^void test_get_format_values(const char *fname)$/;"	f
test_get_info_values	test/test-vcf-api.c	/^void test_get_info_values(const char *fname)$/;"	f
test_index_load_dump	test/test_bgzf.c	/^static int test_index_load_dump(Files *f) {$/;"	f	file:
test_index_seek_getc	test/test_bgzf.c	/^static int test_index_seek_getc(Files *f, const char *mode,$/;"	f	file:
test_logging	test/test.pl	/^sub test_logging$/;"	s
test_op	test/test_view.c	/^enum test_op {$/;"	g	file:
test_pipe	thread_pool.c	/^int test_pipe(int n) {$/;"	f
test_read	test/test_bgzf.c	/^static int test_read(Files *f) {$/;"	f	file:
test_rebgzip	test/test.pl	/^sub test_rebgzip$/;"	s
test_square	thread_pool.c	/^int test_square(int n) {$/;"	f
test_squareB	thread_pool.c	/^int test_squareB(int n) {$/;"	f
test_squareB_dispatcher	thread_pool.c	/^static void *test_squareB_dispatcher(void *arg) {$/;"	f	file:
test_square_u	thread_pool.c	/^int test_square_u(int n) {$/;"	f
test_vcf_api	test/test.pl	/^sub test_vcf_api$/;"	s
test_vcf_sweep	test/test.pl	/^sub test_vcf_sweep$/;"	s
test_vcf_various	test/test.pl	/^sub test_vcf_various$/;"	s
test_view	test/test.pl	/^sub test_view$/;"	s
test_write_read	test/test_bgzf.c	/^static int test_write_read(Files *f, const char *mode, Open_method method,$/;"	f	file:
tests_16_bit	test/hts_endian.c	/^Test16 tests_16_bit[] = {$/;"	v
tests_32_bit	test/hts_endian.c	/^Test32 tests_32_bit[] = {$/;"	v
tests_64_bit	test/hts_endian.c	/^Test64 tests_64_bit[] = {$/;"	v
tests_double	test/hts_endian.c	/^Test_double tests_double[] = {$/;"	v
tests_float	test/hts_endian.c	/^Test_float tests_float[] = {$/;"	v
testv	test/test.pl	/^sub testv {$/;"	s
text	cram/sam_header.h	/^    kstring_t text;           \/\/!< concatenated text, indexed by SAM_hdr_tag$/;"	m	struct:__anon65
text	htslib/sam.h	/^    char *text;$/;"	m	struct:__anon36
text	test/test_bgzf.c	/^    const unsigned char *text;$/;"	m	struct:__anon48	file:
text_format	htslib/hts.h	/^    binary_format, text_format,$/;"	e	enum:htsExactFormat
thread_pool_internal_h	Makefile	/^thread_pool_internal_h = thread_pool_internal.h $(htslib_thread_pool_h)$/;"	m
tid	htslib/hts.h	/^    int tid, beg, end, n_off, i;$/;"	m	struct:__anon14
tid	htslib/sam.h	/^    int32_t tid;$/;"	m	struct:__anon37
tid	sam.c	/^    int32_t tid, pos, max_tid, max_pos;$/;"	m	struct:__bam_plp_t	file:
tid	tbx.c	/^    int tid;$/;"	m	struct:__anon113	file:
tid	thread_pool_internal.h	/^    pthread_t tid;$/;"	m	struct:__anon6
tlen	cram/cram_structs.h	/^    int32_t tlen;         \/\/ TS$/;"	m	struct:cram_record
tlen_approx	cram/cram_structs.h	/^    int tlen_approx;                    \/\/ max TLEN calculation offset.$/;"	m	struct:cram_fd
tlen_zero	cram/cram_structs.h	/^    int tlen_zero;                      \/\/ If true, permit tlen 0 (=> tlen calculated)$/;"	m	struct:cram_fd
tmp_bgzf	test/test_bgzf.c	/^    char *tmp_bgzf;$/;"	m	struct:__anon48	file:
tmp_idx	test/test_bgzf.c	/^    char *tmp_idx;$/;"	m	struct:__anon48	file:
tmp_suffix	test/test_bgzf.c	/^const char *tmp_suffix  = ".tmp";$/;"	v
tmps	htslib/synced_bcf_reader.h	/^    kstring_t tmps;$/;"	m	struct:__anon31
tn	cram/cram_structs.h	/^    int32_t tn;           \/\/ idx to s->tn_blk$/;"	m	struct:cram_record
tn_blk	cram/cram_structs.h	/^    cram_block *tn_blk;$/;"	m	struct:cram_slice
tn_id	cram/cram_structs.h	/^    int tn_id;$/;"	m	struct:cram_slice
to_hex	test/hts_endian.c	/^static char * to_hex(uint8_t *buf, int len) {$/;"	f	file:
token	hfile_s3.c	/^    kstring_t token;$/;"	m	struct:__anon53	file:
token_type	textutils.c	/^static char token_type(hts_json_token *token)$/;"	f	file:
tokenise_search_path	cram/open_trace_file.c	/^char *tokenise_search_path(char *searchpath) {$/;"	f
tolower_c	hts_internal.h	/^static inline char tolower_c(char c) { return tolower((unsigned char) c); }$/;"	f
total_time	thread_pool_internal.h	/^    long long total_time, wait_time;$/;"	m	struct:hts_tpool
toupper_c	hts_internal.h	/^static inline char toupper_c(char c) { return toupper((unsigned char) c); }$/;"	f
tpool_worker	thread_pool.c	/^static void *tpool_worker(void *arg) {$/;"	f	file:
transl	htslib/vcf.h	/^    int ntransl, *transl[2];    \/\/ for bcf_translate()$/;"	m	struct:__anon19
trial	cram/cram_structs.h	/^    int trial;$/;"	m	struct:__anon80
try_bgzf_close	test/test_bgzf.c	/^static int try_bgzf_close(BGZF **bgz, const char *name, const char *func) {$/;"	f	file:
try_bgzf_compression	test/test_bgzf.c	/^static int try_bgzf_compression(BGZF *fp, int expect,$/;"	f	file:
try_bgzf_dopen	test/test_bgzf.c	/^static BGZF * try_bgzf_dopen(const char *name, const char *mode,$/;"	f	file:
try_bgzf_getc	test/test_bgzf.c	/^static int try_bgzf_getc(BGZF *fp, size_t pos, int expected,$/;"	f	file:
try_bgzf_hopen	test/test_bgzf.c	/^static BGZF * try_bgzf_hopen(const char *name, const char *mode,$/;"	f	file:
try_bgzf_index_build_init	test/test_bgzf.c	/^static int try_bgzf_index_build_init(BGZF *bgz,$/;"	f	file:
try_bgzf_index_dump	test/test_bgzf.c	/^static int try_bgzf_index_dump(BGZF *fp, const char *bname, const char *suffix,$/;"	f	file:
try_bgzf_index_load	test/test_bgzf.c	/^static int try_bgzf_index_load(BGZF *fp, const char *bname, const char *suffix,$/;"	f	file:
try_bgzf_mt	test/test_bgzf.c	/^static int try_bgzf_mt(BGZF *bgz, int nthreads, const char *func) {$/;"	f	file:
try_bgzf_open	test/test_bgzf.c	/^static BGZF * try_bgzf_open(const char *name, const char *mode,$/;"	f	file:
try_bgzf_read	test/test_bgzf.c	/^static ssize_t try_bgzf_read(BGZF *fp, void *data, size_t length,$/;"	f	file:
try_bgzf_useek	test/test_bgzf.c	/^static int try_bgzf_useek(BGZF *fp, long uoffset, int where,$/;"	f	file:
try_bgzf_write	test/test_bgzf.c	/^static ssize_t try_bgzf_write(BGZF *fp, const void *data, size_t length,$/;"	f	file:
try_fclose	test/test_bgzf.c	/^static int try_fclose(FILE **file, const char *name, const char *func) {$/;"	f	file:
try_fopen	test/test_bgzf.c	/^static FILE * try_fopen(const char *name, const char *mode) {$/;"	f	file:
try_fread	test/test_bgzf.c	/^static ssize_t try_fread(FILE *in, void *buf, size_t len,$/;"	f	file:
try_fseek_start	test/test_bgzf.c	/^static int try_fseek_start(FILE *f, const char *name, const char *func) {$/;"	f	file:
tsize	thread_pool_internal.h	/^    int tsize;    \/\/ maximum number of jobs$/;"	m	struct:hts_tpool
tweak_overlap_quality	sam.c	/^static void tweak_overlap_quality(bam1_t *a, bam1_t *b)$/;"	f	file:
ty	cram/sam_header.h	/^    SAM_hdr_type *ty;$/;"	m	struct:__anon62
ty	cram/sam_header.h	/^    SAM_hdr_type *ty;$/;"	m	struct:__anon63
ty	cram/sam_header.h	/^    SAM_hdr_type *ty;$/;"	m	struct:__anon64
type	bcf_sr_sort.h	/^    int type;       \/\/ VCF_SNP, VCF_REF, etc.$/;"	m	struct:__anon115
type	cram/cram_codecs.h	/^    enum cram_external_type type;$/;"	m	struct:__anon74	typeref:enum:__anon74::cram_external_type
type	hts_internal.h	/^    char type;    \/\/\/< Token type$/;"	m	struct:hts_json_token
type	htslib/knetfile.h	/^	int type, fd;$/;"	m	struct:knetFile_s
type	htslib/vcf.h	/^    int n, size, type;  \/\/ n: number of values per-sample; size: number of bytes per-sample; type: one of BCF_BT_* types$/;"	m	struct:__anon21
type	htslib/vcf.h	/^    int type, len;  \/\/ type: one of BCF_BT_* types; len: vector length, 1 for scalars$/;"	m	struct:__anon22
type	htslib/vcf.h	/^    int type, n;    \/\/ variant type and the number of bases affected, negative for deletions$/;"	m	struct:__anon20
type	htslib/vcf.h	/^    int type;       \/\/ One of the BCF_HL_* type$/;"	m	struct:__anon16
type_pool	cram/sam_header.h	/^    pool_alloc_t   *type_pool;\/\/!< Pool of SAM_hdr_type structs$/;"	m	struct:__anon65
u	htslib/hts.h	/^    uint64_t u, v;$/;"	m	struct:__anon13
u16	test/hts_endian.c	/^    uint16_t u16;$/;"	m	struct:__anon43	file:
u16_to_le	htslib/hts_endian.h	/^static inline void u16_to_le(uint16_t val, uint8_t *buf) {$/;"	f
u32	test/hts_endian.c	/^    uint32_t u32;$/;"	m	struct:__anon44	file:
u32_to_le	htslib/hts_endian.h	/^static inline void u32_to_le(uint32_t val, uint8_t *buf) {$/;"	f
u64	test/hts_endian.c	/^    uint64_t u64;$/;"	m	struct:__anon45	file:
u64_to_le	htslib/hts_endian.h	/^static inline void u64_to_le(uint64_t val, uint8_t *buf) {$/;"	f
u8	test/hts_endian.c	/^    uint8_t u8[2];$/;"	m	struct:__anon43	file:
u8	test/hts_endian.c	/^    uint8_t u8[4];$/;"	m	struct:__anon44	file:
u8	test/hts_endian.c	/^    uint8_t u8[4];$/;"	m	struct:__anon46	file:
u8	test/hts_endian.c	/^    uint8_t u8[8];$/;"	m	struct:__anon45	file:
u8	test/hts_endian.c	/^    uint8_t u8[8];$/;"	m	struct:__anon47	file:
u8_unaligned	test/hts_endian.c	/^    uint8_t u8_unaligned[3];$/;"	m	struct:__anon43	file:
u8_unaligned	test/hts_endian.c	/^    uint8_t u8_unaligned[5];$/;"	m	struct:__anon44	file:
u8_unaligned	test/hts_endian.c	/^    uint8_t u8_unaligned[5];$/;"	m	struct:__anon46	file:
u8_unaligned	test/hts_endian.c	/^    uint8_t u8_unaligned[9];$/;"	m	struct:__anon45	file:
u8_unaligned	test/hts_endian.c	/^    uint8_t u8_unaligned[9];$/;"	m	struct:__anon47	file:
uaddr	bgzf.c	/^    uint64_t uaddr;  \/\/ offset w.r.t. uncompressed data$/;"	m	struct:__anon52	file:
ublock_addr	bgzf.c	/^    uint64_t ublock_addr;   \/\/ offset of the current block (uncompressed data)$/;"	m	struct:__bgzidx_t	file:
ubyte_t	kstring.c	/^typedef unsigned char ubyte_t;$/;"	t	file:
uc	cram/cram_structs.h	/^typedef unsigned char uc;$/;"	t
uint16_u	htslib/hts_endian.h	/^typedef uint16_t uint16_u __attribute__ ((__aligned__ (1)));$/;"	t
uint16_u	htslib/hts_endian.h	/^typedef uint16_t uint16_u;$/;"	t
uint32_u	htslib/hts_endian.h	/^typedef uint32_t uint32_u __attribute__ ((__aligned__ (1)));$/;"	t
uint32_u	htslib/hts_endian.h	/^typedef uint32_t uint32_u;$/;"	t
uint64_u	htslib/hts_endian.h	/^typedef uint64_t uint64_u __attribute__ ((__aligned__ (1)));$/;"	t
uint64_u	htslib/hts_endian.h	/^typedef uint64_t uint64_u;$/;"	t
uncomp	cram/cram_structs.h	/^    char *uncomp; \/\/ A single block of uncompressed data$/;"	m	struct:cram_block_compression_hdr
uncomp_alloc	cram/cram_structs.h	/^    size_t uncomp_size, uncomp_alloc;$/;"	m	struct:cram_block_compression_hdr
uncomp_data	bgzf.c	/^    unsigned char uncomp_data[BGZF_MAX_BLOCK_SIZE];$/;"	m	struct:bgzf_job	file:
uncomp_len	bgzf.c	/^    size_t uncomp_len;$/;"	m	struct:bgzf_job	file:
uncomp_size	cram/cram_structs.h	/^    int32_t  uncomp_size;$/;"	m	struct:cram_block
uncomp_size	cram/cram_structs.h	/^    size_t uncomp_size, uncomp_alloc;$/;"	m	struct:cram_block_compression_hdr
uncompressed_address	htslib/bgzf.h	/^    int64_t block_address, uncompressed_address;$/;"	m	struct:BGZF
uncompressed_block	htslib/bgzf.h	/^    void *uncompressed_block, *compressed_block;$/;"	m	struct:BGZF
unknown_category	htslib/hts.h	/^    unknown_category,$/;"	e	enum:htsFormatCategory
unknown_format	htslib/hts.h	/^    unknown_format,$/;"	e	enum:htsExactFormat
unmapped_placed	cram/cram_structs.h	/^    int unmapped_placed;$/;"	m	struct:cram_block_compression_hdr
unmapped_qs_included	cram/cram_structs.h	/^    int unmapped_qs_included;$/;"	m	struct:cram_block_compression_hdr
unpackInt16	bgzf.c	/^static inline int unpackInt16(const uint8_t *buffer)$/;"	f	file:
unpack_size	htslib/vcf.h	/^    int unpack_size[3];     \/\/ the original block size of ID, REF+ALT and FILTER$/;"	m	struct:__anon25
unpacked	htslib/vcf.h	/^    int unpacked;           \/\/ remember what has been unpacked to allow calling bcf_unpack() repeatedly without redoing the work$/;"	m	struct:__anon25
unsorted	cram/cram_structs.h	/^    int unsorted;		 \/\/ true is AP_delta is 0.$/;"	m	struct:cram_container
unsorted	cram/cram_structs.h	/^    int unsorted;$/;"	m	struct:cram_fd
unused1	htslib/sam.h	/^    uint8_t unused1;$/;"	m	struct:__anon37
update_loff	hts.c	/^static void update_loff(hts_idx_t *idx, int i, int free_lidx)$/;"	f	file:
url	multipart.c	/^    char *url;$/;"	m	struct:hfile_part	file:
urldecode_kput	hfile_s3.c	/^urldecode_kput(const char *s, int len, kstring_t *str)$/;"	f	file:
usage	htsfile.c	/^static void usage(FILE *fp, int status)$/;"	f	file:
usage	tabix.c	/^static int usage(void)$/;"	f	file:
usage	test/test-bcf-sr.c	/^void usage(void)$/;"	f
use_bz2	cram/cram_structs.h	/^    int use_bz2;$/;"	m	struct:cram_fd
use_lzma	cram/cram_structs.h	/^    int use_lzma;$/;"	m	struct:cram_fd
use_rans	cram/cram_structs.h	/^    int use_rans;$/;"	m	struct:cram_fd
used	cram/pooled_alloc.h	/^    size_t  used;$/;"	m	struct:__anon54
used	cram/string_alloc.h	/^    size_t used;$/;"	m	struct:__anon60
useragent	hfile_libcurl.c	/^    kstring_t useragent;$/;"	m	struct:__anon103	file:
usr	regidx.c	/^    void *usr;              \/\/ user data to pass to regidx_parse_f$/;"	m	struct:_regidx_t	file:
v	htslib/hts.h	/^    uint64_t u, v;$/;"	m	struct:__anon13
v1	htslib/vcf.h	/^    } v1; \/\/ only set if $len==1; for easier access$/;"	m	struct:__anon22	typeref:union:__anon22::__anon23
val	htslib/hts.h	/^    } val;$/;"	m	struct:hts_opt	typeref:union:hts_opt::__anon12
val	htslib/vcf.h	/^    const bcf_idinfo_t *val;$/;"	m	struct:__anon18
val2code	cram/cram_codecs.h	/^    int val2code[MAX_HUFF+1]; \/\/ value to code lookup for small values$/;"	m	struct:__anon70
val_codec	cram/cram_codecs.h	/^    struct cram_codec *val_codec;$/;"	m	struct:__anon75	typeref:struct:__anon75::cram_codec
val_codec	cram/cram_codecs.h	/^    struct cram_codec *val_codec;$/;"	m	struct:__anon77	typeref:struct:__anon77::cram_codec
val_dat	cram/cram_codecs.h	/^    void *val_dat;$/;"	m	struct:__anon77
val_encoding	cram/cram_codecs.h	/^    enum cram_encoding val_encoding;$/;"	m	struct:__anon77	typeref:enum:__anon77::cram_encoding
vals	htslib/vcf.h	/^    char **keys, **vals;    \/\/ The key=value pairs$/;"	m	struct:__anon16
value	htslib/vcf.h	/^    char *value;    \/\/ Set only for generic lines, NULL for FILTER\/INFO, etc.$/;"	m	struct:__anon16
var	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ list of compatible variants that can be output together$/;"	m	struct:__anon117
var	bcf_sr_sort.h	/^    int nvar, mvar, *var;   \/\/ the variants and their type$/;"	m	struct:__anon116
var	bcf_sr_sort.h	/^    var_t *var;             \/\/ list of all variants from all readers$/;"	m	struct:__anon118
var	htslib/vcf.h	/^    variant_t *var;     \/\/ $var and $var_type set only when set_variant_types called$/;"	m	struct:__anon24
var_str2int	bcf_sr_sort.h	/^    void *var_str2int;$/;"	m	struct:__anon118
var_t	bcf_sr_sort.h	/^var_t;$/;"	t	typeref:struct:__anon115
var_type	htslib/vcf.h	/^    int n_var, var_type;$/;"	m	struct:__anon24
var_type	test/test-bcf-sr.pl	/^sub var_type$/;"	s
variant_data	htslib/hts.h	/^    variant_data,     \/\/ Variant calling data -- VCF, BCF, etc$/;"	e	enum:htsFormatCategory
variant_t	htslib/vcf.h	/^} variant_t;$/;"	t	typeref:struct:__anon20
varset_t	bcf_sr_sort.h	/^varset_t;$/;"	t	typeref:struct:__anon117
vcf	bcf_sr_sort.h	/^    int nvcf, mvcf, *vcf;   \/\/ the list of readers with the same variants$/;"	m	struct:__anon115
vcf	htslib/hts.h	/^    sam, bam, bai, cram, crai, vcf, bcf, csi, gzi, tbi, bed,$/;"	e	enum:htsExactFormat
vcfFile	htslib/vcf.h	/^    typedef htsFile vcfFile;$/;"	t
vcf_buf	bcf_sr_sort.h	/^    vcf_buf_t *vcf_buf;     \/\/ records sorted in output order, for each VCF$/;"	m	struct:__anon118
vcf_buf_t	bcf_sr_sort.h	/^vcf_buf_t;$/;"	t	typeref:struct:__anon114
vcf_close	htslib/vcf.h	288;"	d
vcf_format	vcf.c	/^int vcf_format(const bcf_hdr_t *h, const bcf1_t *v, kstring_t *s)$/;"	f
vcf_format1	htslib/vcf.h	249;"	d
vcf_hdr_read	vcf.c	/^bcf_hdr_t *vcf_hdr_read(htsFile *fp)$/;"	f
vcf_hdr_write	vcf.c	/^int vcf_hdr_write(htsFile *fp, const bcf_hdr_t *h)$/;"	f
vcf_open	htslib/vcf.h	286;"	d
vcf_parse	vcf.c	/^int vcf_parse(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v)$/;"	f
vcf_parse1	htslib/vcf.h	247;"	d
vcf_parse_error	htslib/synced_bcf_reader.h	/^    header_error, no_eof, no_memory, vcf_parse_error, bcf_read_error$/;"	e	enum:__anon30
vcf_parse_format	vcf.c	/^static int vcf_parse_format(kstring_t *s, const bcf_hdr_t *h, bcf1_t *v, char *p, char *q)$/;"	f	file:
vcf_read	vcf.c	/^int vcf_read(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)$/;"	f
vcf_read1	htslib/vcf.h	242;"	d
vcf_write	vcf.c	/^int vcf_write(htsFile *fp, const bcf_hdr_t *h, bcf1_t *v)$/;"	f
vcf_write1	htslib/vcf.h	244;"	d
vcf_write_line	vcf.c	/^int vcf_write_line(htsFile *fp, kstring_t *line)$/;"	f
vdict_t	vcf.c	/^typedef khash_t(vdict) vdict_t;$/;"	t	file:
verbose	htsfile.c	/^int verbose = 0;$/;"	v
version	cram/cram_structs.h	/^    int            version;$/;"	m	struct:cram_fd
version	htslib/hts.h	/^    struct { short major, minor; } version;$/;"	m	struct:htsFormat	typeref:struct:htsFormat::__anon8
vhopen_libcurl	hfile_libcurl.c	/^static hFILE *vhopen_libcurl(const char *url, const char *modes, va_list args)$/;"	f	file:
view_all	htsfile.c	/^enum { identify, view_headers, view_all } mode = identify;$/;"	e	enum:__anon96	file:
view_headers	htsfile.c	/^enum { identify, view_headers, view_all } mode = identify;$/;"	e	enum:__anon96	file:
view_raw	htsfile.c	/^static void view_raw(hFILE *fp, const char *filename)$/;"	f	file:
view_sam	htsfile.c	/^static void view_sam(samFile *in, const char *filename)$/;"	f	file:
view_vcf	htsfile.c	/^static void view_vcf(vcfFile *in, const char *filename)$/;"	f	file:
vptr	htslib/vcf.h	/^    uint8_t *vptr;          \/\/ pointer to data array in bcf1_t->shared.s, excluding the size+type and tag id bytes$/;"	m	struct:__anon22
vptr_free	htslib/vcf.h	/^            vptr_free:1;    \/\/ indicates that vptr-vptr_off must be freed; set only when modified and the new$/;"	m	struct:__anon22
vptr_len	htslib/vcf.h	/^    uint32_t vptr_len;      \/\/ length of the vptr block or, when set, of the vptr_mod block, excluding offset$/;"	m	struct:__anon22
vptr_off	htslib/vcf.h	/^    uint32_t vptr_off:31,   \/\/ vptr offset, i.e., the size of the INFO key plus size+type bytes$/;"	m	struct:__anon22
vset	bcf_sr_sort.h	/^    varset_t *vset;         \/\/ list of variant sets - combinations of compatible variants across multiple groups ready for output$/;"	m	struct:__anon118
wait_perform	hfile_libcurl.c	/^static int wait_perform(hFILE_libcurl *fp)$/;"	f	file:
wait_time	thread_pool_internal.h	/^    long long total_time, wait_time;$/;"	m	struct:hts_tpool
wake_dispatch	thread_pool_internal.h	/^    int wake_dispatch;               \/\/ unblocks waiting dispatchers$/;"	m	struct:hts_tpool_process
wake_next_worker	thread_pool.c	/^static void wake_next_worker(hts_tpool_process *q, int locked) {$/;"	f	file:
worker_id	thread_pool.c	/^static int worker_id(hts_tpool *p) {$/;"	f	file:
wr	hfile_libcurl.c	/^        union { char *rd; const char *wr; } ptr;$/;"	m	union:__anon100::__anon101::__anon102	file:
write	htslib/hfile.h	/^	ssize_t (*write)(void* cb_data, const void* buf, size_t sz);$/;"	m	struct:hFILE_callback_ops
write_bcf	test/test-vcf-api.c	/^void write_bcf(char *fname)$/;"	f
write_format_values	test/test-vcf-api.c	/^void write_format_values(const char *fname)$/;"	f
writebuffer_is_nonempty	hfile.c	/^static inline int writebuffer_is_nonempty(hFILE *fp)$/;"	f	file:
x	cram/pooled_alloc.c	/^    int x, y, z;$/;"	m	struct:__anon66	file:
x	sam.c	/^    int k, x, y, end;$/;"	m	struct:__anon4	file:
x	thread_pool.c	/^    unsigned int x;$/;"	m	struct:__anon111	file:
x_max	cram/rANS_byte.h	/^    uint32_t x_max;     \/\/ (Exclusive) upper bound of pre-normalization interval$/;"	m	struct:__anon56
xstr	test/sam.c	103;"	d	file:
xyz	cram/pooled_alloc.c	/^} xyz;$/;"	t	typeref:struct:__anon66	file:
y	cram/pooled_alloc.c	/^    int x, y, z;$/;"	m	struct:__anon66	file:
y	sam.c	/^    int k, x, y, end;$/;"	m	struct:__anon4	file:
y	vcf.c	/^    uint32_t y;$/;"	m	struct:__anon50	file:
z	cram/pooled_alloc.c	/^    int x, y, z;$/;"	m	struct:__anon66	file:
z	hts.c	/^    } z; \/\/ keep internal states$/;"	m	struct:__hts_idx_t	typeref:struct:__hts_idx_t::__anon3	file:
zlib_mem_deflate	cram/cram_io.c	/^static char *zlib_mem_deflate(char *data, size_t size, size_t *cdata_size,$/;"	f	file:
zlib_mem_inflate	cram/cram_io.c	/^char *zlib_mem_inflate(char *cdata, size_t csize, size_t *size) {$/;"	f
